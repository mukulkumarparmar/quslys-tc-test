Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Qualys Gateway Configuration
        Parameters:
          - QToken
          - QEndpoint
      - Label:
          default: Scanner Configuration
        Parameters:
          - SingleRegionConcurrency
          - Concurrency
          - Regions
          - IntervalHours
          - EventsBatchWindow
          - PollRetryInterval
          - SwCA
          - SwCAScanIncludeDirs
          - SwCAScanExcludeDirs
          - SwCAScanTimeout
          - Secret
          - SecretScanIncludeDirs
          - SecretScanExcludeDirs
          - SecretScanTimeout
          - AMI
          - AMIOfflineScan
          - ScanSampling
          - SamplingGroupScanPercentage
      - Label:
          default: EC2 Tag Configuration
        Parameters:
          - MustHaveTagList
          - AtLeastOneInList
          - NoneInTheList
          - NoneOnVolume
      - Label:
          default: Scanner VPC Configuration
        Parameters:
          - VpcCidr
          - SubnetCidr
      - Label:
          default: Event Trigger Api Endpoint Configuration
        Parameters:
          - EnableCustomDomain
          - Route53DomainName
          - Route53DomainId
      - Label:
          default: Advanced Configuration
        Parameters:
          - ReleasePipeline
    ParameterLabels:
      QToken:
        default: SubscriptionToken
      QEndpoint:
        default: APIGatewayURL
      SingleRegionConcurrency:
        default: Scanner Instances Per Region
      Concurrency:
        default: Region Scan Concurrency
      Regions:
        default: Target Regions
      IntervalHours:
        default: Snapshot Refresh Interval
      EventsBatchWindow:
        default: Batch Trigger Scan Duration
      PollRetryInterval:
        default: Retry Discovery Interval
      SwCA:
        default: Software composition analysis (SwCA)
      SwCAScanIncludeDirs:
        default: Include Directories for SwCA
      SwCAScanExcludeDirs:
        default: Exclude Directories for SwCA
      SwCAScanTimeout:
        default: SwCA Scan Timeout
      Secret:
        default: Secret Scan
      SecretScanIncludeDirs:
        default: Include Directories for Secret Scan
      SecretScanExcludeDirs:
        default: Exclude Directories for Secret Scan
      SecretScanTimeout:
        default: Secret Scan Timeout
      AMI:
        default: AMI
      AMIOfflineScan:
        default: AMI Offline Scan
      ScanSampling:
        default: Scan Sampling
      SamplingGroupScanPercentage:
        default: Sampling Group Scan Percentage
      MustHaveTagList:
        default: Tag Filter - Include Instances (All Tags Required)
      AtLeastOneInList:
        default: Tag Filter - Include Instances (Any Tag Sufficient)
      NoneInTheList:
        default: Tag Filter - Exclude Instances (If Any Tag Matches)
      NoneOnVolume:
        default: Tag Filter - Exclude Volumes (If Any Tag Matches), Skips Instances If All Volumes Excluded
      EnableCustomDomain:
        default: Enable Custom Domain
      Route53DomainName:
        default: Route53 Domain Name
      Route53DomainId:
        default: Route53 Domain Id
      ReleasePipeline:
        default: ReleasePipeline
Parameters:
  QToken:
    Type: String
    AllowedPattern: ^[\w\-]{1,64}\.[\w\-]{1,1024}\.[\w\-]{20,100}$
    ConstraintDescription: Token should match the given constraint.
    Description: Follow the steps mentioned in UserGuide to generate SubscriptionToken :- https://docs.qualys.com/en/conn/latest/#t=scans%2Fsnapshot-based_scan.htm
    MinLength: 1
    NoEcho: true
  QEndpoint:
    Type: String
    AllowedPattern: ^(http(s):\/\/.)[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)$
    ConstraintDescription: It should be a valid URL.
    Description: Qualys API Gateway URL. Find the Gateway URL at https://www.qualys.com/platform-identification/
    MinLength: 1
  Regions:
    Type: List<String>
    Default: us-east-1
    AllowedValues:
      - us-east-1
      - us-east-2
      - us-west-1
      - us-west-2
      - af-south-1
      - ap-east-1
      - ap-south-2
      - ap-southeast-3
      - ap-southeast-4
      - ap-south-1
      - ap-northeast-3
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-northeast-1
      - ca-central-1
      - ca-west-1
      - eu-central-1
      - eu-west-1
      - eu-west-2
      - eu-south-1
      - eu-west-3
      - eu-south-2
      - eu-north-1
      - eu-central-2
      - il-central-1
      - me-south-1
      - me-central-1
      - sa-east-1
    Description: Provide the region(s) where the Snapshot scan runs. Eg, ap-south-1, us-east-1
    MinLength: 1
  SingleRegionConcurrency:
    Type: Number
    Default: 10
    Description: Provide the number of scanner instances to execute scans on a single region. The value must be between 1 and 50.
    MaxValue: 50
    MinValue: 1
  Concurrency:
    Type: Number
    Default: 2
    Description: Provide the number of regions to be concurrently scanned. The value must be between 1 and 5.
    MaxValue: 5
    MinValue: 1
  IntervalHours:
    Type: Number
    Default: 24
    Description: (Required) Set the interval to launch the next scan, which will capture a snapshot of the latest instance state. Provide the value in hours. The minimum value is 24 hours, and the maximum is 168 hours (7 days).
    MaxValue: 168
    MinValue: 24
  EventsBatchWindow:
    Type: Number
    Default: 10
    Description: (Required) Set the interval to launch the batch scan of instances discovered via events. Provide the value in minutes. The minimum value is 5 minutes, and the maximum is 12 hours.
    MaxValue: 720
    MinValue: 5
  PollRetryInterval:
    Type: Number
    Default: 60
    Description: (Required) Set the interval to launch a reattempt at discovering instances that may be missed during event-based discovery. Provide the value in minutes. The minimum value is 15 minutes, and the maximum is 12 hours.
    MaxValue: 720
    MinValue: 15
  SwCA:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Enable to scan and analyze your software components.
  SwCAScanIncludeDirs:
    Type: List<String>
    Default: ""
    Description: Specify directories for SwCA scanning. Leave empty to include all directories.
  SwCAScanExcludeDirs:
    Type: List<String>
    Default: ""
    Description: List directories to skip during SwCA and secret scans. Leave empty to exclude none.
  SwCAScanTimeout:
    Type: Number
    Default: 120
    Description: "Set maximum SwCA scan duration in seconds. Default: 120, Supported Range: 10-1200 seconds."
    MaxValue: 1200
    MinValue: 10
  Secret:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Enable to scan for exposed secrets in your code.
  SecretScanIncludeDirs:
    Type: List<String>
    Default: ""
    Description: Choose directories for secret scanning. Leave empty to scan all.
  SecretScanExcludeDirs:
    Type: List<String>
    Default: ""
    Description: List directories to skip during secret scans. Leave empty to exclude none.
  SecretScanTimeout:
    Type: Number
    Default: 120
    Description: "Set maximum secret scan duration in seconds. Default: 120, Supported Range: 10-1200 seconds."
    MaxValue: 1200
    MinValue: 10
  AMI:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Select 'Enabled' to use AMI scanning, which involves scanning AMIs for vulnerabilities.
  AMIOfflineScan:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Select 'Enabled' to start an offline scan using the last captured snapshot as soon as changes in vulnerability signatures are identified for AMI scanning.
  ScanSampling:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Select 'Enabled' to use scan sampling, which involves selecting and analyzing a subset of instances from a larger population to make inferences about the whole group.
  SamplingGroupScanPercentage:
    Type: Number
    Default: 10
    Description: Provide the percentage to execute scans on sampling group instances. The value must be between 1 and 50.
    MaxValue: 50
    MinValue: 1
  MustHaveTagList:
    Type: List<String>
    Default: ""
    Description: Provide comma seperated list of tagKey=tagValue pairs to filter instances for Snapshot scan. All tags must be present on the Instance
  AtLeastOneInList:
    Type: List<String>
    Default: ""
    Description: Provide comma seperated list of tagKey=tagValue pairs to filter instances for Snapshot scan. Any one tag must be present on the Instance
  NoneInTheList:
    Type: List<String>
    Default: ""
    Description: Provide comma seperated list of tagKey=tagValue pairs to EXCLUDE from filter instances for Snapshot scan. If any tag in the list is present on the Instance, it will be excluded
  NoneOnVolume:
    Type: List<String>
    Default: ""
    Description: Provide comma seperated list of tagKey=tagValue pairs to EXCLUDE Volumes for Snapshot scan. If any tag in the list is present on the Volume, it will be excluded. If all volumes are excluded on a Instance, Instance will be skipped during scan
  VpcCidr:
    Type: String
    Default: 10.10.0.0/16
    Description: Provide the Vpc Cidr. Eg, 10.82.64.0/22
    MinLength: 1
  SubnetCidr:
    Type: String
    Default: 10.10.1.0/24
    Description: Provide the Subnet Cidr. Eg, 10.82.64.0/22
    MinLength: 1
  EnableCustomDomain:
    Type: String
    Default: Disabled
    AllowedValues:
      - Enabled
      - Disabled
    Description: Select 'Enabled' to use custom Route53 Domain in ApiGateway
  Route53DomainId:
    Type: String
    Default: ""
    AllowedPattern: ^$|^([A-Z0-9]+)$
    ConstraintDescription: It should be a valid Route53 Hosted zone ID
    Description: Id of Rout53 Domain
  Route53DomainName:
    Type: String
    Default: ""
    AllowedPattern: ^$|^(?!-)([a-zA-Z0-9-]{1,63}\.)*[a-zA-Z]{2,63}$
    ConstraintDescription: It should be a valid FQDN
    Description: Route53 Registered Domain name
  ReleasePipeline:
    Type: String
    Default: GA
    Description: The release pipeline to use. Meant for debugging purposes
    MinLength: 1
Rules:
  DomainShouldNotBeEmpty:
    RuleCondition:
      Fn::Equals:
        - Ref: EnableCustomDomain
        - Enabled
    Assertions:
      - AssertDescription: Route53 Domain Id must not be empty when Custom Domain for ApiGateway is Enabled
        Assert:
          Fn::Not:
            - Fn::Equals:
                - Ref: Route53DomainId
                - ""
      - AssertDescription: Route53 Domain Name must not be empty when Custom Domain for ApiGateway is Enabled
        Assert:
          Fn::Not:
            - Fn::Equals:
                - Ref: Route53DomainName
                - ""
Resources:
  AGProxyApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      EndpointConfiguration:
        Types:
          - EDGE
      Name: qualys-integration-proxy
  AGProxyApiDeploymentb395263a89d6f084fd2ac5deb459be95:
    Type: AWS::ApiGateway::Deployment
    Properties:
      Description: Automatically created by the RestApi construct
      RestApiId:
        Ref: AGProxyApi
    DependsOn:
      - AGProxyApiResource
      - AGProxyProxyMethod
    Metadata:
      aws:cdk:do-not-refactor: true
  AGProxyApiDeploymentStagev0:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId:
        Ref: AGProxyApiDeploymentb395263a89d6f084fd2ac5deb459be95
      RestApiId:
        Ref: AGProxyApi
      StageName: v0
  AGProxyApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId:
        Fn::GetAtt:
          - AGProxyApi
          - RootResourceId
      PathPart: "{proxy+}"
      RestApiId:
        Ref: AGProxyApi
  AGProxyProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: ANY
      Integration:
        CacheKeyParameters:
          - method.request.path.proxy
        IntegrationHttpMethod: ANY
        IntegrationResponses:
          - StatusCode: "200"
        PassthroughBehavior: WHEN_NO_MATCH
        RequestParameters:
          integration.request.path.proxy: method.request.path.proxy
          integration.request.header.Authorization: method.request.header.QAuth
        Type: HTTP_PROXY
        Uri:
          Fn::Join:
            - ""
            - - Ref: QEndpoint
              - /{proxy}
      RequestParameters:
        method.request.path.proxy: true
        method.request.header.QAuth: true
      ResourceId:
        Ref: AGProxyApiResource
      RestApiId:
        Ref: AGProxyApi
  TagsConfig:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Stores tags configured for qualys scanner
      Name: /qualys/snapshot-scanner/tags-config
      Tags:
        App: qualys-snapshot-scanner
      Type: String
      Value:
        Fn::Join:
          - ""
          - - '{"mustHaveTags":"'
            - Fn::Join:
                - ","
                - Ref: MustHaveTagList
            - '","anyInListTags":"'
            - Fn::Join:
                - ","
                - Ref: AtLeastOneInList
            - '","noneInTheList":"'
            - Fn::Join:
                - ","
                - Ref: NoneInTheList
            - '","noneOnVolume":"'
            - Fn::Join:
                - ","
                - Ref: NoneOnVolume
            - '","qualysTags":"App=qualys-snapshot-scanner"}'
  ScanConfig:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Stores scan details for qualys scanner
      Name: /qualys/snapshot-scanner/scan-config
      Tags:
        App: qualys-snapshot-scanner
      Type: String
      Value:
        Fn::Join:
          - ""
          - - '{"regions":"'
            - Fn::Join:
                - ","
                - Ref: Regions
            - '","concurrency":'
            - Ref: Concurrency
            - ',"pollFrequency":'
            - Ref: PollRetryInterval
            - ',"scanFrequency":'
            - Ref: EventsBatchWindow
            - ',"singleRegionConcurrency":'
            - Ref: SingleRegionConcurrency
            - ',"scanIntervalHours":"'
            - Ref: IntervalHours
            - '","swcaEnabled":"'
            - Ref: SwCA
            - '","secretEnabled":"'
            - Ref: Secret
            - '","samplingEnabled":"'
            - Ref: ScanSampling
            - '","offlineScanEnabled":"Disabled","samplingGroupScanPercentage":'
            - Ref: SamplingGroupScanPercentage
            - ',"swcaScanIncludeDirs":"'
            - Fn::Join:
                - ","
                - Ref: SwCAScanIncludeDirs
            - '","swcaScanExcludeDirs":"'
            - Fn::Join:
                - ","
                - Ref: SwCAScanExcludeDirs
            - '","swcaScanTimeout":'
            - Ref: SwCAScanTimeout
            - ',"secretScanIncludeDirs":"'
            - Fn::Join:
                - ","
                - Ref: SecretScanIncludeDirs
            - '","secretScanExcludeDirs":"'
            - Fn::Join:
                - ","
                - Ref: SecretScanExcludeDirs
            - '","secretScanTimeout":'
            - Ref: SecretScanTimeout
            - ',"amiEnabled":"'
            - Ref: AMI
            - '","amiSwcaEnabled":"Disabled","amiSecretEnabled":"Disabled","amiOfflineScanEnabled":"'
            - Ref: AMIOfflineScan
            - '","scannerPlatforms":["LINUX","WINDOWS"],"cftVersion":"1.9.0-11"}'
  AmiConfig:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Stores ami details required by qualys scanner instance
      Name: /qualys/snapshot-scanner/ami-config
      Tags:
        App: qualys-snapshot-scanner
      Type: String
      Value: '{"amiIds":{"LINUX":{},"WINDOWS":{}}}'
  ApiConfig:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Stores generated Rest API endpoint
      Name: /qualys/snapshot-scanner/api-config
      Tags:
        App: qualys-snapshot-scanner
      Type: String
      Value:
        Fn::Join:
          - ""
          - - '{"endpoint":"'
            - Ref: AGProxyApi
            - .execute-api.
            - Ref: AWS::Region
            - "."
            - Ref: AWS::URLSuffix
            - '","qEndpoint":"'
            - Ref: QEndpoint
            - '"}'
  VersionConfig:
    Type: AWS::SSM::Parameter
    Properties:
      Description: Stores generated Rest API endpoint
      Name: /qualys/snapshot-scanner/version
      Tags:
        App: qualys-snapshot-scanner
      Type: String
      Value:
        Fn::Join:
          - ""
          - - '{"cftVersion":"1.9.0-11","sfnVersion":"1.9.0-11","shouldUpdateSfns":"true","releasePipeline":"'
            - Ref: ReleasePipeline
            - '"}'
  ServiceKmsKey:
    Type: AWS::KMS::Key
    Properties:
      Description: Symmetric CMK for Qualys Service Account Resources
      EnableKeyRotation: true
      Enabled: true
      KeyPolicy:
        Statement:
          - Action: kms:*
            Effect: Allow
            Principal:
              AWS:
                Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":iam::"
                    - Ref: AWS::AccountId
                    - :root
            Resource: "*"
          - Action:
              - kms:CreateGrant
              - kms:Decrypt
              - kms:DescribeKey
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Condition:
              StringEquals:
                kms:ViaService:
                  Fn::Join:
                    - ""
                    - - secretsmanager.
                      - Ref: AWS::Region
                      - .amazonaws.com
            Effect: Allow
            Principal:
              AWS:
                Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":iam::"
                    - Ref: AWS::AccountId
                    - :root
            Resource: "*"
          - Action:
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Effect: Allow
            Principal:
              Service:
                Fn::Join:
                  - ""
                  - - logs.
                    - Ref: AWS::Region
                    - .amazonaws.com
            Resource: "*"
        Version: "2012-10-17"
      KeyUsage: ENCRYPT_DECRYPT
      PendingWindowInDays: 7
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  ServiceKmsKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: alias/qualys-service-key
      TargetKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
  QualysSecrets:
    Type: AWS::SecretsManager::Secret
    Properties:
      KmsKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      Name: qualys-secret-token
      SecretString:
        Fn::Join:
          - ""
          - - '{"QToken":"'
            - Ref: QToken
            - '"}'
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  Ec2IamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                Fn::Join:
                  - ""
                  - - ec2.
                    - Ref: AWS::URLSuffix
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/AmazonSSMManagedInstanceCore
      RoleName: qualys-ec2-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  EC2RoleInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: qualys-ec2-role
      Roles:
        - Ref: Ec2IamRole
  Ec2IamPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - s3:GetObject
              - s3:HeadObject
              - s3:PutObject
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :s3:::qualys-data-*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :s3:::qualys-data-*/*
        Version: "2012-10-17"
      PolicyName: qualys-ec2-policy
      Roles:
        - Ref: Ec2IamRole
  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      Description: An execution role for a Lambda function
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      RoleName: qualys-lambda-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  LambdaRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - sqs:ChangeMessageVisibility
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
              - sqs:ReceiveMessage
              - sqs:SendMessage
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - DiscoveryTaskQueue
                  - Arn
              - Fn::GetAtt:
                  - PostProcessScanQueue
                  - Arn
              - Fn::GetAtt:
                  - ScheduleSfnQueue
                  - Arn
              - Fn::GetAtt:
                  - SqsSnapshotNotifications
                  - Arn
          - Action:
              - kms:Decrypt
              - kms:DescribeKey
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - ServiceKmsKey
                - Arn
          - Action:
              - dynamodb:BatchGetItem
              - dynamodb:BatchWriteItem
              - dynamodb:ConditionCheckItem
              - dynamodb:DeleteItem
              - dynamodb:DescribeTable
              - dynamodb:GetItem
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
              - dynamodb:PutItem
              - dynamodb:Query
              - dynamodb:Scan
              - dynamodb:UpdateItem
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - AppConfigTable
                  - Arn
              - Fn::GetAtt:
                  - DiscoveryTaskTable
                  - Arn
              - Fn::GetAtt:
                  - TableEventLogs
                  - Arn
              - Fn::GetAtt:
                  - TableInventoryScanStatus
                  - Arn
              - Fn::GetAtt:
                  - TableResourceInventory
                  - Arn
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - AppConfigTable
                        - Arn
                    - /index/*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - DiscoveryTaskTable
                        - Arn
                    - /index/*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - TableEventLogs
                        - Arn
                    - /index/*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - TableInventoryScanStatus
                        - Arn
                    - /index/*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - TableResourceInventory
                        - Arn
                    - /index/*
          - Action: sqs:SendMessage
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - SqsFailedErrors
                - Arn
          - Action:
              - xray:PutTelemetryRecords
              - xray:PutTraceSegments
            Effect: Allow
            Resource: "*"
          - Action: iam:PassRole
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - SfnRole
                - Arn
        Version: "2012-10-17"
      PolicyName: LambdaRoleDefaultPolicy
      Roles:
        - Ref: LambdaRole
  LambdaPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action: lambda:InvokeFunction
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - ":lambda:*:"
                  - Ref: AWS::AccountId
                  - :function:qualys-util-proxy-instance
          - Action: sts:AssumeRole
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - :iam::*:role/qualys-snapshot-scanner-cross-account
          - Action:
              - ssm:GetParameter
              - ssm:PutParameter
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :parameter
                    - Ref: AmiConfig
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :parameter
                    - Ref: ApiConfig
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :parameter
                    - Ref: ScanConfig
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :parameter
                    - Ref: TagsConfig
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :parameter
                    - Ref: VersionConfig
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ssm:*:"
                    - Ref: AWS::AccountId
                    - :parameter/qualys/snapshot-scanner/region-config
          - Action:
              - ec2:AssignPrivateIpAddresses
              - ec2:AuthorizeSecurityGroupEgress
              - ec2:CreateNetworkInterface
              - ec2:CreateTags
              - ec2:DeleteNetworkInterface
              - ec2:DescribeImages
              - ec2:DescribeInstances
              - ec2:DescribeNetworkInterfaces
              - ec2:DescribePrefixLists
              - ec2:DescribeRouteTables
              - ec2:DescribeSecurityGroups
              - ec2:DescribeSnapshots
              - ec2:DescribeSubnets
              - ec2:DescribeVolumes
              - ec2:DescribeVpcs
              - ec2:DetachNetworkInterface
              - ec2:RevokeSecurityGroupEgress
              - ec2:RevokeSecurityGroupIngress
              - ec2:UnassignPrivateIpAddresses
              - kms:CreateGrant
              - kms:Decrypt
              - kms:DescribeKey
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ListGrants
              - kms:ReEncrypt*
              - kms:RetireGrant
              - logs:DeleteLogGroup
              - logs:DescribeLogGroups
              - s3:ListAllMyBuckets
              - states:DescribeExecution
              - states:ListExecutions
            Effect: Allow
            Resource: "*"
          - Action: ec2:DeregisterImage
            Condition:
              StringEquals:
                aws:ResourceTag/App: qualys-snapshot-scanner
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - :ec2:*::image/*
          - Action:
              - ec2:CreateImage
              - ec2:CreateVolume
              - ec2:RunInstances
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :instance/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :key-pair/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :network-interface/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :security-group/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :subnet/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :volume/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :ec2:*::image/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :ec2:*::snapshot/*
          - Action:
              - ec2:AttachVolume
              - ec2:CreateVolume
              - ec2:DeleteSnapshot
              - ec2:DeleteVolume
              - ec2:DetachVolume
              - ec2:StartInstances
              - ec2:StopInstances
              - ec2:TerminateInstances
            Condition:
              StringEquals:
                aws:ResourceTag/App: qualys-snapshot-scanner
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :instance/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":ec2:*:"
                    - Ref: AWS::AccountId
                    - :volume/*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :ec2:*::snapshot/*
          - Action: iam:PassRole
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - ":iam::"
                  - Ref: AWS::AccountId
                  - :role/qualys-ec2-role
          - Action:
              - secretsmanager:DeleteSecret
              - secretsmanager:GetSecretValue
            Effect: Allow
            Resource:
              Ref: QualysSecrets
          - Action: states:StartExecution
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":states:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :stateMachine:qualys-sfn-create-encrypted-snapshot
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":states:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :stateMachine:qualys-sfn-deregister-service-account
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":states:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :stateMachine:qualys-sfn-destroy-stale-resources
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":states:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :stateMachine:qualys-sfn-image-copy-snapshot
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":states:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :stateMachine:qualys-sfn-notify-qflow
          - Action:
              - states:SendTaskFailure
              - states:SendTaskSuccess
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - ":states:"
                  - Ref: AWS::Region
                  - ":"
                  - Ref: AWS::AccountId
                  - :stateMachine:*
          - Action:
              - s3:CreateBucket
              - s3:DeleteBucket
              - s3:DeleteObject
              - s3:DeleteObjectVersion
              - s3:GetObject
              - s3:ListBucket
              - s3:ListBucketVersions
              - s3:PutBucketLogging
              - s3:PutBucketPolicy
              - s3:PutBucketTagging
              - s3:PutBucketVersioning
              - s3:PutLifecycleConfiguration
              - s3:PutObject
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :s3:::qualys-data-*
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - :s3:::qualys-data-*/*
          - Action: lambda:UpdateFunctionCode
            Effect: Allow
            Resource:
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-cft-cleanup
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-scanner-ami-cleanup
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-util-aws-sdk-wrapper
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-util-data-formatter
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-util-scheduled-sfn-check
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-app-config-store
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-create-inventory-scan-statuses
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-download-to-s3
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-dynamodb-streams
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-dynamodb-wrapper
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-event-based-task-scheduler
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-fetch-inventory-chunks
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-generate-scan-instances-params
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-generate-scan-types-chunks
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-on-demand-scan
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-poll-ami-task-scheduler
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-poll-task-scheduler
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-poll-task-worker
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-post-process-scan
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-process-scan-s3-files
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-s3-create-bucket
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-snapshot-notification
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-step-functions-events
              - Fn::Join:
                  - ""
                  - - "arn:"
                    - Ref: AWS::Partition
                    - ":lambda:"
                    - Ref: AWS::Region
                    - ":"
                    - Ref: AWS::AccountId
                    - :function:qualys-utils-update-lambda-code
        Version: "2012-10-17"
      PolicyName: qualys-lambda-role-policy
      Roles:
        - Ref: LambdaRole
  SqsSnapshotNotifications:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MessageRetentionPeriod: 604800
      QueueName: qualys-snapshot-notifications-queue
      ReceiveMessageWaitTimeSeconds: 20
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 60
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  DiscoveryTaskDLQ:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-discovery-worker-tasks-dlq
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 300
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  DiscoveryTaskQueue:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-discovery-worker-tasks
      RedrivePolicy:
        deadLetterTargetArn:
          Fn::GetAtt:
            - DiscoveryTaskDLQ
            - Arn
        maxReceiveCount: 3
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 300
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  ScheduleSfnDLQ:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-schedule-sfn-dlq
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 300
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  ScheduleSfnQueue:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-schedule-sfn
      RedrivePolicy:
        deadLetterTargetArn:
          Fn::GetAtt:
            - ScheduleSfnDLQ
            - Arn
        maxReceiveCount: 96
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 300
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  PostProcessScanDLQ:
    Type: AWS::SQS::Queue
    Properties:
      DelaySeconds: 0
      FifoQueue: true
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-post-process-scan-dlq.fifo
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 600
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  PostProcessScanQueue:
    Type: AWS::SQS::Queue
    Properties:
      ContentBasedDeduplication: true
      DelaySeconds: 0
      FifoQueue: true
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      QueueName: qualys-post-process-scan.fifo
      RedrivePolicy:
        deadLetterTargetArn:
          Fn::GetAtt:
            - PostProcessScanDLQ
            - Arn
        maxReceiveCount: 1
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 600
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  OnDemandScanPollEventsRule:
    Type: AWS::Events::Rule
    Properties:
      Name: qualys-fetch-on-demand-scan-request
      ScheduleExpression: rate(1 minute)
      State: ENABLED
      Targets:
        - Arn:
            Fn::GetAtt:
              - LambdaOnDemandScanLambda
              - Arn
          Id: Target0
  OnDemandScanPollEventsRuleAllowEventRuleQualysLambdaOnDemandScanLambda0F1216E1:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName:
        Fn::GetAtt:
          - LambdaOnDemandScanLambda
          - Arn
      Principal: events.amazonaws.com
      SourceArn:
        Fn::GetAtt:
          - OnDemandScanPollEventsRule
          - Arn
  TableResourceInventory:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: UID
          AttributeType: S
        - AttributeName: TargetRegion
          AttributeType: S
        - AttributeName: ScannerState
          AttributeType: S
        - AttributeName: ScanPriority
          AttributeType: "N"
        - AttributeName: ScanGroup
          AttributeType: S
        - AttributeName: IsScanGroupLeader
          AttributeType: "N"
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: byRegionAndState
          KeySchema:
            - AttributeName: TargetRegion
              KeyType: HASH
            - AttributeName: ScannerState
              KeyType: RANGE
          Projection:
            NonKeyAttributes:
              - UID
              - VolumeCount
              - ScanAttempts
            ProjectionType: INCLUDE
        - IndexName: byRegionAndPriority
          KeySchema:
            - AttributeName: TargetRegion
              KeyType: HASH
            - AttributeName: ScanPriority
              KeyType: RANGE
          Projection:
            NonKeyAttributes:
              - UID
              - VolumeCount
              - ScanAttempts
              - ScannerState
            ProjectionType: INCLUDE
        - IndexName: byScanSampling
          KeySchema:
            - AttributeName: ScanGroup
              KeyType: HASH
            - AttributeName: IsScanGroupLeader
              KeyType: RANGE
          Projection:
            ProjectionType: KEYS_ONLY
      KeySchema:
        - AttributeName: UID
          KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        KMSMasterKeyId:
          Fn::GetAtt:
            - ServiceKmsKey
            - Arn
        SSEEnabled: true
        SSEType: KMS
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      TableClass: STANDARD
      TableName: qualys-resource-inventory
      TimeToLiveSpecification:
        AttributeName: ExpiresAt
        Enabled: true
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  TableInventoryScanStatus:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: ResourceId
          AttributeType: S
        - AttributeName: ScanType
          AttributeType: S
        - AttributeName: TargetRegion
          AttributeType: S
        - AttributeName: ScannerPlatform
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: byRegionAndPlatform
          KeySchema:
            - AttributeName: TargetRegion
              KeyType: HASH
            - AttributeName: ScannerPlatform
              KeyType: RANGE
          Projection:
            NonKeyAttributes:
              - ResourceId
              - ScanAttempts
              - ScanType
              - ScanStatus
              - VolumeCount
            ProjectionType: INCLUDE
      KeySchema:
        - AttributeName: ResourceId
          KeyType: HASH
        - AttributeName: ScanType
          KeyType: RANGE
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        KMSMasterKeyId:
          Fn::GetAtt:
            - ServiceKmsKey
            - Arn
        SSEEnabled: true
        SSEType: KMS
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      TableClass: STANDARD
      TableName: qualys-inventory-scan-status
      TimeToLiveSpecification:
        AttributeName: ExpiresAt
        Enabled: true
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  TableEventLogs:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: UID
          AttributeType: S
        - AttributeName: InstanceId
          AttributeType: S
        - AttributeName: Time
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: byInstanceId
          KeySchema:
            - AttributeName: InstanceId
              KeyType: HASH
            - AttributeName: Time
              KeyType: RANGE
          Projection:
            NonKeyAttributes:
              - UID
            ProjectionType: INCLUDE
      KeySchema:
        - AttributeName: UID
          KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        KMSMasterKeyId:
          Fn::GetAtt:
            - ServiceKmsKey
            - Arn
        SSEEnabled: true
        SSEType: KMS
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      TableClass: STANDARD
      TableName: qualys-event-logs
      TimeToLiveSpecification:
        AttributeName: ExpiresAt
        Enabled: true
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  DiscoveryTaskTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: TaskId
          AttributeType: S
        - AttributeName: TaskStatus
          AttributeType: S
        - AttributeName: RetryAttempts
          AttributeType: "N"
      BillingMode: PAY_PER_REQUEST
      GlobalSecondaryIndexes:
        - IndexName: byTaskStatus
          KeySchema:
            - AttributeName: TaskStatus
              KeyType: HASH
            - AttributeName: RetryAttempts
              KeyType: RANGE
          Projection:
            NonKeyAttributes:
              - TaskId
            ProjectionType: INCLUDE
      KeySchema:
        - AttributeName: TaskId
          KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: false
      SSESpecification:
        KMSMasterKeyId:
          Fn::GetAtt:
            - ServiceKmsKey
            - Arn
        SSEEnabled: true
        SSEType: KMS
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      TableClass: STANDARD
      TableName: qualys-discovery-task
      TimeToLiveSpecification:
        AttributeName: ExpireAt
        Enabled: true
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  AppConfigTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
        - AttributeName: configId
          AttributeType: S
        - AttributeName: idx
          AttributeType: "N"
        - AttributeName: uid
          AttributeType: S
      BillingMode: PAY_PER_REQUEST
      KeySchema:
        - AttributeName: configId
          KeyType: HASH
        - AttributeName: idx
          KeyType: RANGE
      LocalSecondaryIndexes:
        - IndexName: byConfigValue
          KeySchema:
            - AttributeName: configId
              KeyType: HASH
            - AttributeName: uid
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: false
      SSESpecification:
        KMSMasterKeyId:
          Fn::GetAtt:
            - ServiceKmsKey
            - Arn
        SSEEnabled: true
        SSEType: KMS
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      TableClass: STANDARD
      TableName: qualys-app-config
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: states.amazonaws.com
        Version: "2012-10-17"
      Description: An execution role for a step function
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:DeleteSecret
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource:
                  Ref: QualysSecrets
              - Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Effect: Allow
                Resource:
                  Fn::Join:
                    - ""
                    - - "arn:"
                      - Ref: AWS::Partition
                      - ":ssm:*:"
                      - Ref: AWS::AccountId
                      - :parameter/qualys/snapshot-scanner/version
              - Action: sqs:sendmessage
                Effect: Allow
                Resource:
                  - Fn::Join:
                      - ""
                      - - "arn:"
                        - Ref: AWS::Partition
                        - ":sqs:*:"
                        - Ref: AWS::AccountId
                        - :qualys-post-process-scan.fifo
                  - Fn::Join:
                      - ""
                      - - "arn:"
                        - Ref: AWS::Partition
                        - ":sqs:*:"
                        - Ref: AWS::AccountId
                        - :qualys-schedule-sfn
              - Action:
                  - states:DescribeExecution
                  - states:StopExecution
                Effect: Allow
                Resource: "*"
              - Action:
                  - events:DescribeRule
                  - events:PutRule
                  - events:PutTargets
                Effect: Allow
                Resource:
                  Fn::Join:
                    - ""
                    - - "arn:"
                      - Ref: AWS::Partition
                      - ":events:"
                      - Ref: AWS::Region
                      - ":"
                      - Ref: AWS::AccountId
                      - :rule/StepFunctionsGetEventsForStepFunctionsExecutionRule
            Version: "2012-10-17"
          PolicyName: sfn-sync-invoke
      RoleName: qualys-sfn-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  SfnRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
              - sqs:SendMessage
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - SqsFailedErrors
                - Arn
          - Action:
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - ServiceKmsKey
                - Arn
          - Action:
              - logs:CreateLogDelivery
              - logs:DeleteLogDelivery
              - logs:DescribeLogGroups
              - logs:DescribeResourcePolicies
              - logs:GetLogDelivery
              - logs:ListLogDeliveries
              - logs:PutResourcePolicy
              - logs:UpdateLogDelivery
            Effect: Allow
            Resource: "*"
          - Action: lambda:InvokeFunction
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - LambdaAmiTaskScheduler
                  - Arn
              - Fn::GetAtt:
                  - LambdaAppConfigStore
                  - Arn
              - Fn::GetAtt:
                  - LambdaCFTCleanupFunction
                  - Arn
              - Fn::GetAtt:
                  - LambdaDataFormatter
                  - Arn
              - Fn::GetAtt:
                  - LambdaDownloadToS3
                  - Arn
              - Fn::GetAtt:
                  - LambdaDynamoDbWrapper
                  - Arn
              - Fn::GetAtt:
                  - LambdaEventBasedTaskScheduler
                  - Arn
              - Fn::GetAtt:
                  - LambdaOnDemandScanLambda
                  - Arn
              - Fn::GetAtt:
                  - LambdaPostProcessScan
                  - Arn
              - Fn::GetAtt:
                  - LambdaProcessScanS3Files
                  - Arn
              - Fn::GetAtt:
                  - LambdaS3CreateBucket
                  - Arn
              - Fn::GetAtt:
                  - LambdaSDKWrapper
                  - Arn
              - Fn::GetAtt:
                  - LambdaScannerAmiCleanupFunction
                  - Arn
              - Fn::GetAtt:
                  - LambdaScheduledSfnCheck
                  - Arn
              - Fn::GetAtt:
                  - LambdaTaskScheduler
                  - Arn
              - Fn::GetAtt:
                  - LambdaTaskWorker
                  - Arn
              - Fn::GetAtt:
                  - LambdaUpdateLambdaCode
                  - Arn
              - Fn::GetAtt:
                  - LambdacreateInventoryScanStatus
                  - Arn
              - Fn::GetAtt:
                  - LambdafetchInventoryChunks
                  - Arn
              - Fn::GetAtt:
                  - LambdagenerateScanInstancesParams
                  - Arn
              - Fn::GetAtt:
                  - LambdagenerateScanTypesChunks
                  - Arn
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaAmiTaskScheduler
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaAppConfigStore
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaCFTCleanupFunction
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaDataFormatter
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaDownloadToS3
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaDynamoDbWrapper
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaEventBasedTaskScheduler
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaOnDemandScanLambda
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaPostProcessScan
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaProcessScanS3Files
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaS3CreateBucket
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaSDKWrapper
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaScannerAmiCleanupFunction
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaScheduledSfnCheck
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaTaskScheduler
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaTaskWorker
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdaUpdateLambdaCode
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdacreateInventoryScanStatus
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdafetchInventoryChunks
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdagenerateScanInstancesParams
                        - Arn
                    - :*
              - Fn::Join:
                  - ""
                  - - Fn::GetAtt:
                        - LambdagenerateScanTypesChunks
                        - Arn
                    - :*
        Version: "2012-10-17"
      PolicyName: SfnRoleDefaultPolicy
      Roles:
        - Ref: SfnRole
  SfnRoleUpdateStepFunction:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString:
        Fn::Join:
          - ""
          - - "{\"StartAt\":\"Setup\",\"States\":{\"Setup\":{\"Type\":\"Pass\",\"Parameters\":{\"IDs.$\":\"States.Array($$.Execution.Input..CorrelationId, States.Array(States.UUID()))\"},\"ResultPath\":\"$.Tracing\",\"Next\":\"Init\"},\"Init\":{\"Type\":\"Pass\",\"Parameters\":{\"Partition.$\":\"States.ArrayGetItem(States.StringSplit($$.StateMachine.Id, ':'), 1)\",\"Region.$\":\"States.ArrayGetItem(States.StringSplit($$.StateMachine.Id, ':'), 3)\",\"AccountId.$\":\"States.ArrayGetItem(States.StringSplit($$.StateMachine.Id, ':'), 4)\",\"CorrelationId.$\":\"States.ArrayGetItem($.Tracing.IDs[*][*], 0)\"},\"ResultPath\":\"$.AWS\",\"Next\":\"GetSecrets\"},\"GetSecrets\":{\"Type\":\"Task\",\"Parameters\":{\"SecretId\":\"qualys-secret-token\"},\"Resource\":\"arn:"
            - Ref: AWS::Partition
            - ':states:::aws-sdk:secretsmanager:getSecretValue","Next":"GetVersion","ResultSelector":{"Secret.$":"States.StringToJson($.SecretString)"}},"GetVersion":{"Type":"Task","Parameters":{"Name":"/qualys/snapshot-scanner/version"},"Resource":"arn:'
            - Ref: AWS::Partition
            - ":states:::aws-sdk:ssm:getParameter\",\"Next\":\"ConfigurableStepFunctions\",\"ResultSelector\":{\"Output.$\":\"States.StringToJson($.Parameter.Value)\"},\"ResultPath\":\"$.Version\"},\"ConfigurableStepFunctions\":{\"Type\":\"Pass\",\"Next\":\"IsUpgradeAvailable\",\"Result\":[\"qualys-sfn-sdk-wrapper\",\"qualys-sfn-config-generator\",\"qualys-sfn-update-configs\",\"qualys-sfn-register-service-account\",\"qualys-sfn-deregister-service-account\",\"qualys-sfn-proxy-instance-x\",\"qualys-sfn-instance-discovery-scheduled\",\"qualys-sfn-retry-failed-snapshots\",\"qualys-sfn-events-syncer\",\"qualys-sfn-dynamodb-wrapper\",\"qualys-sfn-create-snapshot\",\"qualys-sfn-copy-snapshot\",\"qualys-sfn-image-copy-snapshot\",\"qualys-sfn-create-encrypted-snapshot\",\"qualys-sfn-find-scan-candidates\",\"qualys-sfn-scan-instances\",\"qualys-sfn-create-instance\",\"qualys-sfn-run-scan\",\"qualys-sfn-destroy-stale-resources\",\"qualys-sfn-scanner-ami-creation\",\"qualys-sfn-cli-config-generator\",\"qualys-sfn-find-scan-candidates-by-scan-type\",\"qualys-sfn-notify-qflow\"],\"ResultPath\":\"$.stepFunctions\"},\"IsUpgradeAvailable\":{\"Type\":\"Choice\",\"Choices\":[{\"And\":[{\"Variable\":\"$.Version.Output.shouldUpdateSfns\",\"IsPresent\":true},{\"Variable\":\"$.Version.Output.shouldUpdateSfns\",\"StringEquals\":\"true\"}],\"Next\":\"GetVersionMapping\",\"Comment\":\"Only update-sfs when it's not a debug build\"}],\"Default\":\"RegisterServiceAccount\"},\"GetVersionMapping\":{\"Type\":\"Task\",\"Resource\":\"arn:"
            - Ref: AWS::Partition
            - :states:::apigateway:invoke","TimeoutSeconds":300,"Parameters":{"ApiEndpoint":"
            - Ref: AGProxyApi
            - .execute-api.
            - Ref: AWS::Region
            - "."
            - Ref: AWS::URLSuffix
            - "\",\"Method\":\"GET\",\"Headers\":{\"QAuth.$\":\"States.Array(States.Format('Bearer {}', $.Secret.QToken))\"},\"Stage\":\"v0\",\"Path\":\"/qflow/v1/version/mapping/qscanner-sfn-orchestrator\",\"QueryParameters\":{\"version.$\":\"States.Array($.Version.Output.sfnVersion)\",\"release.$\":\"States.Array($.Version.Output.releasePipeline)\",\"module.$\":\"States.Array('STEPFUNCTIONS')\"},\"AuthType\":\"NO_AUTH\"},\"Retry\":[{\"ErrorEquals\":[\"States.ALL\"],\"BackoffRate\":1,\"IntervalSeconds\":5,\"MaxAttempts\":10}],\"Next\":\"Map\",\"ResultSelector\":{\"ResponseBody.$\":\"$.ResponseBody\"},\"ResultPath\":\"$.VersionMapping\"},\"Map\":{\"Type\":\"Map\",\"ItemProcessor\":{\"ProcessorConfig\":{\"Mode\":\"INLINE\"},\"StartAt\":\"API Gateway Invoke\",\"States\":{\"API Gateway Invoke\":{\"Type\":\"Task\",\"Resource\":\"arn:"
            - Ref: AWS::Partition
            - :states:::apigateway:invoke","TimeoutSeconds":300,"Parameters":{"ApiEndpoint":"
            - Ref: AGProxyApi
            - .execute-api.
            - Ref: AWS::Region
            - "."
            - Ref: AWS::URLSuffix
            - "\",\"Method\":\"POST\",\"Headers\":{\"QAuth.$\":\"States.Array(States.Format('Bearer {}', $.Secret.QToken))\"},\"Stage\":\"v0\",\"Path.$\":\"States.Format('/qflow/aws-snapshot/v1/stepFunctions/{}.json', $.E)\",\"QueryParameters\":{\"version.$\":\"States.Array($.VersionMapping.version)\"},\"RequestBody\":{\"AWS_PARTITION\":\""
            - Ref: AWS::Partition
            - "\"},\"AuthType\":\"NO_AUTH\"},\"Retry\":[{\"ErrorEquals\":[\"States.ALL\"],\"BackoffRate\":1,\"IntervalSeconds\":5,\"MaxAttempts\":10}],\"Next\":\"UpdateStateMachine\",\"ResultPath\":\"$.StepFunctionDefinition\"},\"UpdateStateMachine\":{\"Type\":\"Task\",\"End\":true,\"Parameters\":{\"StateMachineArn.$\":\"States.Format('arn:"
            - Ref: AWS::Partition
            - ":states:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - ":stateMachine:{}', $.E)\",\"Definition.$\":\"$.StepFunctionDefinition.ResponseBody\"},\"Resource\":\"arn:"
            - Ref: AWS::Partition
            - ':states:::aws-sdk:sfn:updateStateMachine"}}},"ItemsPath":"$.stepFunctions","ResultPath":"$.stepFunction","ItemSelector":{"E.$":"$$.Map.Item.Value","Index.$":"$$.Map.Item.Index","Secret.$":"$.Secret","VersionMapping.$":"$.VersionMapping.ResponseBody"},"Next":"UpdateVersion"},"UpdateVersion":{"Type":"Task","Parameters":{"Name":"/qualys/snapshot-scanner/version","Value":{"sfnVersion.$":"$.VersionMapping.ResponseBody.version","shouldUpdateSfns.$":"$.Version.Output.shouldUpdateSfns","cftVersion.$":"$.Version.Output.cftVersion","releasePipeline.$":"$.Version.Output.releasePipeline"},"Overwrite":true},"Resource":"arn:'
            - Ref: AWS::Partition
            - ':states:::aws-sdk:ssm:putParameter","Next":"RegisterServiceAccount"},"RegisterServiceAccount":{"Type":"Task","Resource":"arn:'
            - Ref: AWS::Partition
            - ':states:::states:startExecution.sync:2","Parameters":{"StateMachineArn":"arn:'
            - Ref: AWS::Partition
            - ":states:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - ':stateMachine:qualys-sfn-register-service-account"},"Next":"UpdateConfigs"},"UpdateConfigs":{"Type":"Task","Resource":"arn:'
            - Ref: AWS::Partition
            - ':states:::states:startExecution.sync:2","Parameters":{"StateMachineArn":"arn:'
            - Ref: AWS::Partition
            - ":states:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :stateMachine:qualys-sfn-update-configs"},"End":true}}}
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-update-states
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - SfnRoleDefaultPolicy
      - SfnRole
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SqsFailedErrors:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MessageRetentionPeriod: 1209600
      QueueName: qualys-failed-errors
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  LambdaSDKWrapper:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/awsSdkWrapper.ts
          var awsSdkWrapper_exports = {};
          __export(awsSdkWrapper_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(awsSdkWrapper_exports);

          // src/lambda/code/lib/awsUtils.ts
          var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
          var import_client_sts = require("@aws-sdk/client-sts");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/awsUtils.ts
          async function loadCredentials(config, roleArn) {
            const IamRoleSessionName = process.env.IamRoleSessionName || IAM_ROLE_SESSION_NAME;
            const stsClient = new import_client_sts.STSClient(config);
            const { Credentials } = await stsClient.send(
              new import_client_sts.AssumeRoleCommand({
                RoleArn: roleArn,
                RoleSessionName: IamRoleSessionName
              })
            );
            if (Credentials == null) {
              throw new Error("Error loading credentials");
            }
            config.credentials = {
              accessKeyId: Credentials.AccessKeyId,
              secretAccessKey: Credentials.SecretAccessKey,
              sessionToken: Credentials.SessionToken
            };
          }
          var cachedSecrets = {};
          if (process.env.SKIP_CACHE_EVICTION_INTERVAL !== "true") {
            setInterval(() => cachedSecrets = {}, 3e5);
          }

          // src/lambda/code/lib/getProperty.ts
          function getProperty(obj, path) {
            const keys = path.split(".");
            let result = obj;
            for (let index = 0; index < keys.length; index++) {
              const key = keys[index];
              if (key === "$") continue;
              if (key === "*") {
                if (!Array.isArray(result)) {
                  return void 0;
                }
                const subPath = keys.slice(index + 1).join(".");
                return result.map((element) => getProperty(element, subPath));
              }
              if (result[key] === void 0) {
                return void 0;
              }
              result = result[key];
            }
            return result;
          }

          // src/lambda/code/lib/formatCollection.ts
          function setProperty(data, path, value) {
            if (typeof path !== "string") {
              throw new Error("Invalid path: path must be a string.");
            }
            const keys = path.split(".");
            let pointer = data;
            for (let i = 0; i < keys.length - 1; i++) {
              if (!pointer[keys[i]] || typeof pointer[keys[i]] !== "object") {
                throw new Error(
                  `Invalid path: path "${keys.slice(0, i + 1).join(".")}" is not valid.`
                );
              }
              pointer = pointer[keys[i]];
            }
            pointer[keys[keys.length - 1]] = value;
            return data;
          }
          function formatCollection(data, query) {
            if (!data || typeof data !== "object") {
              throw new Error("Invalid result: result must be an object or an array.");
            }
            if (!query || typeof query !== "object") {
              throw new Error("Invalid query: query must be an object.");
            }
            const {
              inputPath,
              inputIsCollection,
              resultSelector,
              resultLimiter,
              outputPath
            } = query;
            let pointer = data;
            if (inputPath) {
              if (typeof inputPath !== "string") {
                throw new Error("Invalid inputPath: inputPath must be a string.");
              }
              pointer = getProperty(pointer, inputPath) || {};
              const wildcardRefCount = inputPath.split("*").length - 1;
              if (wildcardRefCount > 0) {
                pointer = pointer.flat(wildcardRefCount);
              }
            }
            if (resultSelector && typeof resultSelector !== "object") {
              throw new Error(
                "Invalid resultSelector: resultSelector must be an object."
              );
            }
            let out = (inputIsCollection ? pointer : [pointer]).map((o) => {
              if (resultSelector && typeof resultSelector === "object") {
                return Object.fromEntries(
                  Object.entries(resultSelector).map(([k, v]) => {
                    if (k.endsWith(".#") && typeof v !== "string") {
                      throw new Error(
                        'Invalid resultSelector value: value must be a string if key end with ".#"'
                      );
                    }
                    return [k.replace(".#", ""), k.endsWith("#") ? getProperty(o, v) : v];
                  })
                );
              } else {
                return o;
              }
            });
            if (resultLimiter && Array.isArray(resultLimiter)) {
              resultLimiter.forEach((path) => {
                if (typeof path !== "string") {
                  throw new Error(
                    "Invalid resultLimiter path: each path must be a string."
                  );
                }
                out = out.map((o) => setProperty(o, path, void 0));
              });
            }
            if (!inputIsCollection) out = out[0];
            if (outputPath) {
              return setProperty(data, outputPath, out);
            }
            return out;
          }

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/awsSdkWrapper.ts
          var handler = async function(event) {
            const logger = getLogger(event);
            let isSqsCall = false;
            if (event.Records) {
              isSqsCall = true;
              event = JSON.parse(event.Records[0].body);
              await new Promise((resolve) => setTimeout(resolve, 300));
            }
            const { roleArn, region, service, method, params = {} } = event;
            const config = { region, logger };
            if (roleArn) {
              await loadCredentials(config, roleArn);
            }
            const _service = (() => {
              switch (service) {
                case "StepFunctions":
                  return "sfn";
                case "SecretsManager":
                  return "secrets-manager";
                default:
                  return service.toLocaleLowerCase();
              }
            })();
            const _client = (() => {
              switch (service) {
                case "StepFunctions":
                  return "SFNClient";
                default:
                  return service + "Client";
              }
            })();
            const _method = (() => {
              return method.charAt(0).toUpperCase() + method.slice(1) + "Command";
            })();
            const {
              [_client]: ServiceClient,
              [_method]: ServiceCommand
              // eslint-disable-next-line @typescript-eslint/no-require-imports
            } = require(`@aws-sdk/client-${_service}`);
            const client = new ServiceClient(config);
            const command = new ServiceCommand(params);
            try {
              let result = await client.send(command);
              if (isSqsCall) {
                logger.log("result", result);
                return result;
              }
              if (event.query) {
                result = formatCollection(result, event.query);
              }
              if (_service === "lambda" && result.Payload && typeof result.Payload === "object") {
                result.Payload = Buffer.from(Uint8Array.from(result.Payload)).toString(
                  "utf-8"
                );
              }
              return result;
            } catch (error) {
              logger.error("Error executing AWS SDK call", error);
              throw error;
            }
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          IamRoleSessionName: qualys-snapshot-scanner
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-util-aws-sdk-wrapper
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 180
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaDataFormatter:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/dataFormatter.ts
          var dataFormatter_exports = {};
          __export(dataFormatter_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(dataFormatter_exports);

          // src/lambda/code/lib/getProperty.ts
          function getProperty(obj, path) {
            const keys = path.split(".");
            let result = obj;
            for (let index = 0; index < keys.length; index++) {
              const key = keys[index];
              if (key === "$") continue;
              if (key === "*") {
                if (!Array.isArray(result)) {
                  return void 0;
                }
                const subPath = keys.slice(index + 1).join(".");
                return result.map((element) => getProperty(element, subPath));
              }
              if (result[key] === void 0) {
                return void 0;
              }
              result = result[key];
            }
            return result;
          }

          // src/lambda/code/lib/array.ts
          function sliceByWeight({
            array,
            weightedProperty,
            maxWeight
          }) {
            const result = [];
            let temp = [];
            let tempWeight = 0;
            for (const item of array) {
              let itemWeight = getProperty(item, weightedProperty);
              if (typeof itemWeight === "string") itemWeight = Number(itemWeight);
              if (typeof itemWeight !== "number" || isNaN(itemWeight)) itemWeight = 0;
              if (tempWeight + itemWeight <= maxWeight) {
                temp.push(item);
                tempWeight += itemWeight;
              } else {
                result.push(temp);
                temp = [item];
                tempWeight = itemWeight;
              }
            }
            if (temp.length) {
              result.push(temp);
            }
            return result;
          }
          function select({
            array,
            properties
          }) {
            console.log("array", array);
            console.log("properties", properties);
            return array.map(
              (e) => Object.fromEntries(
                Object.entries(e).filter(([k, _]) => properties.includes(k))
              )
            );
          }
          function reduceToKeyValue({
            array,
            keyProperty,
            valueProperty
          }) {
            return array.reduce((prev, current) => {
              return {
                ...prev,
                [getProperty(current, keyProperty)]: getProperty(current, valueProperty)
              };
            }, {});
          }

          // src/lambda/code/lib/describeInstanceParameters.ts
          function formatTagParams({
            params,
            requiredTags
          }) {
            if (typeof requiredTags !== "string") return params;
            const array = requiredTags.split(",").filter((x) => x.trim());
            if (!array.length) return params;
            if (!params.Filters) params.Filters = [];
            array.forEach((s) => {
              const [k, v] = s.split("=");
              params.Filters.push({
                Name: `tag:${k}`,
                Values: [v]
              });
            });
            return params;
          }

          // src/lambda/code/lib/filter.ts
          function filter(array, conditions, expression) {
            return array.filter((item) => {
              const conditionResults = {};
              for (const condition of conditions) {
                const actual = getProperty(item, condition.key);
                const expected = typeof condition.value === "string" && condition.value.startsWith("$") ? getProperty(item, condition.value) : condition.value;
                switch (condition.operator) {
                  case "==":
                  case "=":
                    conditionResults[condition.id] = actual === expected;
                    break;
                  case "!=":
                  case "!==":
                    conditionResults[condition.id] = actual !== expected;
                    break;
                  case ">":
                    conditionResults[condition.id] = actual !== void 0 && expected !== void 0 && actual > expected;
                    break;
                  case "<":
                    conditionResults[condition.id] = actual !== void 0 && expected !== void 0 && actual < expected;
                    break;
                  case "exists":
                    conditionResults[condition.id] = actual !== void 0;
                    break;
                  case "in":
                    conditionResults[condition.id] = Array.isArray(expected) && expected.includes(actual);
                    break;
                  case "includes":
                    conditionResults[condition.id] = Array.isArray(actual) && actual.includes(expected);
                    break;
                }
              }
              const evalExpression = new Function(
                "conditionResults",
                `with(conditionResults) { return ${expression} }`
              );
              return evalExpression(conditionResults);
            });
          }
          function customFilter({
            array,
            conditions,
            expression
          }) {
            return filter(array, conditions, expression);
          }

          // src/lambda/code/lib/filterEmpty.ts
          function isNull(x) {
            return x === null;
          }
          function isEmptyObject(x) {
            return typeof x === "object" && Object.keys(x).length === 0;
          }
          function isEmptyStringOrUndefined(x) {
            return x === void 0 || typeof x === "string" && x === "";
          }
          var filterEmptyItems = (data) => {
            return Array.isArray(data) ? data.filter(
              (x) => !(isNull(x) || isEmptyObject(x) || isEmptyStringOrUndefined(x))
            ) : [];
          };

          // src/lambda/code/lib/merge.ts
          function isObject(item) {
            return item && typeof item === "object" && !Array.isArray(item);
          }
          function deepMerge(target, ...sources) {
            if (!sources.length) return target;
            const source = sources.shift();
            if (isObject(target) && isObject(source)) {
              for (const key in source) {
                if (Array.isArray(source[key]) && Array.isArray(target[key])) {
                  Object.assign(target, { [key]: [...target[key], ...source[key]] });
                } else if (isObject(source[key])) {
                  if (!target[key]) Object.assign(target, { [key]: {} });
                  deepMerge(target[key], source[key]);
                } else {
                  Object.assign(target, { [key]: source[key] });
                }
              }
            }
            return deepMerge(target, ...sources);
          }

          // src/lambda/code/lib/generateCliConfigs.ts
          function generateCliConfigs(params) {
            const { UserDefinedScanParameters, PredefinedScanParameters } = params;
            const configs = [];
            for (const platform of ["LINUX", "WINDOWS"]) {
              const platformSpecificConfig = PredefinedScanParameters[platform];
              const mergedPlatformConfig = deepMerge(
                platformSpecificConfig,
                UserDefinedScanParameters
              );
              if (platformSpecificConfig) {
                for (const scanType of ["os", "swca", "secret"]) {
                  configs.push({
                    id: `${platform}-${scanType}`,
                    config: mergedPlatformConfig[scanType]
                  });
                }
              }
            }
            return configs;
          }

          // src/lambda/code/lib/mapVolumeToTargetInstance.ts
          function mapVolumeToTargetInstance(params) {
            if (!params.DevicePathMap || !params.TargetInstances || !params.ScannerInstance)
              return [];
            for (const targetInstance of params.TargetInstances) {
              const targetVolumes = [];
              for (const snapshotId of targetInstance.Snapshots) {
                const devicePathMap = params.DevicePathMap.find(
                  (map) => map.SnapshotId === snapshotId && map.InstanceId === targetInstance.InstanceId
                );
                if (devicePathMap) {
                  const volume = params.ScannerInstance.BlockDeviceMappings.find(
                    (bdm) => bdm.DeviceName === devicePathMap.DevicePath
                  );
                  if (volume) {
                    targetVolumes.push({
                      DevicePath: devicePathMap.DevicePath,
                      VolumeCopy: volume.Ebs,
                      VolumeId: volume.Ebs.VolumeId
                    });
                  }
                }
              }
              targetInstance.targetVolumes = targetVolumes;
              targetInstance.serialNumbers = targetVolumes.map(
                (v) => v.VolumeId == null ? null : v.VolumeId.replace("-", "")
              );
            }
            return params.TargetInstances;
          }

          // src/lambda/code/lib/tagFilter.ts
          function createNormalisedKey(prefix, key) {
            return `__${prefix}_${key}`;
          }
          function normalizeTags(array, TAGS_KEY) {
            return array.map((obj) => {
              const newObj = { ...obj };
              if (Array.isArray(obj[TAGS_KEY])) {
                obj[TAGS_KEY].forEach((tag) => {
                  newObj[createNormalisedKey(TAGS_KEY, tag.Key)] = tag.Value;
                });
              }
              return newObj;
            });
          }
          function createConditions(mustHave, atLeastOne, none, TAGS_KEY) {
            const conditions = [];
            mustHave.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `mustHave${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "=="
              });
            });
            atLeastOne.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `atLeastOne${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "=="
              });
            });
            none.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `none${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "!="
              });
            });
            return conditions;
          }
          function filterInstances(instances, mustHaveTags, atLeastOneTags, noneTags, qualysTags, TAGS_KEY) {
            const mustHave = mustHaveTags ? mustHaveTags.split(",") : [];
            const atLeastOne = atLeastOneTags ? atLeastOneTags.split(",") : [];
            let none = noneTags ? noneTags.split(",") : [];
            none = none.concat(...qualysTags ? qualysTags.split(",") : []);
            const conditions = createConditions(mustHave, atLeastOne, none, TAGS_KEY);
            const mustHaveExpression = mustHave.length > 0 ? mustHave.map((_, index) => `mustHave${index}`).join(" && ") : "true";
            const atLeastOneExpression = atLeastOne.length > 0 ? atLeastOne.map((_, index) => `atLeastOne${index}`).join(" || ") : "true";
            const noneExpression = none.length > 0 ? none.map((_, index) => `none${index}`).join(" && ") : "true";
            const expression = `${mustHaveExpression} && (${atLeastOneExpression}) && ${noneExpression}`;
            return filter(instances, conditions, expression);
          }
          function denormalizeTags(array, key) {
            return array.map((u) => {
              Object.keys(u).forEach((k) => {
                if (k.startsWith(`__${key}`)) delete u[k];
              });
              return u;
            });
          }
          function filterInstancesWrapper(event) {
            const {
              mustHaveTags,
              atLeastOneTags,
              noneTags,
              qualysTags,
              opts: { normaliseTags = true, tagsKey = "Tags" } = {}
            } = event;
            let instances = event.instances;
            const fn = (i) => filterInstances(
              i,
              mustHaveTags,
              atLeastOneTags,
              noneTags,
              qualysTags,
              tagsKey
            );
            if (normaliseTags) {
              instances = normalizeTags(instances, tagsKey);
              return denormalizeTags(fn(instances), tagsKey);
            } else {
              return fn(instances);
            }
          }

          // src/lambda/code/lib/time.ts
          var getTimestampHoursAgo = (hoursAgo) => {
            const date = /* @__PURE__ */ new Date();
            date.setHours(date.getHours() - hoursAgo);
            return date.toISOString();
          };
          var shouldTriggerNext = (parentIntervalInMinutes = 15, myIntervalInMinutes = 240, current = /* @__PURE__ */ new Date()) => {
            const tolerance = parentIntervalInMinutes * 60 / 2;
            const unixTimestamp = Math.floor(current.getTime() / 1e3);
            const remainderSeconds = unixTimestamp % (myIntervalInMinutes * 60);
            const isWithinTolerance = remainderSeconds <= tolerance || remainderSeconds >= myIntervalInMinutes * 60 - tolerance;
            console.log(
              "Now=",
              current.toISOString(),
              "myIntervalInMinutes=",
              myIntervalInMinutes,
              "isWithinTolerance=",
              isWithinTolerance
            );
            return isWithinTolerance;
          };

          // src/lambda/code/lib/transformBlockDeviceMappings.ts
          function transformBlockDeviceMappings(params) {
            if (!params.DevicePathMap) return [];
            if (!params.KmsKeyId) return [];
            const BlockDeviceMappings = [];
            if (params.RootBlockDeviceMapping) {
              BlockDeviceMappings.push(params.RootBlockDeviceMapping);
            }
            for (const DevicePathMap of params.DevicePathMap) {
              BlockDeviceMappings.push({
                DeviceName: DevicePathMap.DevicePath,
                Ebs: {
                  DeleteOnTermination: true,
                  SnapshotId: DevicePathMap.SnapshotId,
                  KmsKeyId: params.KmsKeyId,
                  Encrypted: true,
                  VolumeType: params.VolumeType,
                  Iops: params.Iops,
                  Throughput: params.Throughput
                }
              });
            }
            return BlockDeviceMappings;
          }

          // src/lambda/code/lib/transformDevicePathMap.ts
          function transformDevicePathMap(params) {
            if (!params.linuxDeviceNames)
              params.linuxDeviceNames = "b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y";
            if (!params.TargetInstances) params.TargetInstances = [];
            const linuxDeviceNames = params.linuxDeviceNames.split(",");
            const DevicePathMaps = [];
            let i = 0;
            for (const TargetInstance of params.TargetInstances) {
              for (let j = 0; j < TargetInstance.Snapshots.length; j += 1) {
                const snapshot = TargetInstance.Snapshots[j];
                let volume;
                if (TargetInstance.VolumeIds != null && j < TargetInstance.VolumeIds.length) {
                  volume = TargetInstance.VolumeIds[j];
                }
                DevicePathMaps.push({
                  InstanceId: TargetInstance.InstanceId,
                  SnapshotId: snapshot,
                  DevicePath: `/dev/sd${linuxDeviceNames[i]}`,
                  VolumeId: volume
                });
                i += 1;
              }
            }
            return DevicePathMaps;
          }

          // src/lambda/code/dataFormatter.ts
          var fns = {
            "Fn::GetProperty": getProperty,
            "Fn::FilterEmptyItems": filterEmptyItems,
            "Fn::CustomFilter": customFilter,
            "Fn::TagFilter": filterInstancesWrapper,
            "Fn::GetTime": getTimestampHoursAgo,
            "Fn::ArraySliceByWeight": sliceByWeight,
            "Fn::ArraySelect": select,
            "Fn::ShouldTriggerNext": shouldTriggerNext,
            "Fn::FormatTagFilterInput": formatTagParams,
            "Fn::TransformDevicePathMap": transformDevicePathMap,
            "Fn::TransformBlockDeviceMappings": transformBlockDeviceMappings,
            "Fn::MapVolumeToTargetInstance": mapVolumeToTargetInstance,
            "Fn::ArrayReduceToKeyValue": reduceToKeyValue,
            "Fn::GenerateCliConfigs": generateCliConfigs,
            "Fn::DeepMerge": deepMerge
          };
          function evaluateObject(obj) {
            if (!(typeof obj === "object" && obj !== null)) {
              return obj;
            }
            for (const entry of Object.entries(obj)) {
              const fn = entry[0];
              let args = entry[1];
              let originalWasObject = false;
              if (!Array.isArray(args)) {
                args = [args];
                originalWasObject = true;
              }
              args = args.map((arg) => evaluateObject(arg));
              if (fns[fn]) {
                return fns[fn].apply(this, args);
              } else {
                obj[fn] = originalWasObject ? args[0] : args;
              }
            }
            return obj;
          }
          var handler = async function(event) {
            const { evaluate = {} } = event;
            return evaluateObject(evaluate);
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-util-data-formatter
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaDynamoDbWrapper:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/dynamoDbWrapper.ts
          var dynamoDbWrapper_exports = {};
          __export(dynamoDbWrapper_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(dynamoDbWrapper_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");
          var handler = async function(event) {
            const {
              region,
              method = "putItem",
              params = {},
              options: {
                expiry = Number(process.env.SCAN_INTERVAL_HOURS),
                isEventLog = false
              } = {}
            } = event;
            const client = new import_client_dynamodb.DynamoDBClient({ region });
            const toPlainText = (obj) => {
              if (typeof obj !== "object") return obj;
              return Object.entries(obj).map(([key, value]) => `${key} = ${toPlainText(value)}`).join(", ");
            };
            if (params.Item) {
              params.Item.Time = (/* @__PURE__ */ new Date()).toISOString();
            }
            if (params.Item && isEventLog) {
              params.Item.Metadata = toPlainText(params.Item.Metadata);
            }
            if (params.Item && isEventLog) {
              const expirySeconds = isEventLog ? 7 * 24 * 60 * 60 : expiry * 60 * 60;
              params.Item.ExpiresAt = Math.round(Date.now() / 1e3) + expirySeconds;
            }
            if (params.ExclusiveStartKey == null) {
              delete params.ExclusiveStartKey;
            }
            let command;
            switch (method) {
              case "query":
                command = new import_lib_dynamodb.QueryCommand(params);
                break;
              case "putItem":
                command = new import_lib_dynamodb.PutCommand(params);
                break;
              case "updateItem":
                command = new import_lib_dynamodb.UpdateCommand(params);
                break;
              case "getItem":
                command = new import_lib_dynamodb.GetCommand(params);
                break;
              case "batchGetItem":
                command = new import_lib_dynamodb.BatchGetCommand(params);
                break;
              default:
                throw new Error(`Unsupported method: ${method}`);
            }
            const result = await client.send(command);
            return result;
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          SCAN_INTERVAL_HOURS:
            Ref: IntervalHours
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-dynamodb-wrapper
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdacreateInventoryScanStatus:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/createInventoryScanStatus.ts
          var createInventoryScanStatus_exports = {};
          __export(createInventoryScanStatus_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(createInventoryScanStatus_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");

          // src/lambda/code/discovery/saveScanStatus.ts
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/discovery/parsePlatform.ts
          var parsePlatform = (platformDetails) => {
            if (platformDetails.toLowerCase().indexOf("windows") >= 0) {
              return "WINDOWS";
            } else {
              return "LINUX";
            }
          };

          // src/lambda/code/discovery/saveScanStatus.ts
          var ScanStatusTableName = process.env.ScanStatusTableName ?? RESOURCE_INVENTORY_SCAN_STATUS_TABLE;
          async function saveResourceToScanStatus({
            ResourceId,
            ResourceName,
            ResourceType,
            ScanTypes,
            Platform,
            TargetAccount,
            TargetRegion,
            VolumeCount,
            ExpiresAt,
            DiscoveryTaskId
          }, { dynamodbClient }) {
            await Promise.all(
              ScanTypes.map(async (scanType) => {
                const Item = {
                  ResourceId,
                  ResourceName,
                  ResourceType,
                  TargetRegion,
                  TargetAccount,
                  ScanType: scanType,
                  // scanTypes is an array, and we are storing it as comma seperated string
                  ScannerPlatform: parsePlatform(Platform),
                  VolumeCount,
                  ScanAttempts: 0,
                  ScanStatus: "PENDING" /* Pending */,
                  ExpiresAt,
                  DiscoveryTaskId,
                  Source: "INVENTORY_SCAN_STATUS"
                };
                const params = {
                  TableName: ScanStatusTableName,
                  Item,
                  ConditionExpression: "ResourceId <> :uid and ScanType <> :scanType",
                  ExpressionAttributeValues: {
                    ":uid": ResourceId,
                    ":scanType": scanType
                  }
                };
                await dynamodbClient.send(new import_lib_dynamodb.PutCommand(params));
              })
            );
          }

          // src/lambda/code/createInventoryScanStatus.ts
          var handler = async function(event) {
            const {
              ResourceId,
              ResourceName,
              ResourceType,
              ScanTypes,
              ExpiresAt,
              TargetRegion,
              TargetAccount,
              VolumeCount,
              Platform,
              DiscoveryTaskId
            } = event;
            const dynamodbClient = new import_client_dynamodb.DynamoDBClient({
              region: process.env.AWS_REGION || "us-east-1"
            });
            await saveResourceToScanStatus(
              {
                ResourceId,
                ResourceName,
                ResourceType,
                ScanTypes,
                Platform,
                TargetRegion,
                TargetAccount,
                VolumeCount,
                ExpiresAt,
                DiscoveryTaskId
              },
              { dynamodbClient }
            );
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          ScanStatesPending: PENDING
          ScanStatusTableName: qualys-inventory-scan-status
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-create-inventory-scan-statuses
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdagenerateScanTypesChunks:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/generateScanTypesChunks.ts
          var generateScanTypesChunks_exports = {};
          __export(generateScanTypesChunks_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(generateScanTypesChunks_exports);
          var handler = async function(event) {
            const { chunkConfigurations, scannerPlatforms } = event;
            return chunkConfigurations.filter(
              (a) => scannerPlatforms.indexOf(a.platform) >= 0
            );
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-generate-scan-types-chunks
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdafetchInventoryChunks:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/fetchInventoryChunks.ts
          var fetchInventoryChunks_exports = {};
          __export(fetchInventoryChunks_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(fetchInventoryChunks_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/lib/getProperty.ts
          function getProperty(obj, path) {
            const keys = path.split(".");
            let result = obj;
            for (let index = 0; index < keys.length; index++) {
              const key = keys[index];
              if (key === "$") continue;
              if (key === "*") {
                if (!Array.isArray(result)) {
                  return void 0;
                }
                const subPath = keys.slice(index + 1).join(".");
                return result.map((element) => getProperty(element, subPath));
              }
              if (result[key] === void 0) {
                return void 0;
              }
              result = result[key];
            }
            return result;
          }

          // src/lambda/code/lib/array.ts
          function sliceByWeight({
            array,
            weightedProperty,
            maxWeight
          }) {
            const result = [];
            let temp = [];
            let tempWeight = 0;
            for (const item of array) {
              let itemWeight = getProperty(item, weightedProperty);
              if (typeof itemWeight === "string") itemWeight = Number(itemWeight);
              if (typeof itemWeight !== "number" || isNaN(itemWeight)) itemWeight = 0;
              if (tempWeight + itemWeight <= maxWeight) {
                temp.push(item);
                tempWeight += itemWeight;
              } else {
                result.push(temp);
                temp = [item];
                tempWeight = itemWeight;
              }
            }
            if (temp.length) {
              result.push(temp);
            }
            return result;
          }

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/fetchInventoryChunks.ts
          var DbRegionPlatformIndex = process.env.DbRegionPlatformIndex || "byRegionAndPlatform";
          var ScanStatusTableName = process.env.ScanStatusTableName ?? RESOURCE_INVENTORY_SCAN_STATUS_TABLE;
          var SCAN_QUERY_LIMIT = parseInt(process.env.SCAN_QUERY_LIMIT || "1200");
          var MAX_SCAN_ATTEMPTS = parseInt(process.env.MAX_SCAN_ATTEMPTS || "2");
          var handler = async function(event) {
            const { ScanTypesConfig, TargetRegion, ExclusiveStartKey, CorrelationId } = event;
            const dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId })
            });
            const ddbDocClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
            const KeyConditionExpression = "TargetRegion = :region AND ScannerPlatform = :platform";
            let FilterExpression = "ScanAttempts < :maxScanAttempt AND ScanStatus = :state";
            const ExpressionAttributeValues = {
              ":region": TargetRegion,
              ":state": "PENDING" /* Pending */,
              ":maxScanAttempt": MAX_SCAN_ATTEMPTS,
              ":platform": ScanTypesConfig.platform
            };
            let ScanTypeInExpression = `ScanType IN (`;
            for (let i = 0; i < ScanTypesConfig.scanTypes.length; i += 1) {
              const scanType = ScanTypesConfig.scanTypes[i];
              let key = `:st${i}`;
              ExpressionAttributeValues[`:st${i}`] = scanType;
              if (i !== ScanTypesConfig.scanTypes.length - 1) {
                key += ",";
              }
              ScanTypeInExpression += key;
            }
            ScanTypeInExpression += ")";
            FilterExpression += ` AND ${ScanTypeInExpression}`;
            const { Items, LastEvaluatedKey } = await ddbDocClient.send(
              new import_lib_dynamodb.QueryCommand({
                TableName: ScanStatusTableName,
                IndexName: DbRegionPlatformIndex,
                Limit: SCAN_QUERY_LIMIT,
                KeyConditionExpression,
                FilterExpression,
                ExpressionAttributeValues,
                ProjectionExpression: "ResourceId, ScanType, VolumeCount, ScanAttempts",
                ScanIndexForward: false,
                ConsistentRead: false,
                ExclusiveStartKey: ExclusiveStartKey == null ? void 0 : ExclusiveStartKey
              })
            );
            const chunkSize = ScanTypesConfig.volumeChunkSize;
            const resources = [];
            for (const item of Items) {
              const existingResourceIndex = resources.findIndex(
                (a) => a.UID === item.ResourceId
              );
              if (existingResourceIndex === -1) {
                resources.push({
                  ScanTypes: [item.ScanType],
                  ScanAttempts: [item.ScanAttempts],
                  VolumeCount: item.VolumeCount,
                  UID: item.ResourceId
                });
              } else {
                resources[existingResourceIndex].ScanTypes.push(item.ScanType);
                resources[existingResourceIndex].ScanAttempts.push(item.ScanAttempts);
                if (resources[existingResourceIndex].VolumeCount < item.VolumeCount) {
                  resources[existingResourceIndex].VolumeCount = item.VolumeCount;
                }
              }
            }
            console.log(resources);
            const chunked = sliceByWeight({
              array: resources.map((a) => ({
                ...a
              })),
              weightedProperty: "VolumeCount",
              maxWeight: chunkSize
            });
            return {
              InstanceBatches: chunked,
              LastEvaluatedKey
            };
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          DbRegionPlatformIndex: byRegionAndPlatform
          ScanStatesPending: PENDING
          ScanStatusTableName: qualys-inventory-scan-status
          SCAN_QUERY_LIMIT: "1200"
          MAX_SCAN_ATTEMPTS: "2"
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-fetch-inventory-chunks
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 120
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdagenerateScanInstancesParams:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/generateScanInstancesParams.ts
          var generateScanInstancesParams_exports = {};
          __export(generateScanInstancesParams_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(generateScanInstancesParams_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_client_ec2 = require("@aws-sdk/client-ec2");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/lib/transformDevicePathMap.ts
          function transformDevicePathMap(params) {
            if (!params.linuxDeviceNames)
              params.linuxDeviceNames = "b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y";
            if (!params.TargetInstances) params.TargetInstances = [];
            const linuxDeviceNames2 = params.linuxDeviceNames.split(",");
            const DevicePathMaps = [];
            let i = 0;
            for (const TargetInstance of params.TargetInstances) {
              for (let j = 0; j < TargetInstance.Snapshots.length; j += 1) {
                const snapshot = TargetInstance.Snapshots[j];
                let volume;
                if (TargetInstance.VolumeIds != null && j < TargetInstance.VolumeIds.length) {
                  volume = TargetInstance.VolumeIds[j];
                }
                DevicePathMaps.push({
                  InstanceId: TargetInstance.InstanceId,
                  SnapshotId: snapshot,
                  DevicePath: `/dev/sd${linuxDeviceNames2[i]}`,
                  VolumeId: volume
                });
                i += 1;
              }
            }
            return DevicePathMaps;
          }

          // src/lambda/code/generateScanInstancesParams.ts
          var InventoryTableName = process.env.InventoryTableName ?? RESOURCE_INVENTORY_TABLE;
          var AppConfigTable = process.env.QualysAppConfigTable || APP_CONFIG_TABLE;
          function generateAlphabetString(startChar, endChar) {
            const startCode = startChar.charCodeAt(0);
            const endCode = endChar.charCodeAt(0);
            let alphabetString = "";
            for (let i = startCode; i <= endCode; i++) {
              alphabetString += String.fromCharCode(i);
              if (i !== endCode) {
                alphabetString += ",";
              }
            }
            return alphabetString;
          }
          var linuxDeviceNames = generateAlphabetString("b", "y");
          var GetIntancesFromDynamo = async ({
            TargetInstances,
            ProjectionExpression
          }, { ddbDocClient }) => {
            const ResourceInventoryKeys = TargetInstances.map((a) => ({ UID: a.UID }));
            const {
              Responses: { [InventoryTableName]: ResourceInstances }
            } = await ddbDocClient.send(
              new import_lib_dynamodb.BatchGetCommand({
                RequestItems: {
                  [InventoryTableName]: {
                    Keys: ResourceInventoryKeys,
                    ProjectionExpression
                  }
                }
              })
            );
            return {
              ResourceInstances
            };
          };
          var GetCliConfigFromDynamo = async ({
            ScanTypesConfig
          }, { ddbDocClient }) => {
            const CliConfigs = await Promise.all(
              ScanTypesConfig.scanTypes.map(async (scanType) => {
                const { Items } = await ddbDocClient.send(
                  new import_lib_dynamodb.QueryCommand({
                    TableName: AppConfigTable,
                    IndexName: "byConfigValue",
                    KeyConditionExpression: "uid = :uid AND configId = :configId",
                    ExpressionAttributeValues: {
                      ":uid": `${ScanTypesConfig.platform}-${scanType}`,
                      ":configId": CLI_CONFIG_PARAMETER
                    }
                  })
                );
                return {
                  scanType,
                  config: JSON.parse(Items[0].value).__v.config
                };
              })
            );
            return {
              CliConfigs: CliConfigs.reduce(
                (a, b) => ({ ...a, [b.scanType]: b.config }),
                {}
              )
            };
          };
          var CombineResourceAndScanType = ({
            ResourceInstances,
            TargetInstances
          }) => {
            const ScanTargets = [];
            for (const ResourceInstance of ResourceInstances) {
              if (ResourceInstance.ScannerState === "SNAPSHOT_COMPLETED" /* SnapshotCompleted */) {
                const originalInstance = TargetInstances.find(
                  (a) => a.UID === ResourceInstance.UID
                );
                if (originalInstance) {
                  for (let i = 0; i < originalInstance.ScanTypes.length; i += 1) {
                    const ScanType = originalInstance.ScanTypes[i];
                    const ScanAttempts = originalInstance.ScanAttempts[i];
                    ScanTargets.push({
                      ...ResourceInstance,
                      ScanType,
                      ScanAttempts
                    });
                  }
                }
              }
            }
            return {
              ScanTargets
            };
          };
          var GenerateDevicePathMap = ({ Instances }) => {
            const DevicePathMaps = transformDevicePathMap({
              linuxDeviceNames,
              TargetInstances: Instances
            });
            return {
              DevicePathMaps
            };
          };
          var GenerateCreateInstanceParams = function({
            Config,
            TargetRegion,
            RegionConfig,
            ScanTypesConfig
          }) {
            const imageId = Config.amiIds[ScanTypesConfig.platform][TargetRegion];
            const CreateInstanceParams = {
              ImageId: imageId,
              InstanceType: ScanTypesConfig.instanceType,
              SecurityGroupIds: [RegionConfig.ScannerSecurityGroupId],
              SubnetId: RegionConfig.ScannerSubnetId
            };
            return {
              CreateInstanceParams
            };
          };
          var confirmIfSnapshotExists = async ({
            ResourceInstances
          }, { ec2Client }) => {
            const SnapshotIds = ResourceInstances.flatMap((a) => a.Snapshots).filter(
              (a) => a != null
            );
            const { Snapshots } = await ec2Client.send(
              new import_client_ec2.DescribeSnapshotsCommand({
                Filters: [
                  {
                    Name: "snapshot-id",
                    Values: SnapshotIds
                  }
                ]
              })
            );
            console.log(`All Resources: ${ResourceInstances.length}`);
            const FilteredResourceInstances = ResourceInstances.filter((a) => {
              let snapshotsExist = true;
              for (const SnapshotId of a.Snapshots ?? []) {
                if (!Snapshots?.find((a2) => a2.SnapshotId === SnapshotId)) {
                  snapshotsExist = false;
                }
              }
              return snapshotsExist;
            });
            console.log(`Included Resources: ${FilteredResourceInstances.length}`);
            return {
              ResourceInstances: FilteredResourceInstances
            };
          };
          var handler = async function(event) {
            const {
              TargetInstances,
              ProjectionExpression,
              ScanTypesConfig,
              RegionConfig,
              Config,
              TargetRegion,
              CorrelationId
            } = event;
            const dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId })
            });
            const ddbDocClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
            const ec2Client = new import_client_ec2.EC2Client({
              region: TargetRegion
            });
            const { ResourceInstances: OriginalResourceInstances } = await GetIntancesFromDynamo(
              { TargetInstances, ProjectionExpression },
              { ddbDocClient }
            );
            console.log(OriginalResourceInstances);
            const { ResourceInstances } = await confirmIfSnapshotExists(
              {
                ResourceInstances: OriginalResourceInstances
              },
              { ec2Client }
            );
            const { CliConfigs } = await GetCliConfigFromDynamo(
              {
                ScanTypesConfig
              },
              { ddbDocClient }
            );
            console.log(CliConfigs);
            const { ScanTargets } = CombineResourceAndScanType({
              ResourceInstances,
              TargetInstances
            });
            console.log(ScanTargets);
            const { DevicePathMaps } = GenerateDevicePathMap({
              Instances: ResourceInstances
            });
            console.log(DevicePathMaps);
            const { CreateInstanceParams } = GenerateCreateInstanceParams({
              Config,
              TargetRegion,
              RegionConfig,
              ScanTypesConfig
            });
            console.log(CreateInstanceParams);
            return {
              ScanTargets,
              DevicePathMaps,
              CreateInstanceParams,
              CliConfigs,
              S3BucketName: getS3BucketName(TargetRegion)
            };
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-generate-scan-instances-params
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 256
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 120
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaAppConfigStore:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/appConfig.ts
          var appConfig_exports = {};
          __export(appConfig_exports, {
            configActionHandler: () => configActionHandler,
            handler: () => handler
          });
          module.exports = __toCommonJS(appConfig_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_util_dynamodb = require("@aws-sdk/util-dynamodb");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/appConfig.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var AppConfig = class {
            opts;
            client;
            constructor({
              region,
              tableName,
              configId,
              isArray,
              lookupKey,
              lookupKeyIndex
            }) {
              this.opts = { tableName, configId, isArray, lookupKey, lookupKeyIndex };
              Object.freeze(this.opts);
              this.client = new import_client_dynamodb.DynamoDBClient({ region });
            }
            serialize(value) {
              return JSON.stringify({ __v: value });
            }
            deserialize(value) {
              return JSON.parse(value).__v;
            }
            async listCfg(args) {
              return this.getCfg(args);
            }
            async getCfg({
              nextMarker,
              maxItems = 100
            }) {
              const { Items, LastEvaluatedKey } = await this.query({
                keyExpression: this.opts.isArray || nextMarker ? this.getKeyExpression({ configId: this.opts.configId }) : this.getKeyExpression({ configId: this.opts.configId, idx: 0 }),
                nextMarker,
                maxItems
              });
              const result = Items.map((u) => this.deserialize(u.value));
              return {
                data: result.length > 1 || this.opts.isArray ? result : result[0],
                nextMarker: LastEvaluatedKey || false
              };
            }
            getKeyExpression(obj) {
              return {
                KeyConditionExpression: Object.keys(obj).map((j) => `${j} = :${j}`).join(" and "),
                ExpressionAttributeValues: (0, import_util_dynamodb.marshall)(
                  Object.fromEntries(Object.entries(obj).map(([k, v]) => [`:${k}`, v]))
                )
              };
            }
            async query({
              keyExpression,
              nextMarker,
              maxItems,
              ascOrder = true,
              indexName
            }) {
              const params = {
                TableName: this.opts.tableName,
                ...keyExpression,
                Limit: maxItems,
                ExclusiveStartKey: nextMarker ? (0, import_util_dynamodb.marshall)(nextMarker) : void 0,
                ConsistentRead: true,
                ScanIndexForward: ascOrder,
                IndexName: indexName
              };
              const command = new import_client_dynamodb.QueryCommand(params);
              const { Items, LastEvaluatedKey } = await this.client.send(command);
              return {
                Items: Items.map((item) => (0, import_util_dynamodb.unmarshall)(item)),
                LastEvaluatedKey: LastEvaluatedKey ? (0, import_util_dynamodb.unmarshall)(LastEvaluatedKey) : null
              };
            }
            async putCfg({ value }) {
              await this.appendCfg({ value, startFromZero: true });
              await this.destroyCfg({
                nextMarker: {
                  idx: Array.isArray(value) && value.length > 0 ? value.length - 1 : 0,
                  configId: this.opts.configId
                }
              });
            }
            async appendCfg({
              value,
              startFromZero = false
            }) {
              if (!Array.isArray(value)) value = [value];
              let startIndex = 0;
              if (!startFromZero) {
                const result = await this.query({
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId }),
                  maxItems: 1,
                  ascOrder: false
                });
                startIndex = result.Items.length > 0 ? result.Items[0].idx + 1 : 0;
              }
              const batchSize = 25;
              for (let i = 0; i < value.length; i += batchSize) {
                const batch = value.slice(i, i + batchSize);
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: batch.map((e, j) => ({
                      PutRequest: {
                        Item: (0, import_util_dynamodb.marshall)({
                          configId: this.opts.configId,
                          idx: i + j + startIndex,
                          value: this.serialize(e),
                          ...this.opts.lookupKey && e[this.opts.lookupKey] && {
                            uid: e[this.opts.lookupKey].toString()
                          }
                        })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              }
            }
            async destroyCfg({
              nextMarker
            }) {
              do {
                const { Items, LastEvaluatedKey } = await this.query({
                  nextMarker,
                  maxItems: 25,
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId })
                });
                nextMarker = LastEvaluatedKey;
                if (!Items.length) break;
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: Items.map((e) => ({
                      DeleteRequest: {
                        Key: (0, import_util_dynamodb.marshall)({ configId: e.configId, idx: e.idx })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              } while (nextMarker);
            }
            async findCfg({ lookupValue }) {
              const { Items } = await this.query({
                keyExpression: this.getKeyExpression({
                  configId: this.opts.configId,
                  uid: lookupValue
                }),
                maxItems: 1,
                indexName: this.opts.lookupKeyIndex
              });
              const data = Items.map((u) => this.deserialize(u.value));
              return { data: data.length ? data[0] : void 0 };
            }
          };
          async function configActionHandler(event) {
            const {
              region = process.env.AWS_REGION || "us-east-1",
              configName,
              action,
              value,
              maxItems,
              nextMarker,
              lookupKey,
              lookupValue,
              lookupKeyIndex = process.env.LookupIndex || "byConfigValue"
            } = event;
            if (!["put", "get", "append", "destroy", "list", "find"].includes(action)) {
              throw new Error("Invalid value for field `action`");
            }
            const isArray = Array.isArray(value) || ["append", "list", "destroy"].includes(action);
            const tableName = process.env.QualysAppConfigTable || APP_CONFIG_TABLE;
            const cfg = new AppConfig({
              region,
              tableName,
              configId: configName,
              isArray,
              lookupKey,
              lookupKeyIndex
            });
            return cfg[`${action}Cfg`]({ nextMarker, value, lookupValue, maxItems });
          }
          var handler = configActionHandler;
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            configActionHandler,
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          QualysAppConfigTable: qualys-app-config
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-app-config-store
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaCFTCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __create = Object.create;
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __getProtoOf = Object.getPrototypeOf;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
            mod
          ));
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/cleanup.ts
          var cleanup_exports = {};
          __export(cleanup_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(cleanup_exports);
          var import_client_sfn = require("@aws-sdk/client-sfn");

          // src/lambda/code/lib/httpReq.ts
          var import_https = __toESM(require("https"));

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/httpReq.ts
          var httpsReq = (url, method, headers = {}, body = null, logger = getLogger({})) => {
            logger.log("api call intiating", { url, method, headers });
            return new Promise((resolve, reject) => {
              const req = import_https.default.request(url, { method, headers }, (res) => {
                let responseData = "";
                res.on("data", (chunk) => {
                  responseData += chunk;
                });
                res.on("end", () => {
                  try {
                    if (res.statusCode != null && res.statusCode >= 200 && res.statusCode < 300) {
                      if (headers.accept === "application/json") {
                        const parsedData = JSON.parse(responseData);
                        logger.log("api call success", url, parsedData);
                        resolve(parsedData);
                      } else {
                        logger.log("api call success", url, responseData);
                        resolve(responseData);
                      }
                    } else {
                      logger.error("Api call failed:", url, res.statusCode, responseData);
                      reject(
                        new Error(
                          `Request failed with status code ${res.statusCode}: ${responseData}`
                        )
                      );
                    }
                  } catch (error) {
                    logger.error("Api call failed:", url, responseData);
                    reject(error);
                  }
                });
              });
              req.on("error", (err) => {
                reject(err);
              });
              if (body) {
                req.write(body);
              }
              req.end();
            });
          };

          // src/lambda/code/lib/cfnResponse.ts
          var SUCCESS = "SUCCESS";
          var FAILED = "FAILED";
          var send = async function(event, context, responseStatus, responseData, physicalResourceId, noEcho) {
            const responseBody = JSON.stringify({
              Status: responseStatus,
              Reason: "See the details in CloudWatch Log Stream: " + context.logStreamName,
              PhysicalResourceId: physicalResourceId || context.logStreamName,
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              NoEcho: noEcho || false,
              Data: responseData
            });
            console.log("CFN Request body:\n", responseBody);
            return httpsReq(
              event.ResponseURL,
              "PUT",
              {
                "content-type": "",
                "content-length": responseBody.length
              },
              responseBody
            );
          };

          // src/lambda/code/s3Management.ts
          var import_client_s3 = require("@aws-sdk/client-s3");
          var import_client_cloudwatch_logs = require("@aws-sdk/client-cloudwatch-logs");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/lib/sgEgress.ts
          var import_client_ec2 = require("@aws-sdk/client-ec2");
          var TagAppKey = process.env.TagAppKey || "";
          var TagAppValue = process.env.TagAppValue || "";
          async function getScannerSg(region) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { SecurityGroups } = await ec2Client.send(
              new import_client_ec2.DescribeSecurityGroupsCommand({
                Filters: [
                  {
                    Name: "group-name",
                    Values: [EC2_SCANNER_SECURITY_GROUP_NAME]
                  },
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  }
                ]
              })
            );
            if (!SecurityGroups || SecurityGroups.length == 0) {
              throw new Error("Security group not found");
            }
            return SecurityGroups[0];
          }
          async function findPrefixIdForService(region, service) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { PrefixLists } = await ec2Client.send(
              new import_client_ec2.DescribePrefixListsCommand({
                Filters: [
                  {
                    Name: "prefix-list-name",
                    Values: [`com.amazonaws.${region}.${service}`]
                  }
                ]
              })
            );
            if (!PrefixLists || PrefixLists.length == 0) {
              throw new Error("Prefix list not found");
            }
            const prefixListId = PrefixLists[0].PrefixListId;
            if (!prefixListId) {
              throw new Error("Prefix list id not found");
            }
            return prefixListId;
          }
          async function addServiceEgressToSg(region, securityGroup, service, port) {
            const prefixId = await findPrefixIdForService(region, service);
            const egress = securityGroup.IpPermissionsEgress;
            console.log(egress);
            const existingEgress = egress?.find(
              (a) => a.PrefixListIds?.find((a2) => a2.PrefixListId == prefixId) != null
            );
            if (!existingEgress) {
              const ec2Client = new import_client_ec2.EC2Client({ region });
              await ec2Client.send(
                new import_client_ec2.AuthorizeSecurityGroupEgressCommand({
                  GroupId: securityGroup.GroupId,
                  IpPermissions: [
                    {
                      IpProtocol: "tcp",
                      FromPort: port,
                      ToPort: port,
                      PrefixListIds: [
                        {
                          Description: "Allow connection to s3",
                          PrefixListId: prefixId
                        }
                      ]
                    }
                  ]
                })
              );
            }
          }
          async function addEgressToScannerSg(region) {
            const securityGroup = await getScannerSg(region);
            await addServiceEgressToSg(region, securityGroup, "s3", 443);
          }
          async function restrictDefaultSecurityGroup(region) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { Vpcs } = await ec2Client.send(
              new import_client_ec2.DescribeVpcsCommand({
                Filters: [
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  }
                ]
              })
            );
            if (!Vpcs || Vpcs.length == 0) {
              throw new Error("Vpc not found");
            }
            const vpcId = Vpcs[0].VpcId;
            if (!vpcId) {
              throw new Error("Vpc not found");
            }
            const { SecurityGroups } = await ec2Client.send(
              new import_client_ec2.DescribeSecurityGroupsCommand({
                Filters: [
                  {
                    Name: "group-name",
                    Values: ["default"]
                  },
                  {
                    Name: "vpc-id",
                    Values: [vpcId]
                  }
                ]
              })
            );
            if (!SecurityGroups || SecurityGroups.length == 0) {
              throw new Error("Security group not found");
            }
            const GroupId = SecurityGroups[0].GroupId;
            const securityGroupEgress = SecurityGroups[0].IpPermissionsEgress;
            if (securityGroupEgress && securityGroupEgress.length > 0) {
              await ec2Client.send(
                new import_client_ec2.RevokeSecurityGroupEgressCommand({
                  GroupId,
                  IpPermissions: securityGroupEgress
                })
              );
            }
            const securityGroupIngress = SecurityGroups[0].IpPermissions;
            if (securityGroupIngress && securityGroupIngress.length > 0) {
              await ec2Client.send(
                new import_client_ec2.RevokeSecurityGroupIngressCommand({
                  GroupId,
                  IpPermissions: securityGroupIngress
                })
              );
            }
          }

          // src/lambda/code/s3Management.ts
          var TagAppKey2 = process.env.TagAppKey || "";
          var TagAppValue2 = process.env.TagAppValue || "";
          async function checkIfBucketExists(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            try {
              const existingBucket = await s3Client.send(
                new import_client_s3.HeadBucketCommand({ Bucket: getS3BucketName(region) })
              );
              return existingBucket.BucketRegion != null;
            } catch (e) {
              if (e instanceof import_client_s3.NotFound) {
                return false;
              }
              console.log(e);
              return false;
            }
          }
          async function createS3Bucket(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            try {
              const exists = await checkIfBucketExists(region);
              if (exists) {
                return;
              }
              const Bucket = getS3BucketName(region);
              await s3Client.send(
                new import_client_s3.CreateBucketCommand({
                  Bucket
                })
              );
            } catch (e) {
              if (e instanceof import_client_s3.BucketAlreadyExists) {
                console.log("Bucket already exists");
              } else if (e instanceof import_client_s3.BucketAlreadyOwnedByYou) {
                console.log("Bucket already exists");
              } else {
                throw e;
              }
            }
          }
          async function createS3BucketPolicy(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketPolicyCommand({
                Bucket,
                Policy: JSON.stringify({
                  Version: "2012-10-17",
                  Statement: [
                    {
                      Sid: "DenyHttpOnly",
                      Principal: "*",
                      Effect: "Deny",
                      Action: ["s3:*"],
                      Resource: [`arn:${process.env.AWS_PARTITION}:s3:::${Bucket}/*`],
                      Condition: {
                        Bool: {
                          "aws:SecureTransport": "false"
                        }
                      }
                    }
                  ]
                })
              })
            );
          }
          async function enableBucketVersioning(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketVersioningCommand({
                Bucket,
                VersioningConfiguration: {
                  Status: "Enabled"
                }
              })
            );
          }
          async function addS3BucketTag(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketTaggingCommand({
                Bucket,
                Tagging: {
                  TagSet: [
                    {
                      Key: TagAppKey2,
                      Value: TagAppValue2
                    }
                  ]
                }
              })
            );
          }
          async function createS3LifecycleConfigurations(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketLifecycleConfigurationCommand({
                Bucket,
                LifecycleConfiguration: {
                  Rules: [
                    {
                      ID: `${Bucket}-data-expiration`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Expiration: {
                        Days: 1
                      },
                      Filter: {
                        Prefix: "data"
                      },
                      Status: "Enabled"
                    },
                    {
                      ID: `${Bucket}-logs-expiration`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Expiration: {
                        Days: 1
                      },
                      Filter: {
                        Prefix: "logs"
                      },
                      Status: "Enabled"
                    },
                    {
                      ID: `${Bucket}-logs-artifacts`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Filter: {
                        Prefix: "artifacts"
                      },
                      Status: "Enabled"
                    }
                  ]
                }
              })
            );
          }
          async function deleteDanglingLogGroups(region) {
            if (region === (process.env.AWS_REGION || "us-east-1")) {
              return;
            }
            const logClient = new import_client_cloudwatch_logs.CloudWatchLogsClient({
              region
            });
            const { logGroups } = await logClient.send(
              new import_client_cloudwatch_logs.DescribeLogGroupsCommand({
                logGroupNamePrefix: "/qualys/logs"
              })
            );
            if (logGroups && logGroups.length > 0) {
              await logClient.send(
                new import_client_cloudwatch_logs.DeleteLogGroupCommand({
                  logGroupName: logGroups[0].logGroupName
                })
              );
            }
          }
          async function emptyS3BucketVersions(region, PreviousToken) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            const { Versions, NextKeyMarker } = await s3Client.send(
              new import_client_s3.ListObjectVersionsCommand({
                Bucket,
                KeyMarker: PreviousToken
              })
            );
            if (Versions) {
              console.log(
                `Found ${Versions.length} versions in bucket ${Bucket}, deleting all`
              );
              await s3Client.send(
                new import_client_s3.DeleteObjectsCommand({
                  Bucket,
                  Delete: {
                    Objects: Versions.map((Item) => ({
                      Key: Item.Key,
                      VersionId: Item.VersionId
                    }))
                  }
                })
              );
            }
            if (NextKeyMarker) {
              await emptyS3BucketVersions(region, NextKeyMarker);
            }
          }
          async function emptyS3BucketDeleteMarkers(region, PreviousToken) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            const { DeleteMarkers, NextKeyMarker } = await s3Client.send(
              new import_client_s3.ListObjectVersionsCommand({
                Bucket,
                KeyMarker: PreviousToken
              })
            );
            if (DeleteMarkers) {
              console.log(
                `Found ${DeleteMarkers.length} Delete Markers in bucket ${Bucket}, deleting all`
              );
              await s3Client.send(
                new import_client_s3.DeleteObjectsCommand({
                  Bucket,
                  Delete: {
                    Objects: DeleteMarkers.map((Item) => ({
                      Key: Item.Key,
                      VersionId: Item.VersionId
                    }))
                  }
                })
              );
            }
            if (NextKeyMarker) {
              await emptyS3BucketDeleteMarkers(region, NextKeyMarker);
            }
          }
          async function deleteS3Bucket(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            await s3Client.send(
              new import_client_s3.DeleteBucketCommand({
                Bucket: getS3BucketName(region)
              })
            );
          }
          async function createS3Region(region) {
            await createS3Bucket(region);
            await createS3BucketPolicy(region);
            await addS3BucketTag(region);
            await enableBucketVersioning(region);
            await createS3LifecycleConfigurations(region);
            await addEgressToScannerSg(region);
            await restrictDefaultSecurityGroup(region);
            await deleteDanglingLogGroups(region);
          }
          async function deleteS3Region(region) {
            const exists = await checkIfBucketExists(region);
            if (exists) {
              await emptyS3BucketVersions(region);
              await emptyS3BucketDeleteMarkers(region);
              await deleteS3Bucket(region);
            }
          }
          async function deleteDanglingS3Buckets(regions) {
            const s3Client = new import_client_s3.S3Client({
              region: process.env.AWS_REGION || "us-east-1"
            });
            const { Buckets } = await s3Client.send(
              new import_client_s3.ListBucketsCommand({
                Prefix: getS3BucketNamePrefix()
              })
            );
            for (const bucket of Buckets ?? []) {
              if (bucket.BucketRegion != null && regions.indexOf(bucket.BucketRegion) == -1) {
                await deleteS3Region(bucket.BucketRegion);
              }
            }
          }
          var getServiceRegions = () => {
            return (process.env.SERVICE_REGIONS || "").split(",");
          };
          var s3Management = async ({
            action
          }) => {
            if (action === "CREATE") {
              await Promise.all(getServiceRegions().map(createS3Region));
              await deleteDanglingS3Buckets(getServiceRegions());
            } else if (action === "DELETE") {
              await Promise.all(getServiceRegions().map(deleteS3Region));
            }
          };

          // src/lambda/code/cleanup.ts
          var sfnClient = new import_client_sfn.SFNClient({});
          async function isSfnRunning(executionArn) {
            const command = new import_client_sfn.DescribeExecutionCommand({
              executionArn
            });
            const description = await sfnClient.send(command);
            console.log("ExecutionArn", executionArn, "Status", description.status);
            return description.status === "RUNNING";
          }
          async function execSfn(stateMachineArn, input) {
            const startCommand = new import_client_sfn.StartExecutionCommand({
              stateMachineArn,
              input: JSON.stringify(input)
            });
            const execution = await sfnClient.send(startCommand);
            const executionArn = execution.executionArn;
            let i = 0;
            do {
              i += 1;
              if (i > 10) {
                break;
              }
              await new Promise((resolve) => setTimeout(resolve, 3e3));
            } while (await isSfnRunning(executionArn));
          }
          async function deleteS3Buckets(retriesLeft = 3) {
            try {
              await s3Management({ action: "DELETE" });
            } catch (e) {
              if (retriesLeft > 0) {
                return await deleteS3Buckets(retriesLeft - 1);
              } else {
                throw e;
              }
            }
          }
          var handler = async function(event, context) {
            const region = process.env.AWS_REGION;
            const tasks = [
              {
                sfnName: process.env.SfnCleanup,
                input: {
                  minInstanceAge: 0,
                  minSnapshotAge: 0
                }
              },
              {
                sfnName: process.env.SfnDeregisterServiceAccount,
                input: {
                  deleteResources: true
                }
              }
            ];
            const ACCOUNT_ID = context.invokedFunctionArn.split(":")[4];
            console.log("event", JSON.stringify(event));
            if (event.RequestType === "Delete") {
              for (const { sfnName, input } of tasks) {
                try {
                  const stateMachineArn = `arn:${process.env.AWS_PARTITION}:states:${region}:${ACCOUNT_ID}:stateMachine:${sfnName}`;
                  await execSfn(stateMachineArn, input);
                } catch (e) {
                  console.log(e);
                }
              }
              try {
                await deleteS3Buckets();
              } catch (e) {
                console.error(e);
                return send(event, context, FAILED, {}, event.PhysicalResourceId);
              }
            }
            return send(event, context, SUCCESS, {}, event.PhysicalResourceId);
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          TagAppKey: App
          TagAppValue: qualys-snapshot-scanner
          SfnCleanup: qualys-sfn-destroy-stale-resources
          SfnDeregisterServiceAccount: qualys-sfn-deregister-service-account
          AWS_PARTITION:
            Ref: AWS::Partition
          SERVICE_REGIONS:
            Fn::Join:
              - ","
              - Ref: Regions
      FunctionName: qualys-cft-cleanup
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 900
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaScannerAmiCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/scannerAmiCleanup.ts
          var scannerAmiCleanup_exports = {};
          __export(scannerAmiCleanup_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(scannerAmiCleanup_exports);
          var import_client_ec2 = require("@aws-sdk/client-ec2");
          var TagAppKey = process.env.TagAppKey || "";
          var TagAppValue = process.env.TagAppValue || "";
          var TagPurposeKey = process.env.TagPurposeKey || "";
          var TagPurposeAmiCreationValue = process.env.TagPurposeAmiCreationValue || "";
          var platformTagExist = (Image2) => {
            for (const tag of Image2.Tags) {
              if (tag.Key === "Platform") {
                return true;
              }
            }
            return false;
          };
          var deleteImagesAndSnapshots = async ({
            Region,
            GeneratedAmiResult
          }) => {
            const amiIds = [];
            for (const Platform in GeneratedAmiResult) {
              if (GeneratedAmiResult[Platform][Region]) {
                amiIds.push(GeneratedAmiResult[Platform][Region]);
              }
            }
            const ec2Client = new import_client_ec2.EC2Client({
              region: Region
            });
            const { Images } = await ec2Client.send(
              new import_client_ec2.DescribeImagesCommand({
                Filters: [
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  },
                  {
                    Name: `tag:${TagPurposeKey}`,
                    Values: [TagPurposeAmiCreationValue]
                  }
                ]
              })
            );
            console.log(Images);
            const DeleteImageIds = [];
            for (const Image2 of Images) {
              if (amiIds.indexOf(Image2.ImageId) === -1 || !platformTagExist(Image2)) {
                DeleteImageIds.push(Image2.ImageId);
              }
            }
            console.log(DeleteImageIds);
            await Promise.all(
              DeleteImageIds.map(
                (ImageId) => ec2Client.send(
                  new import_client_ec2.DeregisterImageCommand({
                    ImageId
                  })
                )
              )
            );
            console.log(amiIds);
            const { Images: CurrentImages } = await ec2Client.send(
              new import_client_ec2.DescribeImagesCommand({ ImageIds: amiIds })
            );
            const validSnapshotIds = CurrentImages.map(
              (a) => a.BlockDeviceMappings.map((a2) => a2.Ebs?.SnapshotId).filter((a2) => a2 != null)
            ).flat(1);
            console.log(validSnapshotIds);
            const { Snapshots } = await ec2Client.send(
              new import_client_ec2.DescribeSnapshotsCommand({
                Filters: [
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  },
                  {
                    Name: `tag:${TagPurposeKey}`,
                    Values: [TagPurposeAmiCreationValue]
                  }
                ]
              })
            );
            console.log(Snapshots);
            const DeleteSnapshotIds = [];
            for (const Snapshot2 of Snapshots) {
              if (validSnapshotIds.indexOf(Snapshot2.SnapshotId) === -1 || !platformTagExist(Snapshot2)) {
                DeleteSnapshotIds.push(Snapshot2.SnapshotId);
              }
            }
            console.log(DeleteSnapshotIds);
            await Promise.all(
              DeleteSnapshotIds.map(
                (SnapshotId) => ec2Client.send(
                  new import_client_ec2.DeleteSnapshotCommand({
                    SnapshotId
                  })
                )
              )
            );
          };
          var handler = async function(event) {
            const { Regions, GeneratedAmiResult } = event;
            await Promise.all(
              Regions.map(
                (Region) => deleteImagesAndSnapshots({ Region, GeneratedAmiResult })
              )
            );
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          TagAppKey: App
          TagAppValue: qualys-snapshot-scanner
          TagPurposeKey: InstancePurpose
          TagPurposeAmiCreationValue: AmiCreation
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-scanner-ami-cleanup
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 256
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 180
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaTaskWorker:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __create = Object.create;
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __getProtoOf = Object.getPrototypeOf;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __commonJS = (cb, mod) => function __require() {
            return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
          };
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
            mod
          ));
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // node_modules/lodash/_freeGlobal.js
          var require_freeGlobal = __commonJS({
            "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
              var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
              module2.exports = freeGlobal;
            }
          });

          // node_modules/lodash/_root.js
          var require_root = __commonJS({
            "node_modules/lodash/_root.js"(exports2, module2) {
              var freeGlobal = require_freeGlobal();
              var freeSelf = typeof self == "object" && self && self.Object === Object && self;
              var root = freeGlobal || freeSelf || Function("return this")();
              module2.exports = root;
            }
          });

          // node_modules/lodash/_Symbol.js
          var require_Symbol = __commonJS({
            "node_modules/lodash/_Symbol.js"(exports2, module2) {
              var root = require_root();
              var Symbol2 = root.Symbol;
              module2.exports = Symbol2;
            }
          });

          // node_modules/lodash/_getRawTag.js
          var require_getRawTag = __commonJS({
            "node_modules/lodash/_getRawTag.js"(exports2, module2) {
              var Symbol2 = require_Symbol();
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var nativeObjectToString = objectProto.toString;
              var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
              function getRawTag(value) {
                var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
                try {
                  value[symToStringTag] = void 0;
                  var unmasked = true;
                } catch (e) {
                }
                var result = nativeObjectToString.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag] = tag;
                  } else {
                    delete value[symToStringTag];
                  }
                }
                return result;
              }
              module2.exports = getRawTag;
            }
          });

          // node_modules/lodash/_objectToString.js
          var require_objectToString = __commonJS({
            "node_modules/lodash/_objectToString.js"(exports2, module2) {
              var objectProto = Object.prototype;
              var nativeObjectToString = objectProto.toString;
              function objectToString(value) {
                return nativeObjectToString.call(value);
              }
              module2.exports = objectToString;
            }
          });

          // node_modules/lodash/_baseGetTag.js
          var require_baseGetTag = __commonJS({
            "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
              var Symbol2 = require_Symbol();
              var getRawTag = require_getRawTag();
              var objectToString = require_objectToString();
              var nullTag = "[object Null]";
              var undefinedTag = "[object Undefined]";
              var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
              function baseGetTag(value) {
                if (value == null) {
                  return value === void 0 ? undefinedTag : nullTag;
                }
                return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
              }
              module2.exports = baseGetTag;
            }
          });

          // node_modules/lodash/isObject.js
          var require_isObject = __commonJS({
            "node_modules/lodash/isObject.js"(exports2, module2) {
              function isObject(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              module2.exports = isObject;
            }
          });

          // node_modules/lodash/isFunction.js
          var require_isFunction = __commonJS({
            "node_modules/lodash/isFunction.js"(exports2, module2) {
              var baseGetTag = require_baseGetTag();
              var isObject = require_isObject();
              var asyncTag = "[object AsyncFunction]";
              var funcTag = "[object Function]";
              var genTag = "[object GeneratorFunction]";
              var proxyTag = "[object Proxy]";
              function isFunction(value) {
                if (!isObject(value)) {
                  return false;
                }
                var tag = baseGetTag(value);
                return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
              }
              module2.exports = isFunction;
            }
          });

          // node_modules/lodash/_coreJsData.js
          var require_coreJsData = __commonJS({
            "node_modules/lodash/_coreJsData.js"(exports2, module2) {
              var root = require_root();
              var coreJsData = root["__core-js_shared__"];
              module2.exports = coreJsData;
            }
          });

          // node_modules/lodash/_isMasked.js
          var require_isMasked = __commonJS({
            "node_modules/lodash/_isMasked.js"(exports2, module2) {
              var coreJsData = require_coreJsData();
              var maskSrcKey = function() {
                var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              }();
              function isMasked(func) {
                return !!maskSrcKey && maskSrcKey in func;
              }
              module2.exports = isMasked;
            }
          });

          // node_modules/lodash/_toSource.js
          var require_toSource = __commonJS({
            "node_modules/lodash/_toSource.js"(exports2, module2) {
              var funcProto = Function.prototype;
              var funcToString = funcProto.toString;
              function toSource(func) {
                if (func != null) {
                  try {
                    return funcToString.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              module2.exports = toSource;
            }
          });

          // node_modules/lodash/_baseIsNative.js
          var require_baseIsNative = __commonJS({
            "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
              var isFunction = require_isFunction();
              var isMasked = require_isMasked();
              var isObject = require_isObject();
              var toSource = require_toSource();
              var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
              var reIsHostCtor = /^\[object .+?Constructor\]$/;
              var funcProto = Function.prototype;
              var objectProto = Object.prototype;
              var funcToString = funcProto.toString;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var reIsNative = RegExp(
                "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              function baseIsNative(value) {
                if (!isObject(value) || isMasked(value)) {
                  return false;
                }
                var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                return pattern.test(toSource(value));
              }
              module2.exports = baseIsNative;
            }
          });

          // node_modules/lodash/_getValue.js
          var require_getValue = __commonJS({
            "node_modules/lodash/_getValue.js"(exports2, module2) {
              function getValue(object, key) {
                return object == null ? void 0 : object[key];
              }
              module2.exports = getValue;
            }
          });

          // node_modules/lodash/_getNative.js
          var require_getNative = __commonJS({
            "node_modules/lodash/_getNative.js"(exports2, module2) {
              var baseIsNative = require_baseIsNative();
              var getValue = require_getValue();
              function getNative(object, key) {
                var value = getValue(object, key);
                return baseIsNative(value) ? value : void 0;
              }
              module2.exports = getNative;
            }
          });

          // node_modules/lodash/_nativeCreate.js
          var require_nativeCreate = __commonJS({
            "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
              var getNative = require_getNative();
              var nativeCreate = getNative(Object, "create");
              module2.exports = nativeCreate;
            }
          });

          // node_modules/lodash/_hashClear.js
          var require_hashClear = __commonJS({
            "node_modules/lodash/_hashClear.js"(exports2, module2) {
              var nativeCreate = require_nativeCreate();
              function hashClear() {
                this.__data__ = nativeCreate ? nativeCreate(null) : {};
                this.size = 0;
              }
              module2.exports = hashClear;
            }
          });

          // node_modules/lodash/_hashDelete.js
          var require_hashDelete = __commonJS({
            "node_modules/lodash/_hashDelete.js"(exports2, module2) {
              function hashDelete(key) {
                var result = this.has(key) && delete this.__data__[key];
                this.size -= result ? 1 : 0;
                return result;
              }
              module2.exports = hashDelete;
            }
          });

          // node_modules/lodash/_hashGet.js
          var require_hashGet = __commonJS({
            "node_modules/lodash/_hashGet.js"(exports2, module2) {
              var nativeCreate = require_nativeCreate();
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function hashGet(key) {
                var data = this.__data__;
                if (nativeCreate) {
                  var result = data[key];
                  return result === HASH_UNDEFINED ? void 0 : result;
                }
                return hasOwnProperty.call(data, key) ? data[key] : void 0;
              }
              module2.exports = hashGet;
            }
          });

          // node_modules/lodash/_hashHas.js
          var require_hashHas = __commonJS({
            "node_modules/lodash/_hashHas.js"(exports2, module2) {
              var nativeCreate = require_nativeCreate();
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function hashHas(key) {
                var data = this.__data__;
                return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
              }
              module2.exports = hashHas;
            }
          });

          // node_modules/lodash/_hashSet.js
          var require_hashSet = __commonJS({
            "node_modules/lodash/_hashSet.js"(exports2, module2) {
              var nativeCreate = require_nativeCreate();
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              function hashSet(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
                return this;
              }
              module2.exports = hashSet;
            }
          });

          // node_modules/lodash/_Hash.js
          var require_Hash = __commonJS({
            "node_modules/lodash/_Hash.js"(exports2, module2) {
              var hashClear = require_hashClear();
              var hashDelete = require_hashDelete();
              var hashGet = require_hashGet();
              var hashHas = require_hashHas();
              var hashSet = require_hashSet();
              function Hash(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              Hash.prototype.clear = hashClear;
              Hash.prototype["delete"] = hashDelete;
              Hash.prototype.get = hashGet;
              Hash.prototype.has = hashHas;
              Hash.prototype.set = hashSet;
              module2.exports = Hash;
            }
          });

          // node_modules/lodash/_listCacheClear.js
          var require_listCacheClear = __commonJS({
            "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
              function listCacheClear() {
                this.__data__ = [];
                this.size = 0;
              }
              module2.exports = listCacheClear;
            }
          });

          // node_modules/lodash/eq.js
          var require_eq = __commonJS({
            "node_modules/lodash/eq.js"(exports2, module2) {
              function eq(value, other) {
                return value === other || value !== value && other !== other;
              }
              module2.exports = eq;
            }
          });

          // node_modules/lodash/_assocIndexOf.js
          var require_assocIndexOf = __commonJS({
            "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
              var eq = require_eq();
              function assocIndexOf(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              module2.exports = assocIndexOf;
            }
          });

          // node_modules/lodash/_listCacheDelete.js
          var require_listCacheDelete = __commonJS({
            "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
              var assocIndexOf = require_assocIndexOf();
              var arrayProto = Array.prototype;
              var splice = arrayProto.splice;
              function listCacheDelete(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              module2.exports = listCacheDelete;
            }
          });

          // node_modules/lodash/_listCacheGet.js
          var require_listCacheGet = __commonJS({
            "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
              var assocIndexOf = require_assocIndexOf();
              function listCacheGet(key) {
                var data = this.__data__, index = assocIndexOf(data, key);
                return index < 0 ? void 0 : data[index][1];
              }
              module2.exports = listCacheGet;
            }
          });

          // node_modules/lodash/_listCacheHas.js
          var require_listCacheHas = __commonJS({
            "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
              var assocIndexOf = require_assocIndexOf();
              function listCacheHas(key) {
                return assocIndexOf(this.__data__, key) > -1;
              }
              module2.exports = listCacheHas;
            }
          });

          // node_modules/lodash/_listCacheSet.js
          var require_listCacheSet = __commonJS({
            "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
              var assocIndexOf = require_assocIndexOf();
              function listCacheSet(key, value) {
                var data = this.__data__, index = assocIndexOf(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              module2.exports = listCacheSet;
            }
          });

          // node_modules/lodash/_ListCache.js
          var require_ListCache = __commonJS({
            "node_modules/lodash/_ListCache.js"(exports2, module2) {
              var listCacheClear = require_listCacheClear();
              var listCacheDelete = require_listCacheDelete();
              var listCacheGet = require_listCacheGet();
              var listCacheHas = require_listCacheHas();
              var listCacheSet = require_listCacheSet();
              function ListCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              ListCache.prototype.clear = listCacheClear;
              ListCache.prototype["delete"] = listCacheDelete;
              ListCache.prototype.get = listCacheGet;
              ListCache.prototype.has = listCacheHas;
              ListCache.prototype.set = listCacheSet;
              module2.exports = ListCache;
            }
          });

          // node_modules/lodash/_Map.js
          var require_Map = __commonJS({
            "node_modules/lodash/_Map.js"(exports2, module2) {
              var getNative = require_getNative();
              var root = require_root();
              var Map2 = getNative(root, "Map");
              module2.exports = Map2;
            }
          });

          // node_modules/lodash/_mapCacheClear.js
          var require_mapCacheClear = __commonJS({
            "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
              var Hash = require_Hash();
              var ListCache = require_ListCache();
              var Map2 = require_Map();
              function mapCacheClear() {
                this.size = 0;
                this.__data__ = {
                  "hash": new Hash(),
                  "map": new (Map2 || ListCache)(),
                  "string": new Hash()
                };
              }
              module2.exports = mapCacheClear;
            }
          });

          // node_modules/lodash/_isKeyable.js
          var require_isKeyable = __commonJS({
            "node_modules/lodash/_isKeyable.js"(exports2, module2) {
              function isKeyable(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
              }
              module2.exports = isKeyable;
            }
          });

          // node_modules/lodash/_getMapData.js
          var require_getMapData = __commonJS({
            "node_modules/lodash/_getMapData.js"(exports2, module2) {
              var isKeyable = require_isKeyable();
              function getMapData(map, key) {
                var data = map.__data__;
                return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
              }
              module2.exports = getMapData;
            }
          });

          // node_modules/lodash/_mapCacheDelete.js
          var require_mapCacheDelete = __commonJS({
            "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
              var getMapData = require_getMapData();
              function mapCacheDelete(key) {
                var result = getMapData(this, key)["delete"](key);
                this.size -= result ? 1 : 0;
                return result;
              }
              module2.exports = mapCacheDelete;
            }
          });

          // node_modules/lodash/_mapCacheGet.js
          var require_mapCacheGet = __commonJS({
            "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
              var getMapData = require_getMapData();
              function mapCacheGet(key) {
                return getMapData(this, key).get(key);
              }
              module2.exports = mapCacheGet;
            }
          });

          // node_modules/lodash/_mapCacheHas.js
          var require_mapCacheHas = __commonJS({
            "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
              var getMapData = require_getMapData();
              function mapCacheHas(key) {
                return getMapData(this, key).has(key);
              }
              module2.exports = mapCacheHas;
            }
          });

          // node_modules/lodash/_mapCacheSet.js
          var require_mapCacheSet = __commonJS({
            "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
              var getMapData = require_getMapData();
              function mapCacheSet(key, value) {
                var data = getMapData(this, key), size = data.size;
                data.set(key, value);
                this.size += data.size == size ? 0 : 1;
                return this;
              }
              module2.exports = mapCacheSet;
            }
          });

          // node_modules/lodash/_MapCache.js
          var require_MapCache = __commonJS({
            "node_modules/lodash/_MapCache.js"(exports2, module2) {
              var mapCacheClear = require_mapCacheClear();
              var mapCacheDelete = require_mapCacheDelete();
              var mapCacheGet = require_mapCacheGet();
              var mapCacheHas = require_mapCacheHas();
              var mapCacheSet = require_mapCacheSet();
              function MapCache(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              MapCache.prototype.clear = mapCacheClear;
              MapCache.prototype["delete"] = mapCacheDelete;
              MapCache.prototype.get = mapCacheGet;
              MapCache.prototype.has = mapCacheHas;
              MapCache.prototype.set = mapCacheSet;
              module2.exports = MapCache;
            }
          });

          // node_modules/lodash/_setCacheAdd.js
          var require_setCacheAdd = __commonJS({
            "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
              var HASH_UNDEFINED = "__lodash_hash_undefined__";
              function setCacheAdd(value) {
                this.__data__.set(value, HASH_UNDEFINED);
                return this;
              }
              module2.exports = setCacheAdd;
            }
          });

          // node_modules/lodash/_setCacheHas.js
          var require_setCacheHas = __commonJS({
            "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
              function setCacheHas(value) {
                return this.__data__.has(value);
              }
              module2.exports = setCacheHas;
            }
          });

          // node_modules/lodash/_SetCache.js
          var require_SetCache = __commonJS({
            "node_modules/lodash/_SetCache.js"(exports2, module2) {
              var MapCache = require_MapCache();
              var setCacheAdd = require_setCacheAdd();
              var setCacheHas = require_setCacheHas();
              function SetCache(values) {
                var index = -1, length = values == null ? 0 : values.length;
                this.__data__ = new MapCache();
                while (++index < length) {
                  this.add(values[index]);
                }
              }
              SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
              SetCache.prototype.has = setCacheHas;
              module2.exports = SetCache;
            }
          });

          // node_modules/lodash/_baseFindIndex.js
          var require_baseFindIndex = __commonJS({
            "node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
              function baseFindIndex(array, predicate, fromIndex, fromRight) {
                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                while (fromRight ? index-- : ++index < length) {
                  if (predicate(array[index], index, array)) {
                    return index;
                  }
                }
                return -1;
              }
              module2.exports = baseFindIndex;
            }
          });

          // node_modules/lodash/_baseIsNaN.js
          var require_baseIsNaN = __commonJS({
            "node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
              function baseIsNaN(value) {
                return value !== value;
              }
              module2.exports = baseIsNaN;
            }
          });

          // node_modules/lodash/_strictIndexOf.js
          var require_strictIndexOf = __commonJS({
            "node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
              function strictIndexOf(array, value, fromIndex) {
                var index = fromIndex - 1, length = array.length;
                while (++index < length) {
                  if (array[index] === value) {
                    return index;
                  }
                }
                return -1;
              }
              module2.exports = strictIndexOf;
            }
          });

          // node_modules/lodash/_baseIndexOf.js
          var require_baseIndexOf = __commonJS({
            "node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
              var baseFindIndex = require_baseFindIndex();
              var baseIsNaN = require_baseIsNaN();
              var strictIndexOf = require_strictIndexOf();
              function baseIndexOf(array, value, fromIndex) {
                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
              }
              module2.exports = baseIndexOf;
            }
          });

          // node_modules/lodash/_arrayIncludes.js
          var require_arrayIncludes = __commonJS({
            "node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
              var baseIndexOf = require_baseIndexOf();
              function arrayIncludes(array, value) {
                var length = array == null ? 0 : array.length;
                return !!length && baseIndexOf(array, value, 0) > -1;
              }
              module2.exports = arrayIncludes;
            }
          });

          // node_modules/lodash/_arrayIncludesWith.js
          var require_arrayIncludesWith = __commonJS({
            "node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
              function arrayIncludesWith(array, value, comparator) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (comparator(value, array[index])) {
                    return true;
                  }
                }
                return false;
              }
              module2.exports = arrayIncludesWith;
            }
          });

          // node_modules/lodash/_arrayMap.js
          var require_arrayMap = __commonJS({
            "node_modules/lodash/_arrayMap.js"(exports2, module2) {
              function arrayMap(array, iteratee) {
                var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                while (++index < length) {
                  result[index] = iteratee(array[index], index, array);
                }
                return result;
              }
              module2.exports = arrayMap;
            }
          });

          // node_modules/lodash/_baseUnary.js
          var require_baseUnary = __commonJS({
            "node_modules/lodash/_baseUnary.js"(exports2, module2) {
              function baseUnary(func) {
                return function(value) {
                  return func(value);
                };
              }
              module2.exports = baseUnary;
            }
          });

          // node_modules/lodash/_cacheHas.js
          var require_cacheHas = __commonJS({
            "node_modules/lodash/_cacheHas.js"(exports2, module2) {
              function cacheHas(cache, key) {
                return cache.has(key);
              }
              module2.exports = cacheHas;
            }
          });

          // node_modules/lodash/_baseDifference.js
          var require_baseDifference = __commonJS({
            "node_modules/lodash/_baseDifference.js"(exports2, module2) {
              var SetCache = require_SetCache();
              var arrayIncludes = require_arrayIncludes();
              var arrayIncludesWith = require_arrayIncludesWith();
              var arrayMap = require_arrayMap();
              var baseUnary = require_baseUnary();
              var cacheHas = require_cacheHas();
              var LARGE_ARRAY_SIZE = 200;
              function baseDifference(array, values, iteratee, comparator) {
                var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
                if (!length) {
                  return result;
                }
                if (iteratee) {
                  values = arrayMap(values, baseUnary(iteratee));
                }
                if (comparator) {
                  includes = arrayIncludesWith;
                  isCommon = false;
                } else if (values.length >= LARGE_ARRAY_SIZE) {
                  includes = cacheHas;
                  isCommon = false;
                  values = new SetCache(values);
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed = iteratee == null ? value : iteratee(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed === computed) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values[valuesIndex] === computed) {
                          continue outer;
                        }
                      }
                      result.push(value);
                    } else if (!includes(values, computed, comparator)) {
                      result.push(value);
                    }
                  }
                return result;
              }
              module2.exports = baseDifference;
            }
          });

          // node_modules/lodash/_arrayPush.js
          var require_arrayPush = __commonJS({
            "node_modules/lodash/_arrayPush.js"(exports2, module2) {
              function arrayPush(array, values) {
                var index = -1, length = values.length, offset = array.length;
                while (++index < length) {
                  array[offset + index] = values[index];
                }
                return array;
              }
              module2.exports = arrayPush;
            }
          });

          // node_modules/lodash/isObjectLike.js
          var require_isObjectLike = __commonJS({
            "node_modules/lodash/isObjectLike.js"(exports2, module2) {
              function isObjectLike(value) {
                return value != null && typeof value == "object";
              }
              module2.exports = isObjectLike;
            }
          });

          // node_modules/lodash/_baseIsArguments.js
          var require_baseIsArguments = __commonJS({
            "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
              var baseGetTag = require_baseGetTag();
              var isObjectLike = require_isObjectLike();
              var argsTag = "[object Arguments]";
              function baseIsArguments(value) {
                return isObjectLike(value) && baseGetTag(value) == argsTag;
              }
              module2.exports = baseIsArguments;
            }
          });

          // node_modules/lodash/isArguments.js
          var require_isArguments = __commonJS({
            "node_modules/lodash/isArguments.js"(exports2, module2) {
              var baseIsArguments = require_baseIsArguments();
              var isObjectLike = require_isObjectLike();
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              var propertyIsEnumerable = objectProto.propertyIsEnumerable;
              var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                return arguments;
              }()) ? baseIsArguments : function(value) {
                return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
              };
              module2.exports = isArguments;
            }
          });

          // node_modules/lodash/isArray.js
          var require_isArray = __commonJS({
            "node_modules/lodash/isArray.js"(exports2, module2) {
              var isArray = Array.isArray;
              module2.exports = isArray;
            }
          });

          // node_modules/lodash/_isFlattenable.js
          var require_isFlattenable = __commonJS({
            "node_modules/lodash/_isFlattenable.js"(exports2, module2) {
              var Symbol2 = require_Symbol();
              var isArguments = require_isArguments();
              var isArray = require_isArray();
              var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
              function isFlattenable(value) {
                return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              module2.exports = isFlattenable;
            }
          });

          // node_modules/lodash/_baseFlatten.js
          var require_baseFlatten = __commonJS({
            "node_modules/lodash/_baseFlatten.js"(exports2, module2) {
              var arrayPush = require_arrayPush();
              var isFlattenable = require_isFlattenable();
              function baseFlatten(array, depth, predicate, isStrict, result) {
                var index = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result || (result = []);
                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      baseFlatten(value, depth - 1, predicate, isStrict, result);
                    } else {
                      arrayPush(result, value);
                    }
                  } else if (!isStrict) {
                    result[result.length] = value;
                  }
                }
                return result;
              }
              module2.exports = baseFlatten;
            }
          });

          // node_modules/lodash/_stackClear.js
          var require_stackClear = __commonJS({
            "node_modules/lodash/_stackClear.js"(exports2, module2) {
              var ListCache = require_ListCache();
              function stackClear() {
                this.__data__ = new ListCache();
                this.size = 0;
              }
              module2.exports = stackClear;
            }
          });

          // node_modules/lodash/_stackDelete.js
          var require_stackDelete = __commonJS({
            "node_modules/lodash/_stackDelete.js"(exports2, module2) {
              function stackDelete(key) {
                var data = this.__data__, result = data["delete"](key);
                this.size = data.size;
                return result;
              }
              module2.exports = stackDelete;
            }
          });

          // node_modules/lodash/_stackGet.js
          var require_stackGet = __commonJS({
            "node_modules/lodash/_stackGet.js"(exports2, module2) {
              function stackGet(key) {
                return this.__data__.get(key);
              }
              module2.exports = stackGet;
            }
          });

          // node_modules/lodash/_stackHas.js
          var require_stackHas = __commonJS({
            "node_modules/lodash/_stackHas.js"(exports2, module2) {
              function stackHas(key) {
                return this.__data__.has(key);
              }
              module2.exports = stackHas;
            }
          });

          // node_modules/lodash/_stackSet.js
          var require_stackSet = __commonJS({
            "node_modules/lodash/_stackSet.js"(exports2, module2) {
              var ListCache = require_ListCache();
              var Map2 = require_Map();
              var MapCache = require_MapCache();
              var LARGE_ARRAY_SIZE = 200;
              function stackSet(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache) {
                  var pairs = data.__data__;
                  if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              module2.exports = stackSet;
            }
          });

          // node_modules/lodash/_Stack.js
          var require_Stack = __commonJS({
            "node_modules/lodash/_Stack.js"(exports2, module2) {
              var ListCache = require_ListCache();
              var stackClear = require_stackClear();
              var stackDelete = require_stackDelete();
              var stackGet = require_stackGet();
              var stackHas = require_stackHas();
              var stackSet = require_stackSet();
              function Stack(entries) {
                var data = this.__data__ = new ListCache(entries);
                this.size = data.size;
              }
              Stack.prototype.clear = stackClear;
              Stack.prototype["delete"] = stackDelete;
              Stack.prototype.get = stackGet;
              Stack.prototype.has = stackHas;
              Stack.prototype.set = stackSet;
              module2.exports = Stack;
            }
          });

          // node_modules/lodash/_arraySome.js
          var require_arraySome = __commonJS({
            "node_modules/lodash/_arraySome.js"(exports2, module2) {
              function arraySome(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length;
                while (++index < length) {
                  if (predicate(array[index], index, array)) {
                    return true;
                  }
                }
                return false;
              }
              module2.exports = arraySome;
            }
          });

          // node_modules/lodash/_equalArrays.js
          var require_equalArrays = __commonJS({
            "node_modules/lodash/_equalArrays.js"(exports2, module2) {
              var SetCache = require_SetCache();
              var arraySome = require_arraySome();
              var cacheHas = require_cacheHas();
              var COMPARE_PARTIAL_FLAG = 1;
              var COMPARE_UNORDERED_FLAG = 2;
              function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                var arrStacked = stack.get(array);
                var othStacked = stack.get(other);
                if (arrStacked && othStacked) {
                  return arrStacked == other && othStacked == array;
                }
                var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
                stack.set(array, other);
                stack.set(other, array);
                while (++index < arrLength) {
                  var arrValue = array[index], othValue = other[index];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                  }
                  if (compared !== void 0) {
                    if (compared) {
                      continue;
                    }
                    result = false;
                    break;
                  }
                  if (seen) {
                    if (!arraySome(other, function(othValue2, othIndex) {
                      if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                      }
                    })) {
                      result = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    result = false;
                    break;
                  }
                }
                stack["delete"](array);
                stack["delete"](other);
                return result;
              }
              module2.exports = equalArrays;
            }
          });

          // node_modules/lodash/_Uint8Array.js
          var require_Uint8Array = __commonJS({
            "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
              var root = require_root();
              var Uint8Array2 = root.Uint8Array;
              module2.exports = Uint8Array2;
            }
          });

          // node_modules/lodash/_mapToArray.js
          var require_mapToArray = __commonJS({
            "node_modules/lodash/_mapToArray.js"(exports2, module2) {
              function mapToArray(map) {
                var index = -1, result = Array(map.size);
                map.forEach(function(value, key) {
                  result[++index] = [key, value];
                });
                return result;
              }
              module2.exports = mapToArray;
            }
          });

          // node_modules/lodash/_setToArray.js
          var require_setToArray = __commonJS({
            "node_modules/lodash/_setToArray.js"(exports2, module2) {
              function setToArray(set) {
                var index = -1, result = Array(set.size);
                set.forEach(function(value) {
                  result[++index] = value;
                });
                return result;
              }
              module2.exports = setToArray;
            }
          });

          // node_modules/lodash/_equalByTag.js
          var require_equalByTag = __commonJS({
            "node_modules/lodash/_equalByTag.js"(exports2, module2) {
              var Symbol2 = require_Symbol();
              var Uint8Array2 = require_Uint8Array();
              var eq = require_eq();
              var equalArrays = require_equalArrays();
              var mapToArray = require_mapToArray();
              var setToArray = require_setToArray();
              var COMPARE_PARTIAL_FLAG = 1;
              var COMPARE_UNORDERED_FLAG = 2;
              var boolTag = "[object Boolean]";
              var dateTag = "[object Date]";
              var errorTag = "[object Error]";
              var mapTag = "[object Map]";
              var numberTag = "[object Number]";
              var regexpTag = "[object RegExp]";
              var setTag = "[object Set]";
              var stringTag = "[object String]";
              var symbolTag = "[object Symbol]";
              var arrayBufferTag = "[object ArrayBuffer]";
              var dataViewTag = "[object DataView]";
              var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
              var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
              function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                switch (tag) {
                  case dataViewTag:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                      return false;
                    }
                    return true;
                  case boolTag:
                  case dateTag:
                  case numberTag:
                    return eq(+object, +other);
                  case errorTag:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag:
                  case stringTag:
                    return object == other + "";
                  case mapTag:
                    var convert = mapToArray;
                  case setTag:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                    convert || (convert = setToArray);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG;
                    stack.set(object, other);
                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                    stack["delete"](object);
                    return result;
                  case symbolTag:
                    if (symbolValueOf) {
                      return symbolValueOf.call(object) == symbolValueOf.call(other);
                    }
                }
                return false;
              }
              module2.exports = equalByTag;
            }
          });

          // node_modules/lodash/_baseGetAllKeys.js
          var require_baseGetAllKeys = __commonJS({
            "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
              var arrayPush = require_arrayPush();
              var isArray = require_isArray();
              function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                var result = keysFunc(object);
                return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
              }
              module2.exports = baseGetAllKeys;
            }
          });

          // node_modules/lodash/_arrayFilter.js
          var require_arrayFilter = __commonJS({
            "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
              function arrayFilter(array, predicate) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result[resIndex++] = value;
                  }
                }
                return result;
              }
              module2.exports = arrayFilter;
            }
          });

          // node_modules/lodash/stubArray.js
          var require_stubArray = __commonJS({
            "node_modules/lodash/stubArray.js"(exports2, module2) {
              function stubArray() {
                return [];
              }
              module2.exports = stubArray;
            }
          });

          // node_modules/lodash/_getSymbols.js
          var require_getSymbols = __commonJS({
            "node_modules/lodash/_getSymbols.js"(exports2, module2) {
              var arrayFilter = require_arrayFilter();
              var stubArray = require_stubArray();
              var objectProto = Object.prototype;
              var propertyIsEnumerable = objectProto.propertyIsEnumerable;
              var nativeGetSymbols = Object.getOwnPropertySymbols;
              var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                if (object == null) {
                  return [];
                }
                object = Object(object);
                return arrayFilter(nativeGetSymbols(object), function(symbol) {
                  return propertyIsEnumerable.call(object, symbol);
                });
              };
              module2.exports = getSymbols;
            }
          });

          // node_modules/lodash/_baseTimes.js
          var require_baseTimes = __commonJS({
            "node_modules/lodash/_baseTimes.js"(exports2, module2) {
              function baseTimes(n, iteratee) {
                var index = -1, result = Array(n);
                while (++index < n) {
                  result[index] = iteratee(index);
                }
                return result;
              }
              module2.exports = baseTimes;
            }
          });

          // node_modules/lodash/stubFalse.js
          var require_stubFalse = __commonJS({
            "node_modules/lodash/stubFalse.js"(exports2, module2) {
              function stubFalse() {
                return false;
              }
              module2.exports = stubFalse;
            }
          });

          // node_modules/lodash/isBuffer.js
          var require_isBuffer = __commonJS({
            "node_modules/lodash/isBuffer.js"(exports2, module2) {
              var root = require_root();
              var stubFalse = require_stubFalse();
              var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
              var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var Buffer2 = moduleExports ? root.Buffer : void 0;
              var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
              var isBuffer = nativeIsBuffer || stubFalse;
              module2.exports = isBuffer;
            }
          });

          // node_modules/lodash/_isIndex.js
          var require_isIndex = __commonJS({
            "node_modules/lodash/_isIndex.js"(exports2, module2) {
              var MAX_SAFE_INTEGER = 9007199254740991;
              var reIsUint = /^(?:0|[1-9]\d*)$/;
              function isIndex(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              module2.exports = isIndex;
            }
          });

          // node_modules/lodash/isLength.js
          var require_isLength = __commonJS({
            "node_modules/lodash/isLength.js"(exports2, module2) {
              var MAX_SAFE_INTEGER = 9007199254740991;
              function isLength(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
              }
              module2.exports = isLength;
            }
          });

          // node_modules/lodash/_baseIsTypedArray.js
          var require_baseIsTypedArray = __commonJS({
            "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
              var baseGetTag = require_baseGetTag();
              var isLength = require_isLength();
              var isObjectLike = require_isObjectLike();
              var argsTag = "[object Arguments]";
              var arrayTag = "[object Array]";
              var boolTag = "[object Boolean]";
              var dateTag = "[object Date]";
              var errorTag = "[object Error]";
              var funcTag = "[object Function]";
              var mapTag = "[object Map]";
              var numberTag = "[object Number]";
              var objectTag = "[object Object]";
              var regexpTag = "[object RegExp]";
              var setTag = "[object Set]";
              var stringTag = "[object String]";
              var weakMapTag = "[object WeakMap]";
              var arrayBufferTag = "[object ArrayBuffer]";
              var dataViewTag = "[object DataView]";
              var float32Tag = "[object Float32Array]";
              var float64Tag = "[object Float64Array]";
              var int8Tag = "[object Int8Array]";
              var int16Tag = "[object Int16Array]";
              var int32Tag = "[object Int32Array]";
              var uint8Tag = "[object Uint8Array]";
              var uint8ClampedTag = "[object Uint8ClampedArray]";
              var uint16Tag = "[object Uint16Array]";
              var uint32Tag = "[object Uint32Array]";
              var typedArrayTags = {};
              typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
              typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
              function baseIsTypedArray(value) {
                return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
              }
              module2.exports = baseIsTypedArray;
            }
          });

          // node_modules/lodash/_nodeUtil.js
          var require_nodeUtil = __commonJS({
            "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
              var freeGlobal = require_freeGlobal();
              var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
              var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
              var moduleExports = freeModule && freeModule.exports === freeExports;
              var freeProcess = moduleExports && freeGlobal.process;
              var nodeUtil = function() {
                try {
                  var types = freeModule && freeModule.require && freeModule.require("util").types;
                  if (types) {
                    return types;
                  }
                  return freeProcess && freeProcess.binding && freeProcess.binding("util");
                } catch (e) {
                }
              }();
              module2.exports = nodeUtil;
            }
          });

          // node_modules/lodash/isTypedArray.js
          var require_isTypedArray = __commonJS({
            "node_modules/lodash/isTypedArray.js"(exports2, module2) {
              var baseIsTypedArray = require_baseIsTypedArray();
              var baseUnary = require_baseUnary();
              var nodeUtil = require_nodeUtil();
              var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
              var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
              module2.exports = isTypedArray;
            }
          });

          // node_modules/lodash/_arrayLikeKeys.js
          var require_arrayLikeKeys = __commonJS({
            "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
              var baseTimes = require_baseTimes();
              var isArguments = require_isArguments();
              var isArray = require_isArray();
              var isBuffer = require_isBuffer();
              var isIndex = require_isIndex();
              var isTypedArray = require_isTypedArray();
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function arrayLikeKeys(value, inherited) {
                var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                  (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                  isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                  isIndex(key, length)))) {
                    result.push(key);
                  }
                }
                return result;
              }
              module2.exports = arrayLikeKeys;
            }
          });

          // node_modules/lodash/_isPrototype.js
          var require_isPrototype = __commonJS({
            "node_modules/lodash/_isPrototype.js"(exports2, module2) {
              var objectProto = Object.prototype;
              function isPrototype(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                return value === proto;
              }
              module2.exports = isPrototype;
            }
          });

          // node_modules/lodash/_overArg.js
          var require_overArg = __commonJS({
            "node_modules/lodash/_overArg.js"(exports2, module2) {
              function overArg(func, transform) {
                return function(arg) {
                  return func(transform(arg));
                };
              }
              module2.exports = overArg;
            }
          });

          // node_modules/lodash/_nativeKeys.js
          var require_nativeKeys = __commonJS({
            "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
              var overArg = require_overArg();
              var nativeKeys = overArg(Object.keys, Object);
              module2.exports = nativeKeys;
            }
          });

          // node_modules/lodash/_baseKeys.js
          var require_baseKeys = __commonJS({
            "node_modules/lodash/_baseKeys.js"(exports2, module2) {
              var isPrototype = require_isPrototype();
              var nativeKeys = require_nativeKeys();
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function baseKeys(object) {
                if (!isPrototype(object)) {
                  return nativeKeys(object);
                }
                var result = [];
                for (var key in Object(object)) {
                  if (hasOwnProperty.call(object, key) && key != "constructor") {
                    result.push(key);
                  }
                }
                return result;
              }
              module2.exports = baseKeys;
            }
          });

          // node_modules/lodash/isArrayLike.js
          var require_isArrayLike = __commonJS({
            "node_modules/lodash/isArrayLike.js"(exports2, module2) {
              var isFunction = require_isFunction();
              var isLength = require_isLength();
              function isArrayLike(value) {
                return value != null && isLength(value.length) && !isFunction(value);
              }
              module2.exports = isArrayLike;
            }
          });

          // node_modules/lodash/keys.js
          var require_keys = __commonJS({
            "node_modules/lodash/keys.js"(exports2, module2) {
              var arrayLikeKeys = require_arrayLikeKeys();
              var baseKeys = require_baseKeys();
              var isArrayLike = require_isArrayLike();
              function keys(object) {
                return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
              }
              module2.exports = keys;
            }
          });

          // node_modules/lodash/_getAllKeys.js
          var require_getAllKeys = __commonJS({
            "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
              var baseGetAllKeys = require_baseGetAllKeys();
              var getSymbols = require_getSymbols();
              var keys = require_keys();
              function getAllKeys(object) {
                return baseGetAllKeys(object, keys, getSymbols);
              }
              module2.exports = getAllKeys;
            }
          });

          // node_modules/lodash/_equalObjects.js
          var require_equalObjects = __commonJS({
            "node_modules/lodash/_equalObjects.js"(exports2, module2) {
              var getAllKeys = require_getAllKeys();
              var COMPARE_PARTIAL_FLAG = 1;
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                    return false;
                  }
                }
                var objStacked = stack.get(object);
                var othStacked = stack.get(other);
                if (objStacked && othStacked) {
                  return objStacked == other && othStacked == object;
                }
                var result = true;
                stack.set(object, other);
                stack.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                  }
                  if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                    result = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result = false;
                  }
                }
                stack["delete"](object);
                stack["delete"](other);
                return result;
              }
              module2.exports = equalObjects;
            }
          });

          // node_modules/lodash/_DataView.js
          var require_DataView = __commonJS({
            "node_modules/lodash/_DataView.js"(exports2, module2) {
              var getNative = require_getNative();
              var root = require_root();
              var DataView = getNative(root, "DataView");
              module2.exports = DataView;
            }
          });

          // node_modules/lodash/_Promise.js
          var require_Promise = __commonJS({
            "node_modules/lodash/_Promise.js"(exports2, module2) {
              var getNative = require_getNative();
              var root = require_root();
              var Promise2 = getNative(root, "Promise");
              module2.exports = Promise2;
            }
          });

          // node_modules/lodash/_Set.js
          var require_Set = __commonJS({
            "node_modules/lodash/_Set.js"(exports2, module2) {
              var getNative = require_getNative();
              var root = require_root();
              var Set2 = getNative(root, "Set");
              module2.exports = Set2;
            }
          });

          // node_modules/lodash/_WeakMap.js
          var require_WeakMap = __commonJS({
            "node_modules/lodash/_WeakMap.js"(exports2, module2) {
              var getNative = require_getNative();
              var root = require_root();
              var WeakMap = getNative(root, "WeakMap");
              module2.exports = WeakMap;
            }
          });

          // node_modules/lodash/_getTag.js
          var require_getTag = __commonJS({
            "node_modules/lodash/_getTag.js"(exports2, module2) {
              var DataView = require_DataView();
              var Map2 = require_Map();
              var Promise2 = require_Promise();
              var Set2 = require_Set();
              var WeakMap = require_WeakMap();
              var baseGetTag = require_baseGetTag();
              var toSource = require_toSource();
              var mapTag = "[object Map]";
              var objectTag = "[object Object]";
              var promiseTag = "[object Promise]";
              var setTag = "[object Set]";
              var weakMapTag = "[object WeakMap]";
              var dataViewTag = "[object DataView]";
              var dataViewCtorString = toSource(DataView);
              var mapCtorString = toSource(Map2);
              var promiseCtorString = toSource(Promise2);
              var setCtorString = toSource(Set2);
              var weakMapCtorString = toSource(WeakMap);
              var getTag = baseGetTag;
              if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
                getTag = function(value) {
                  var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString:
                        return dataViewTag;
                      case mapCtorString:
                        return mapTag;
                      case promiseCtorString:
                        return promiseTag;
                      case setCtorString:
                        return setTag;
                      case weakMapCtorString:
                        return weakMapTag;
                    }
                  }
                  return result;
                };
              }
              module2.exports = getTag;
            }
          });

          // node_modules/lodash/_baseIsEqualDeep.js
          var require_baseIsEqualDeep = __commonJS({
            "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
              var Stack = require_Stack();
              var equalArrays = require_equalArrays();
              var equalByTag = require_equalByTag();
              var equalObjects = require_equalObjects();
              var getTag = require_getTag();
              var isArray = require_isArray();
              var isBuffer = require_isBuffer();
              var isTypedArray = require_isTypedArray();
              var COMPARE_PARTIAL_FLAG = 1;
              var argsTag = "[object Arguments]";
              var arrayTag = "[object Array]";
              var objectTag = "[object Object]";
              var objectProto = Object.prototype;
              var hasOwnProperty = objectProto.hasOwnProperty;
              function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                objTag = objTag == argsTag ? objectTag : objTag;
                othTag = othTag == argsTag ? objectTag : othTag;
                var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer(object)) {
                  if (!isBuffer(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack || (stack = new Stack());
                  return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                  var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack || (stack = new Stack());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack || (stack = new Stack());
                return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
              }
              module2.exports = baseIsEqualDeep;
            }
          });

          // node_modules/lodash/_baseIsEqual.js
          var require_baseIsEqual = __commonJS({
            "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
              var baseIsEqualDeep = require_baseIsEqualDeep();
              var isObjectLike = require_isObjectLike();
              function baseIsEqual(value, other, bitmask, customizer, stack) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
              }
              module2.exports = baseIsEqual;
            }
          });

          // node_modules/lodash/_baseIsMatch.js
          var require_baseIsMatch = __commonJS({
            "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
              var Stack = require_Stack();
              var baseIsEqual = require_baseIsEqual();
              var COMPARE_PARTIAL_FLAG = 1;
              var COMPARE_UNORDERED_FLAG = 2;
              function baseIsMatch(object, source, matchData, customizer) {
                var index = matchData.length, length = index, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object(object);
                while (index--) {
                  var data = matchData[index];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === void 0 && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack = new Stack();
                    if (customizer) {
                      var result = customizer(objValue, srcValue, key, object, source, stack);
                    }
                    if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              module2.exports = baseIsMatch;
            }
          });

          // node_modules/lodash/_isStrictComparable.js
          var require_isStrictComparable = __commonJS({
            "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
              var isObject = require_isObject();
              function isStrictComparable(value) {
                return value === value && !isObject(value);
              }
              module2.exports = isStrictComparable;
            }
          });

          // node_modules/lodash/_getMatchData.js
          var require_getMatchData = __commonJS({
            "node_modules/lodash/_getMatchData.js"(exports2, module2) {
              var isStrictComparable = require_isStrictComparable();
              var keys = require_keys();
              function getMatchData(object) {
                var result = keys(object), length = result.length;
                while (length--) {
                  var key = result[length], value = object[key];
                  result[length] = [key, value, isStrictComparable(value)];
                }
                return result;
              }
              module2.exports = getMatchData;
            }
          });

          // node_modules/lodash/_matchesStrictComparable.js
          var require_matchesStrictComparable = __commonJS({
            "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
              function matchesStrictComparable(key, srcValue) {
                return function(object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
                };
              }
              module2.exports = matchesStrictComparable;
            }
          });

          // node_modules/lodash/_baseMatches.js
          var require_baseMatches = __commonJS({
            "node_modules/lodash/_baseMatches.js"(exports2, module2) {
              var baseIsMatch = require_baseIsMatch();
              var getMatchData = require_getMatchData();
              var matchesStrictComparable = require_matchesStrictComparable();
              function baseMatches(source) {
                var matchData = getMatchData(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                }
                return function(object) {
                  return object === source || baseIsMatch(object, source, matchData);
                };
              }
              module2.exports = baseMatches;
            }
          });

          // node_modules/lodash/isSymbol.js
          var require_isSymbol = __commonJS({
            "node_modules/lodash/isSymbol.js"(exports2, module2) {
              var baseGetTag = require_baseGetTag();
              var isObjectLike = require_isObjectLike();
              var symbolTag = "[object Symbol]";
              function isSymbol(value) {
                return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
              }
              module2.exports = isSymbol;
            }
          });

          // node_modules/lodash/_isKey.js
          var require_isKey = __commonJS({
            "node_modules/lodash/_isKey.js"(exports2, module2) {
              var isArray = require_isArray();
              var isSymbol = require_isSymbol();
              var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
              var reIsPlainProp = /^\w*$/;
              function isKey(value, object) {
                if (isArray(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                  return true;
                }
                return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
              }
              module2.exports = isKey;
            }
          });

          // node_modules/lodash/memoize.js
          var require_memoize = __commonJS({
            "node_modules/lodash/memoize.js"(exports2, module2) {
              var MapCache = require_MapCache();
              var FUNC_ERROR_TEXT = "Expected a function";
              function memoize(func, resolver) {
                if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                var memoized = function() {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                  if (cache.has(key)) {
                    return cache.get(key);
                  }
                  var result = func.apply(this, args);
                  memoized.cache = cache.set(key, result) || cache;
                  return result;
                };
                memoized.cache = new (memoize.Cache || MapCache)();
                return memoized;
              }
              memoize.Cache = MapCache;
              module2.exports = memoize;
            }
          });

          // node_modules/lodash/_memoizeCapped.js
          var require_memoizeCapped = __commonJS({
            "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
              var memoize = require_memoize();
              var MAX_MEMOIZE_SIZE = 500;
              function memoizeCapped(func) {
                var result = memoize(func, function(key) {
                  if (cache.size === MAX_MEMOIZE_SIZE) {
                    cache.clear();
                  }
                  return key;
                });
                var cache = result.cache;
                return result;
              }
              module2.exports = memoizeCapped;
            }
          });

          // node_modules/lodash/_stringToPath.js
          var require_stringToPath = __commonJS({
            "node_modules/lodash/_stringToPath.js"(exports2, module2) {
              var memoizeCapped = require_memoizeCapped();
              var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
              var reEscapeChar = /\\(\\)?/g;
              var stringToPath = memoizeCapped(function(string) {
                var result = [];
                if (string.charCodeAt(0) === 46) {
                  result.push("");
                }
                string.replace(rePropName, function(match, number, quote, subString) {
                  result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                });
                return result;
              });
              module2.exports = stringToPath;
            }
          });

          // node_modules/lodash/_baseToString.js
          var require_baseToString = __commonJS({
            "node_modules/lodash/_baseToString.js"(exports2, module2) {
              var Symbol2 = require_Symbol();
              var arrayMap = require_arrayMap();
              var isArray = require_isArray();
              var isSymbol = require_isSymbol();
              var INFINITY = 1 / 0;
              var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
              var symbolToString = symbolProto ? symbolProto.toString : void 0;
              function baseToString(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray(value)) {
                  return arrayMap(value, baseToString) + "";
                }
                if (isSymbol(value)) {
                  return symbolToString ? symbolToString.call(value) : "";
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              module2.exports = baseToString;
            }
          });

          // node_modules/lodash/toString.js
          var require_toString = __commonJS({
            "node_modules/lodash/toString.js"(exports2, module2) {
              var baseToString = require_baseToString();
              function toString(value) {
                return value == null ? "" : baseToString(value);
              }
              module2.exports = toString;
            }
          });

          // node_modules/lodash/_castPath.js
          var require_castPath = __commonJS({
            "node_modules/lodash/_castPath.js"(exports2, module2) {
              var isArray = require_isArray();
              var isKey = require_isKey();
              var stringToPath = require_stringToPath();
              var toString = require_toString();
              function castPath(value, object) {
                if (isArray(value)) {
                  return value;
                }
                return isKey(value, object) ? [value] : stringToPath(toString(value));
              }
              module2.exports = castPath;
            }
          });

          // node_modules/lodash/_toKey.js
          var require_toKey = __commonJS({
            "node_modules/lodash/_toKey.js"(exports2, module2) {
              var isSymbol = require_isSymbol();
              var INFINITY = 1 / 0;
              function toKey(value) {
                if (typeof value == "string" || isSymbol(value)) {
                  return value;
                }
                var result = value + "";
                return result == "0" && 1 / value == -INFINITY ? "-0" : result;
              }
              module2.exports = toKey;
            }
          });

          // node_modules/lodash/_baseGet.js
          var require_baseGet = __commonJS({
            "node_modules/lodash/_baseGet.js"(exports2, module2) {
              var castPath = require_castPath();
              var toKey = require_toKey();
              function baseGet(object, path) {
                path = castPath(path, object);
                var index = 0, length = path.length;
                while (object != null && index < length) {
                  object = object[toKey(path[index++])];
                }
                return index && index == length ? object : void 0;
              }
              module2.exports = baseGet;
            }
          });

          // node_modules/lodash/get.js
          var require_get = __commonJS({
            "node_modules/lodash/get.js"(exports2, module2) {
              var baseGet = require_baseGet();
              function get(object, path, defaultValue) {
                var result = object == null ? void 0 : baseGet(object, path);
                return result === void 0 ? defaultValue : result;
              }
              module2.exports = get;
            }
          });

          // node_modules/lodash/_baseHasIn.js
          var require_baseHasIn = __commonJS({
            "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
              function baseHasIn(object, key) {
                return object != null && key in Object(object);
              }
              module2.exports = baseHasIn;
            }
          });

          // node_modules/lodash/_hasPath.js
          var require_hasPath = __commonJS({
            "node_modules/lodash/_hasPath.js"(exports2, module2) {
              var castPath = require_castPath();
              var isArguments = require_isArguments();
              var isArray = require_isArray();
              var isIndex = require_isIndex();
              var isLength = require_isLength();
              var toKey = require_toKey();
              function hasPath(object, path, hasFunc) {
                path = castPath(path, object);
                var index = -1, length = path.length, result = false;
                while (++index < length) {
                  var key = toKey(path[index]);
                  if (!(result = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result || ++index != length) {
                  return result;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
              }
              module2.exports = hasPath;
            }
          });

          // node_modules/lodash/hasIn.js
          var require_hasIn = __commonJS({
            "node_modules/lodash/hasIn.js"(exports2, module2) {
              var baseHasIn = require_baseHasIn();
              var hasPath = require_hasPath();
              function hasIn(object, path) {
                return object != null && hasPath(object, path, baseHasIn);
              }
              module2.exports = hasIn;
            }
          });

          // node_modules/lodash/_baseMatchesProperty.js
          var require_baseMatchesProperty = __commonJS({
            "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
              var baseIsEqual = require_baseIsEqual();
              var get = require_get();
              var hasIn = require_hasIn();
              var isKey = require_isKey();
              var isStrictComparable = require_isStrictComparable();
              var matchesStrictComparable = require_matchesStrictComparable();
              var toKey = require_toKey();
              var COMPARE_PARTIAL_FLAG = 1;
              var COMPARE_UNORDERED_FLAG = 2;
              function baseMatchesProperty(path, srcValue) {
                if (isKey(path) && isStrictComparable(srcValue)) {
                  return matchesStrictComparable(toKey(path), srcValue);
                }
                return function(object) {
                  var objValue = get(object, path);
                  return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                };
              }
              module2.exports = baseMatchesProperty;
            }
          });

          // node_modules/lodash/identity.js
          var require_identity = __commonJS({
            "node_modules/lodash/identity.js"(exports2, module2) {
              function identity(value) {
                return value;
              }
              module2.exports = identity;
            }
          });

          // node_modules/lodash/_baseProperty.js
          var require_baseProperty = __commonJS({
            "node_modules/lodash/_baseProperty.js"(exports2, module2) {
              function baseProperty(key) {
                return function(object) {
                  return object == null ? void 0 : object[key];
                };
              }
              module2.exports = baseProperty;
            }
          });

          // node_modules/lodash/_basePropertyDeep.js
          var require_basePropertyDeep = __commonJS({
            "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
              var baseGet = require_baseGet();
              function basePropertyDeep(path) {
                return function(object) {
                  return baseGet(object, path);
                };
              }
              module2.exports = basePropertyDeep;
            }
          });

          // node_modules/lodash/property.js
          var require_property = __commonJS({
            "node_modules/lodash/property.js"(exports2, module2) {
              var baseProperty = require_baseProperty();
              var basePropertyDeep = require_basePropertyDeep();
              var isKey = require_isKey();
              var toKey = require_toKey();
              function property(path) {
                return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
              }
              module2.exports = property;
            }
          });

          // node_modules/lodash/_baseIteratee.js
          var require_baseIteratee = __commonJS({
            "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
              var baseMatches = require_baseMatches();
              var baseMatchesProperty = require_baseMatchesProperty();
              var identity = require_identity();
              var isArray = require_isArray();
              var property = require_property();
              function baseIteratee(value) {
                if (typeof value == "function") {
                  return value;
                }
                if (value == null) {
                  return identity;
                }
                if (typeof value == "object") {
                  return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                }
                return property(value);
              }
              module2.exports = baseIteratee;
            }
          });

          // node_modules/lodash/_apply.js
          var require_apply = __commonJS({
            "node_modules/lodash/_apply.js"(exports2, module2) {
              function apply(func, thisArg, args) {
                switch (args.length) {
                  case 0:
                    return func.call(thisArg);
                  case 1:
                    return func.call(thisArg, args[0]);
                  case 2:
                    return func.call(thisArg, args[0], args[1]);
                  case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
                }
                return func.apply(thisArg, args);
              }
              module2.exports = apply;
            }
          });

          // node_modules/lodash/_overRest.js
          var require_overRest = __commonJS({
            "node_modules/lodash/_overRest.js"(exports2, module2) {
              var apply = require_apply();
              var nativeMax = Math.max;
              function overRest(func, start, transform) {
                start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
                return function() {
                  var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform(array);
                  return apply(func, this, otherArgs);
                };
              }
              module2.exports = overRest;
            }
          });

          // node_modules/lodash/constant.js
          var require_constant = __commonJS({
            "node_modules/lodash/constant.js"(exports2, module2) {
              function constant(value) {
                return function() {
                  return value;
                };
              }
              module2.exports = constant;
            }
          });

          // node_modules/lodash/_defineProperty.js
          var require_defineProperty = __commonJS({
            "node_modules/lodash/_defineProperty.js"(exports2, module2) {
              var getNative = require_getNative();
              var defineProperty = function() {
                try {
                  var func = getNative(Object, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {
                }
              }();
              module2.exports = defineProperty;
            }
          });

          // node_modules/lodash/_baseSetToString.js
          var require_baseSetToString = __commonJS({
            "node_modules/lodash/_baseSetToString.js"(exports2, module2) {
              var constant = require_constant();
              var defineProperty = require_defineProperty();
              var identity = require_identity();
              var baseSetToString = !defineProperty ? identity : function(func, string) {
                return defineProperty(func, "toString", {
                  "configurable": true,
                  "enumerable": false,
                  "value": constant(string),
                  "writable": true
                });
              };
              module2.exports = baseSetToString;
            }
          });

          // node_modules/lodash/_shortOut.js
          var require_shortOut = __commonJS({
            "node_modules/lodash/_shortOut.js"(exports2, module2) {
              var HOT_COUNT = 800;
              var HOT_SPAN = 16;
              var nativeNow = Date.now;
              function shortOut(func) {
                var count = 0, lastCalled = 0;
                return function() {
                  var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(void 0, arguments);
                };
              }
              module2.exports = shortOut;
            }
          });

          // node_modules/lodash/_setToString.js
          var require_setToString = __commonJS({
            "node_modules/lodash/_setToString.js"(exports2, module2) {
              var baseSetToString = require_baseSetToString();
              var shortOut = require_shortOut();
              var setToString = shortOut(baseSetToString);
              module2.exports = setToString;
            }
          });

          // node_modules/lodash/_baseRest.js
          var require_baseRest = __commonJS({
            "node_modules/lodash/_baseRest.js"(exports2, module2) {
              var identity = require_identity();
              var overRest = require_overRest();
              var setToString = require_setToString();
              function baseRest(func, start) {
                return setToString(overRest(func, start, identity), func + "");
              }
              module2.exports = baseRest;
            }
          });

          // node_modules/lodash/isArrayLikeObject.js
          var require_isArrayLikeObject = __commonJS({
            "node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
              var isArrayLike = require_isArrayLike();
              var isObjectLike = require_isObjectLike();
              function isArrayLikeObject(value) {
                return isObjectLike(value) && isArrayLike(value);
              }
              module2.exports = isArrayLikeObject;
            }
          });

          // node_modules/lodash/last.js
          var require_last = __commonJS({
            "node_modules/lodash/last.js"(exports2, module2) {
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : void 0;
              }
              module2.exports = last;
            }
          });

          // node_modules/lodash/differenceBy.js
          var require_differenceBy = __commonJS({
            "node_modules/lodash/differenceBy.js"(exports2, module2) {
              var baseDifference = require_baseDifference();
              var baseFlatten = require_baseFlatten();
              var baseIteratee = require_baseIteratee();
              var baseRest = require_baseRest();
              var isArrayLikeObject = require_isArrayLikeObject();
              var last = require_last();
              var differenceBy4 = baseRest(function(array, values) {
                var iteratee = last(values);
                if (isArrayLikeObject(iteratee)) {
                  iteratee = void 0;
                }
                return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee, 2)) : [];
              });
              module2.exports = differenceBy4;
            }
          });

          // node_modules/lodash/_baseSlice.js
          var require_baseSlice = __commonJS({
            "node_modules/lodash/_baseSlice.js"(exports2, module2) {
              function baseSlice(array, start, end) {
                var index = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result = Array(length);
                while (++index < length) {
                  result[index] = array[index + start];
                }
                return result;
              }
              module2.exports = baseSlice;
            }
          });

          // node_modules/lodash/_isIterateeCall.js
          var require_isIterateeCall = __commonJS({
            "node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
              var eq = require_eq();
              var isArrayLike = require_isArrayLike();
              var isIndex = require_isIndex();
              var isObject = require_isObject();
              function isIterateeCall(value, index, object) {
                if (!isObject(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                  return eq(object[index], value);
                }
                return false;
              }
              module2.exports = isIterateeCall;
            }
          });

          // node_modules/lodash/_trimmedEndIndex.js
          var require_trimmedEndIndex = __commonJS({
            "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
              var reWhitespace = /\s/;
              function trimmedEndIndex(string) {
                var index = string.length;
                while (index-- && reWhitespace.test(string.charAt(index))) {
                }
                return index;
              }
              module2.exports = trimmedEndIndex;
            }
          });

          // node_modules/lodash/_baseTrim.js
          var require_baseTrim = __commonJS({
            "node_modules/lodash/_baseTrim.js"(exports2, module2) {
              var trimmedEndIndex = require_trimmedEndIndex();
              var reTrimStart = /^\s+/;
              function baseTrim(string) {
                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
              }
              module2.exports = baseTrim;
            }
          });

          // node_modules/lodash/toNumber.js
          var require_toNumber = __commonJS({
            "node_modules/lodash/toNumber.js"(exports2, module2) {
              var baseTrim = require_baseTrim();
              var isObject = require_isObject();
              var isSymbol = require_isSymbol();
              var NAN = 0 / 0;
              var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
              var reIsBinary = /^0b[01]+$/i;
              var reIsOctal = /^0o[0-7]+$/i;
              var freeParseInt = parseInt;
              function toNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol(value)) {
                  return NAN;
                }
                if (isObject(value)) {
                  var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                  value = isObject(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = baseTrim(value);
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
              }
              module2.exports = toNumber;
            }
          });

          // node_modules/lodash/toFinite.js
          var require_toFinite = __commonJS({
            "node_modules/lodash/toFinite.js"(exports2, module2) {
              var toNumber = require_toNumber();
              var INFINITY = 1 / 0;
              var MAX_INTEGER = 17976931348623157e292;
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              module2.exports = toFinite;
            }
          });

          // node_modules/lodash/toInteger.js
          var require_toInteger = __commonJS({
            "node_modules/lodash/toInteger.js"(exports2, module2) {
              var toFinite = require_toFinite();
              function toInteger(value) {
                var result = toFinite(value), remainder = result % 1;
                return result === result ? remainder ? result - remainder : result : 0;
              }
              module2.exports = toInteger;
            }
          });

          // node_modules/lodash/chunk.js
          var require_chunk = __commonJS({
            "node_modules/lodash/chunk.js"(exports2, module2) {
              var baseSlice = require_baseSlice();
              var isIterateeCall = require_isIterateeCall();
              var toInteger = require_toInteger();
              var nativeCeil = Math.ceil;
              var nativeMax = Math.max;
              function chunk2(array, size, guard) {
                if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
                  size = 1;
                } else {
                  size = nativeMax(toInteger(size), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size < 1) {
                  return [];
                }
                var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
                while (index < length) {
                  result[resIndex++] = baseSlice(array, index, index += size);
                }
                return result;
              }
              module2.exports = chunk2;
            }
          });

          // src/lambda/code/taskWorker.ts
          var taskWorker_exports = {};
          __export(taskWorker_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(taskWorker_exports);

          // src/lambda/code/discovery/scheduledAmiDiscoveryTask.ts
          var import_client_dynamodb3 = require("@aws-sdk/client-dynamodb");
          var import_client_ec22 = require("@aws-sdk/client-ec2");
          var import_client_kms2 = require("@aws-sdk/client-kms");
          var import_client_sfn2 = require("@aws-sdk/client-sfn");

          // src/lambda/code/appConfig.ts
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_util_dynamodb = require("@aws-sdk/util-dynamodb");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/appConfig.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var AppConfig = class {
            opts;
            client;
            constructor({
              region,
              tableName,
              configId,
              isArray,
              lookupKey,
              lookupKeyIndex
            }) {
              this.opts = { tableName, configId, isArray, lookupKey, lookupKeyIndex };
              Object.freeze(this.opts);
              this.client = new import_client_dynamodb.DynamoDBClient({ region });
            }
            serialize(value) {
              return JSON.stringify({ __v: value });
            }
            deserialize(value) {
              return JSON.parse(value).__v;
            }
            async listCfg(args) {
              return this.getCfg(args);
            }
            async getCfg({
              nextMarker,
              maxItems = 100
            }) {
              const { Items, LastEvaluatedKey } = await this.query({
                keyExpression: this.opts.isArray || nextMarker ? this.getKeyExpression({ configId: this.opts.configId }) : this.getKeyExpression({ configId: this.opts.configId, idx: 0 }),
                nextMarker,
                maxItems
              });
              const result = Items.map((u) => this.deserialize(u.value));
              return {
                data: result.length > 1 || this.opts.isArray ? result : result[0],
                nextMarker: LastEvaluatedKey || false
              };
            }
            getKeyExpression(obj) {
              return {
                KeyConditionExpression: Object.keys(obj).map((j) => `${j} = :${j}`).join(" and "),
                ExpressionAttributeValues: (0, import_util_dynamodb.marshall)(
                  Object.fromEntries(Object.entries(obj).map(([k, v]) => [`:${k}`, v]))
                )
              };
            }
            async query({
              keyExpression,
              nextMarker,
              maxItems,
              ascOrder = true,
              indexName
            }) {
              const params = {
                TableName: this.opts.tableName,
                ...keyExpression,
                Limit: maxItems,
                ExclusiveStartKey: nextMarker ? (0, import_util_dynamodb.marshall)(nextMarker) : void 0,
                ConsistentRead: true,
                ScanIndexForward: ascOrder,
                IndexName: indexName
              };
              const command = new import_client_dynamodb.QueryCommand(params);
              const { Items, LastEvaluatedKey } = await this.client.send(command);
              return {
                Items: Items.map((item) => (0, import_util_dynamodb.unmarshall)(item)),
                LastEvaluatedKey: LastEvaluatedKey ? (0, import_util_dynamodb.unmarshall)(LastEvaluatedKey) : null
              };
            }
            async putCfg({ value }) {
              await this.appendCfg({ value, startFromZero: true });
              await this.destroyCfg({
                nextMarker: {
                  idx: Array.isArray(value) && value.length > 0 ? value.length - 1 : 0,
                  configId: this.opts.configId
                }
              });
            }
            async appendCfg({
              value,
              startFromZero = false
            }) {
              if (!Array.isArray(value)) value = [value];
              let startIndex = 0;
              if (!startFromZero) {
                const result = await this.query({
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId }),
                  maxItems: 1,
                  ascOrder: false
                });
                startIndex = result.Items.length > 0 ? result.Items[0].idx + 1 : 0;
              }
              const batchSize = 25;
              for (let i = 0; i < value.length; i += batchSize) {
                const batch = value.slice(i, i + batchSize);
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: batch.map((e, j) => ({
                      PutRequest: {
                        Item: (0, import_util_dynamodb.marshall)({
                          configId: this.opts.configId,
                          idx: i + j + startIndex,
                          value: this.serialize(e),
                          ...this.opts.lookupKey && e[this.opts.lookupKey] && {
                            uid: e[this.opts.lookupKey].toString()
                          }
                        })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              }
            }
            async destroyCfg({
              nextMarker
            }) {
              do {
                const { Items, LastEvaluatedKey } = await this.query({
                  nextMarker,
                  maxItems: 25,
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId })
                });
                nextMarker = LastEvaluatedKey;
                if (!Items.length) break;
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: Items.map((e) => ({
                      DeleteRequest: {
                        Key: (0, import_util_dynamodb.marshall)({ configId: e.configId, idx: e.idx })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              } while (nextMarker);
            }
            async findCfg({ lookupValue }) {
              const { Items } = await this.query({
                keyExpression: this.getKeyExpression({
                  configId: this.opts.configId,
                  uid: lookupValue
                }),
                maxItems: 1,
                indexName: this.opts.lookupKeyIndex
              });
              const data = Items.map((u) => this.deserialize(u.value));
              return { data: data.length ? data[0] : void 0 };
            }
          };
          async function configActionHandler(event) {
            const {
              region = process.env.AWS_REGION || "us-east-1",
              configName,
              action,
              value,
              maxItems,
              nextMarker,
              lookupKey,
              lookupValue,
              lookupKeyIndex = process.env.LookupIndex || "byConfigValue"
            } = event;
            if (!["put", "get", "append", "destroy", "list", "find"].includes(action)) {
              throw new Error("Invalid value for field `action`");
            }
            const isArray = Array.isArray(value) || ["append", "list", "destroy"].includes(action);
            const tableName = process.env.QualysAppConfigTable || APP_CONFIG_TABLE;
            const cfg = new AppConfig({
              region,
              tableName,
              configId: configName,
              isArray,
              lookupKey,
              lookupKeyIndex
            });
            return cfg[`${action}Cfg`]({ nextMarker, value, lookupValue, maxItems });
          }

          // src/lambda/code/lib/awsUtils.ts
          var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
          var import_client_sts = require("@aws-sdk/client-sts");
          async function loadCredentials(config2, roleArn) {
            const IamRoleSessionName = process.env.IamRoleSessionName || IAM_ROLE_SESSION_NAME;
            const stsClient = new import_client_sts.STSClient(config2);
            const { Credentials } = await stsClient.send(
              new import_client_sts.AssumeRoleCommand({
                RoleArn: roleArn,
                RoleSessionName: IamRoleSessionName
              })
            );
            if (Credentials == null) {
              throw new Error("Error loading credentials");
            }
            config2.credentials = {
              accessKeyId: Credentials.AccessKeyId,
              secretAccessKey: Credentials.SecretAccessKey,
              sessionToken: Credentials.SessionToken
            };
          }
          function createRoleArn(accountId, targetRoleName = process.env.IamTargetAccountRoleName) {
            return `arn:${process.env.AWS_PARTITION}:iam::${accountId}:role/${targetRoleName}`;
          }
          var cachedSecrets = {};
          if (process.env.SKIP_CACHE_EVICTION_INTERVAL !== "true") {
            setInterval(() => cachedSecrets = {}, 3e5);
          }

          // src/lambda/code/lib/describeInstanceParameters.ts
          function formatTagParams({
            params,
            requiredTags
          }) {
            if (typeof requiredTags !== "string") return params;
            const array = requiredTags.split(",").filter((x) => x.trim());
            if (!array.length) return params;
            if (!params.Filters) params.Filters = [];
            array.forEach((s) => {
              const [k, v] = s.split("=");
              params.Filters.push({
                Name: `tag:${k}`,
                Values: [v]
              });
            });
            return params;
          }

          // src/lambda/code/lib/filterImages.ts
          var import_differenceBy = __toESM(require_differenceBy());

          // src/lambda/code/discovery/skippedResource.ts
          var SourceTableInventory = process.env.SourceTableInventory ?? "RESOURCE_INVENTORY";
          var DefaultExpiryHours = parseInt(
            process.env.SCAN_INTERVAL_HOURS ?? "24",
            10
          );
          var AmiDefaultExpiryHours = parseInt(
            process.env.AMI_SCAN_INTERVAL_HOURS ?? "168",
            10
          );
          function mapInstanceToSkippedResource(instance, targetAccountId, targetRegion, discoveryTaskId, SkipReason2) {
            const now = Math.floor(Date.now() / 1e3);
            const expiry = DefaultExpiryHours * 3600;
            return {
              UID: instance.InstanceId,
              RawInstanceData: JSON.stringify(instance),
              ScannerState: "SKIPPED" /* Skipped */,
              Source: SourceTableInventory,
              StateReason: SkipReason2,
              ResourceType: "Instance",
              InstanceId: instance.InstanceId,
              TargetAccount: targetAccountId,
              TargetRegion: targetRegion,
              DiscoveryTaskId: discoveryTaskId,
              ExpiresAt: now + expiry
            };
          }
          function mapImageToSkippedResource(instance, targetAccountId, targetRegion, discoveryTaskId, SkipReason2) {
            const now = Math.floor(Date.now() / 1e3);
            const expiry = AmiDefaultExpiryHours * 3600;
            return {
              UID: instance.ImageId,
              RawInstanceData: JSON.stringify(instance),
              ScannerState: "SKIPPED" /* Skipped */,
              StateReason: SkipReason2,
              Source: SourceTableInventory,
              ResourceType: "Image",
              InstanceId: instance.ImageId,
              TargetAccount: targetAccountId,
              TargetRegion: targetRegion,
              DiscoveryTaskId: discoveryTaskId,
              ExpiresAt: now + expiry
            };
          }

          // src/lambda/code/lib/getProperty.ts
          function getProperty(obj, path) {
            const keys = path.split(".");
            let result = obj;
            for (let index = 0; index < keys.length; index++) {
              const key = keys[index];
              if (key === "$") continue;
              if (key === "*") {
                if (!Array.isArray(result)) {
                  return void 0;
                }
                const subPath = keys.slice(index + 1).join(".");
                return result.map((element) => getProperty(element, subPath));
              }
              if (result[key] === void 0) {
                return void 0;
              }
              result = result[key];
            }
            return result;
          }

          // src/lambda/code/lib/filter.ts
          function filter(array, conditions, expression) {
            return array.filter((item) => {
              const conditionResults = {};
              for (const condition of conditions) {
                const actual = getProperty(item, condition.key);
                const expected = typeof condition.value === "string" && condition.value.startsWith("$") ? getProperty(item, condition.value) : condition.value;
                switch (condition.operator) {
                  case "==":
                  case "=":
                    conditionResults[condition.id] = actual === expected;
                    break;
                  case "!=":
                  case "!==":
                    conditionResults[condition.id] = actual !== expected;
                    break;
                  case ">":
                    conditionResults[condition.id] = actual !== void 0 && expected !== void 0 && actual > expected;
                    break;
                  case "<":
                    conditionResults[condition.id] = actual !== void 0 && expected !== void 0 && actual < expected;
                    break;
                  case "exists":
                    conditionResults[condition.id] = actual !== void 0;
                    break;
                  case "in":
                    conditionResults[condition.id] = Array.isArray(expected) && expected.includes(actual);
                    break;
                  case "includes":
                    conditionResults[condition.id] = Array.isArray(actual) && actual.includes(expected);
                    break;
                }
              }
              const evalExpression = new Function(
                "conditionResults",
                `with(conditionResults) { return ${expression} }`
              );
              return evalExpression(conditionResults);
            });
          }
          function customFilter({
            array,
            conditions,
            expression
          }) {
            return filter(array, conditions, expression);
          }

          // src/lambda/code/lib/tagFilter.ts
          function createNormalisedKey(prefix2, key) {
            return `__${prefix2}_${key}`;
          }
          function normalizeTags(array, TAGS_KEY) {
            return array.map((obj) => {
              const newObj = { ...obj };
              if (Array.isArray(obj[TAGS_KEY])) {
                obj[TAGS_KEY].forEach((tag) => {
                  newObj[createNormalisedKey(TAGS_KEY, tag.Key)] = tag.Value;
                });
              }
              return newObj;
            });
          }
          function createConditions(mustHave, atLeastOne, none, TAGS_KEY) {
            const conditions = [];
            mustHave.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `mustHave${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "=="
              });
            });
            atLeastOne.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `atLeastOne${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "=="
              });
            });
            none.forEach((tag, index) => {
              const [key, value] = tag.split("=");
              conditions.push({
                id: `none${index}`,
                key: createNormalisedKey(TAGS_KEY, key),
                value,
                operator: "!="
              });
            });
            return conditions;
          }
          function filterInstances(instances, mustHaveTags, atLeastOneTags, noneTags, qualysTags, TAGS_KEY) {
            const mustHave = mustHaveTags ? mustHaveTags.split(",") : [];
            const atLeastOne = atLeastOneTags ? atLeastOneTags.split(",") : [];
            let none = noneTags ? noneTags.split(",") : [];
            none = none.concat(...qualysTags ? qualysTags.split(",") : []);
            const conditions = createConditions(mustHave, atLeastOne, none, TAGS_KEY);
            const mustHaveExpression = mustHave.length > 0 ? mustHave.map((_, index) => `mustHave${index}`).join(" && ") : "true";
            const atLeastOneExpression = atLeastOne.length > 0 ? atLeastOne.map((_, index) => `atLeastOne${index}`).join(" || ") : "true";
            const noneExpression = none.length > 0 ? none.map((_, index) => `none${index}`).join(" && ") : "true";
            const expression = `${mustHaveExpression} && (${atLeastOneExpression}) && ${noneExpression}`;
            return filter(instances, conditions, expression);
          }
          function denormalizeTags(array, key) {
            return array.map((u) => {
              Object.keys(u).forEach((k) => {
                if (k.startsWith(`__${key}`)) delete u[k];
              });
              return u;
            });
          }
          function filterInstancesWrapper(event) {
            const {
              mustHaveTags,
              atLeastOneTags,
              noneTags,
              qualysTags,
              opts: { normaliseTags = true, tagsKey = "Tags" } = {}
            } = event;
            let instances = event.instances;
            const fn = (i) => filterInstances(
              i,
              mustHaveTags,
              atLeastOneTags,
              noneTags,
              qualysTags,
              tagsKey
            );
            if (normaliseTags) {
              instances = normalizeTags(instances, tagsKey);
              return denormalizeTags(fn(instances), tagsKey);
            } else {
              return fn(instances);
            }
          }

          // src/lambda/code/lib/filterImages.ts
          function filterImagesByTags(instances, tagConfig) {
            return filterInstancesWrapper({
              instances,
              mustHaveTags: tagConfig.mustHaveTags,
              atLeastOneTags: tagConfig.anyInListTags,
              noneTags: tagConfig.noneInTheList,
              qualysTags: tagConfig.qualysTags
            });
          }
          function filterImagesByProperty(images) {
            return customFilter({
              array: images,
              conditions: [
                {
                  id: "isMarketplace",
                  key: "ProductCodes.*.ProductCodeType",
                  value: "marketplace",
                  operator: "includes"
                },
                {
                  id: "isARM",
                  key: "Architecture",
                  value: "arm64",
                  operator: "=="
                },
                {
                  id: "isWindows",
                  key: "PlatformDetails",
                  value: "Windows",
                  operator: "=="
                },
                {
                  id: "doesNotSupportEna",
                  key: "EnaSupport",
                  value: true,
                  operator: "!="
                }
              ],
              expression: "!isWindows && !( isMarketplace && isARM ) && !( isMarketplace && doesNotSupportEna )"
            });
          }
          function filterImagesByState(images) {
            return customFilter({
              array: images,
              conditions: [
                {
                  id: "isAvailable",
                  key: "State",
                  value: "available",
                  operator: "=="
                }
              ],
              expression: "isAvailable"
            });
          }
          async function filterValidImages(images, targetAccountId, targetRegion, discoveryTaskId, tagConfig) {
            let skippedImages = [];
            const initialCount = images.length;
            const images1 = filterImagesByState(images);
            const filteredByState = images1.length;
            skippedImages = [
              ...skippedImages,
              ...(0, import_differenceBy.default)(images, images1, (a) => a.ImageId).map(
                (a) => mapImageToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "INVALID_STATE" /* INVALID_STATE */
                )
              )
            ];
            const images2 = filterImagesByTags(images1, tagConfig);
            const filteredByTagCount = images2.length;
            skippedImages = [
              ...skippedImages,
              ...(0, import_differenceBy.default)(images1, images2, (a) => a.ImageId).map(
                (a) => mapImageToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "INVALID_TAGS" /* INVALID_TAGS */
                )
              )
            ];
            const images3 = filterImagesByProperty(images2);
            const filteredByPropertyCount = images3.length;
            skippedImages = [
              ...skippedImages,
              ...(0, import_differenceBy.default)(images2, images3, (a) => a.ImageId).map(
                (a) => mapImageToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "INVALID_PROPERTIES" /* INVALID_PROPERTIES */
                )
              )
            ];
            return {
              images: images3,
              skippedImages,
              filterInfo: {
                initialCount,
                filteredByState,
                filteredByTagCount,
                filteredByPropertyCount
              }
            };
          }

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/discovery/saveImages.ts
          var import_client_dynamodb2 = require("@aws-sdk/client-dynamodb");
          var import_client_ec2 = require("@aws-sdk/client-ec2");
          var import_client_kms = require("@aws-sdk/client-kms");
          var import_client_sfn = require("@aws-sdk/client-sfn");
          var import_lib_dynamodb3 = require("@aws-sdk/lib-dynamodb");
          var import_crypto = require("crypto");

          // src/lambda/code/discovery/saveResourceToDb.ts
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");
          var import_chunk = __toESM(require_chunk());
          var InventoryTableName = process.env.InventoryTableName ?? RESOURCE_INVENTORY_TABLE;
          async function saveResourceToDb(instanceDetails, dynamodbClient) {
            const command = new import_lib_dynamodb.PutCommand({
              TableName: InventoryTableName,
              Item: instanceDetails,
              ConditionExpression: "UID <> :uid or (UID = :uid AND ScannerState = :skipped)",
              ExpressionAttributeValues: {
                ":uid": instanceDetails.UID,
                ":skipped": "SKIPPED" /* Skipped */
              }
            });
            await dynamodbClient.send(command);
          }
          async function saveBulkResourcesToDb(instancesDetails, dynamodbClient) {
            console.log(instancesDetails);
            const batches = (0, import_chunk.default)(instancesDetails, 25);
            await Promise.all(
              batches.map(async (batch) => {
                const command = new import_lib_dynamodb.BatchWriteCommand({
                  RequestItems: {
                    [InventoryTableName]: batch.map((instanceDetails) => ({
                      PutRequest: {
                        Item: instanceDetails,
                        ConditionExpression: "UID <> :uid or (UID = :uid AND ScannerState = :skipped)",
                        ExpressionAttributeValues: {
                          ":uid": instanceDetails.UID,
                          ":skipped": "SKIPPED" /* Skipped */
                        }
                      }
                    }))
                  }
                });
                await dynamodbClient.send(command);
              })
            );
          }

          // src/lambda/code/discovery/saveScanStatus.ts
          var import_lib_dynamodb2 = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/discovery/parsePlatform.ts
          var parsePlatform = (platformDetails) => {
            if (platformDetails.toLowerCase().indexOf("windows") >= 0) {
              return "WINDOWS";
            } else {
              return "LINUX";
            }
          };

          // src/lambda/code/discovery/saveScanStatus.ts
          var ScanStatusTableName = process.env.ScanStatusTableName ?? RESOURCE_INVENTORY_SCAN_STATUS_TABLE;
          async function saveResourceToScanStatus({
            ResourceId,
            ResourceName,
            ResourceType,
            ScanTypes,
            Platform,
            TargetAccount,
            TargetRegion,
            VolumeCount,
            ExpiresAt,
            DiscoveryTaskId
          }, { dynamodbClient }) {
            await Promise.all(
              ScanTypes.map(async (scanType) => {
                const Item = {
                  ResourceId,
                  ResourceName,
                  ResourceType,
                  TargetRegion,
                  TargetAccount,
                  ScanType: scanType,
                  // scanTypes is an array, and we are storing it as comma seperated string
                  ScannerPlatform: parsePlatform(Platform),
                  VolumeCount,
                  ScanAttempts: 0,
                  ScanStatus: "PENDING" /* Pending */,
                  ExpiresAt,
                  DiscoveryTaskId,
                  Source: "INVENTORY_SCAN_STATUS"
                };
                const params = {
                  TableName: ScanStatusTableName,
                  Item,
                  ConditionExpression: "ResourceId <> :uid and ScanType <> :scanType",
                  ExpressionAttributeValues: {
                    ":uid": ResourceId,
                    ":scanType": scanType
                  }
                };
                await dynamodbClient.send(new import_lib_dynamodb2.PutCommand(params));
              })
            );
          }

          // src/lambda/code/discovery/saveImages.ts
          var SourceTableAmiInventory = process.env.SourceTableInventory ?? "RESOURCE_INVENTORY";
          var AmiSourceTableLogs = process.env.AmiSourceTableLogs ?? "EVENT_LOGS";
          var AmiEventStatesRegistered = process.env.AmiEventStatesRegistered ?? "AMI_REGISTERED";
          var AmiEventStatesReceived = process.env.AmiEventStatesReceived ?? "EVENT_RECEIVED";
          var AmiInventoryTableName = process.env.InventoryTableName ?? RESOURCE_INVENTORY_TABLE;
          var AmiEventLogsTableName = process.env.DbTableEventLogs ?? EVENT_LOGS_TABLE;
          var AmiDefaultExpiryHours2 = parseInt(
            process.env.AMI_SCAN_INTERVAL_HOURS ?? "168",
            10
          );
          var AmiLogExpiry = 7 * 24 * 3600;
          function isConditionalCheckFailed(error) {
            return error instanceof import_client_dynamodb2.ConditionalCheckFailedException || error.code?.includes("ConditionalCheckFailedException") || error.message?.includes("ConditionalCheckFailedException") || error.message?.includes("The conditional request failed");
          }
          function handleImageSaveError(error, imageId, errors, results) {
            error.id = imageId;
            console.error("Image save failed:", error);
            errors.push(error);
            results.failed++;
          }
          function extractImageName(image) {
            if (image.Name) {
              return image.Name;
            }
            if (image.Tags) {
              for (const Tag of image.Tags) {
                if (Tag.Key === "Name" && Tag.Value) {
                  return Tag.Value;
                }
              }
            }
            return "-";
          }
          function formatImageDetails(image, targetAccountId, targetRegion, discoveryTaskId) {
            const knownKeys = [
              "ImageId",
              "InstanceType",
              "KeyName",
              "LaunchTime",
              "Placement",
              "PrivateDnsName",
              "PrivateIpAddress",
              "ProductCodes",
              "PublicDnsName",
              "PublicIpAddress",
              "State",
              "SubnetId",
              "VpcId",
              "Architecture",
              "BlockDeviceMappings",
              "EbsOptimized",
              "EnaSupport",
              "Hypervisor",
              "RootDeviceName",
              "RootDeviceType",
              "SourceDestCheck",
              "Tags",
              "VirtualizationType",
              "CpuOptions",
              "PlatformDetails",
              "UsageOperation",
              "UsageOperationUpdateTime",
              "PrivateDnsNameOptions",
              "CurrentInstanceBootMode",
              "Name",
              "ScanTypes"
            ];
            for (const key of Object.keys(image)) {
              if (!knownKeys.includes(key)) {
                delete image[key];
              }
            }
            const now = Math.floor(Date.now() / 1e3);
            const expiry = Math.min(6, AmiDefaultExpiryHours2) * 3600;
            const expiryAfterSnapshot = AmiDefaultExpiryHours2 * 3600;
            const priority = Number(process.env.ScanPriority || "10");
            return {
              UID: image.ImageId,
              ImageId: image.ImageId,
              ResourceType: "Image",
              TargetAccount: targetAccountId,
              TargetRegion: targetRegion,
              Platform: image.PlatformDetails,
              Architecture: image.Architecture,
              RootDeviceType: image.RootDeviceType,
              InstanceId: image.ImageId,
              ScannerState: "DISCOVERED" /* Discovered */,
              Source: SourceTableAmiInventory,
              RawInstanceData: JSON.stringify(image),
              VolumeCount: 1,
              ScanGroup: image.ImageId,
              IsScanGroupLeader: 1,
              ScanPriority: priority,
              ExpiresAt: now + expiry,
              ExpiresAtAfterSnapshot: now + expiryAfterSnapshot,
              DiscoveryTaskId: discoveryTaskId,
              ScanTypes: image.ScanTypes,
              ResourceName: extractImageName(image)
            };
          }
          async function addImageRegisteredEvent(imageDetails, dynamodbClient, discoveredViaEvent) {
            const event = {
              ImageId: imageDetails.ImageId,
              TargetAccount: imageDetails.TargetAccount,
              TargetRegion: imageDetails.TargetRegion,
              Source: AmiSourceTableLogs,
              Metadata: "",
              ExpiresAt: Math.floor(Date.now() / 1e3) + AmiLogExpiry,
              // 7d
              ExecutionId: "IMAGE_DISCOVERY_LAMBDA",
              Time: (/* @__PURE__ */ new Date()).toISOString()
            };
            const itemsToPut = [
              {
                UID: `${imageDetails.ImageId}.${(0, import_crypto.randomUUID)()}`,
                EventName: AmiEventStatesRegistered,
                ...event
              }
            ];
            if (discoveredViaEvent) {
              itemsToPut.push({
                UID: `${imageDetails.ImageId}.${(0, import_crypto.randomUUID)()}`,
                EventName: AmiEventStatesReceived,
                ...event
              });
            }
            await Promise.all(
              itemsToPut.map(async (item) => {
                const params = {
                  TableName: AmiEventLogsTableName,
                  Item: item
                };
                await dynamodbClient.send(new import_lib_dynamodb3.PutCommand(params));
              })
            );
          }
          async function updateImageState(imageDetails, dynamodbClient, Snapshots, State, StateReason) {
            const params = {
              ScannerState: State,
              Snapshots,
              SnapshotDeleteAfterComplete: false,
              ExpiresAt: imageDetails.ExpiresAtAfterSnapshot
            };
            if (StateReason) {
              params.StateReason = StateReason;
            }
            const UpdateExpression = Object.keys(params).map((key) => `${key} = :${key}`).join(", ");
            const ExpressionAttributeValues = Object.fromEntries(
              Object.entries(params).map(([k, v]) => [`:${k}`, v])
            );
            const command = {
              TableName: AmiInventoryTableName,
              Key: { UID: imageDetails.UID },
              UpdateExpression: `SET ${UpdateExpression}`,
              ExpressionAttributeValues,
              ConditionExpression: "attribute_exists(UID)"
            };
            await dynamodbClient.send(new import_lib_dynamodb3.UpdateCommand(command));
          }
          async function addCopyPermission(ec2Client, snapshotId, serviceAccountId) {
            try {
              const describeParams = {
                SnapshotId: snapshotId,
                Attribute: "createVolumePermission"
              };
              const describeResponse = await ec2Client.send(
                new import_client_ec2.DescribeSnapshotAttributeCommand(describeParams)
              );
              const permissions = describeResponse.CreateVolumePermissions || [];
              const permissionExists = permissions.some(
                (perm) => perm.UserId === serviceAccountId
              );
              if (!permissionExists) {
                const modifyParams = {
                  SnapshotId: snapshotId,
                  Attribute: "createVolumePermission",
                  OperationType: "add",
                  UserIds: [serviceAccountId]
                };
                await ec2Client.send(new import_client_ec2.ModifySnapshotAttributeCommand(modifyParams));
              }
            } catch (error) {
              console.error("Error adding copy permission:", error);
              throw error;
            }
          }
          async function grantKmsPermissionsForSnapshot(kmsClient, serviceAccountId, defaultEbsKeyId, snapshots) {
            try {
              const snapshot = snapshots[0];
              if (!snapshot?.Encrypted) return "SNAPSHOT_PERMISSION_REQUIRED";
              const kmsKeyId = snapshot.KmsKeyId;
              if (kmsKeyId !== defaultEbsKeyId) {
                const { KeyMetadata } = await kmsClient.send(
                  new import_client_kms.DescribeKeyCommand({
                    KeyId: kmsKeyId
                  })
                );
                console.log(KeyMetadata);
                if (KeyMetadata == null || !KeyMetadata.Enabled) {
                  return "FAILURE";
                }
                const grantsResponse = await kmsClient.send(
                  new import_client_kms.ListGrantsCommand({
                    KeyId: kmsKeyId,
                    GranteePrincipal: `arn:${process.env.AWS_PARTITION}:iam::${serviceAccountId}:root`
                  })
                );
                if (grantsResponse.Grants == null || grantsResponse.Grants.length === 0) {
                  await kmsClient.send(
                    new import_client_kms.CreateGrantCommand({
                      KeyId: kmsKeyId,
                      GranteePrincipal: `arn:${process.env.AWS_PARTITION}:iam::${serviceAccountId}:root`,
                      RetiringPrincipal: `arn:${process.env.AWS_PARTITION}:iam::${serviceAccountId}:root`,
                      Operations: ["ReEncryptFrom", "Decrypt"],
                      Name: `GrantForSnapshot-${snapshot.SnapshotId}-${serviceAccountId}`
                    })
                  );
                }
                return "SNAPSHOT_PERMISSION_REQUIRED";
              } else {
                return "COPY_REQUIRED";
              }
            } catch (error) {
              console.error("Error granting KMS permissions:", error);
              throw error;
            }
          }
          async function getSnapshotsData(image, ec2Client) {
            const rootEbs = image.BlockDeviceMappings?.find(
              (x) => x.DeviceName === image.RootDeviceName
            );
            const snapshotIds = rootEbs ? [rootEbs.Ebs?.SnapshotId] : image.BlockDeviceMappings?.map((a) => a.Ebs?.SnapshotId);
            const snapshotData = await ec2Client.send(
              new import_client_ec2.DescribeSnapshotsCommand({
                SnapshotIds: snapshotIds.filter((a) => a != null)
              })
            );
            return snapshotData.Snapshots;
          }
          async function saveImages({
            images,
            targetAccountId,
            targetRegion,
            discoveryTaskId
          }, {
            dynamodbClient,
            sa,
            ec2Client,
            kmsClient,
            sfnClient
          }, discoveredViaEvent = false) {
            const batchSize = 10;
            const results = { failed: 0, saved: 0, notified: 0, alreadyExists: 0 };
            const errors = [];
            const defaultEbsKey = await kmsClient.send(
              new import_client_kms.DescribeKeyCommand({
                KeyId: `arn:${process.env.AWS_PARTITION}:kms:${targetRegion}:${targetAccountId}:alias/aws/ebs`
              })
            );
            const defaultEbsKeyId = defaultEbsKey?.KeyMetadata?.Arn;
            const imageDetailsBatch = images.map((a) => ({
              image: a,
              imageDetails: formatImageDetails(
                a,
                targetAccountId,
                targetRegion,
                discoveryTaskId
              )
            }));
            for (let i = 0; i < imageDetailsBatch.length; i += batchSize) {
              const batch = imageDetailsBatch.slice(i, i + batchSize);
              await Promise.all(
                batch.map(async ({ image, imageDetails }) => {
                  try {
                    await saveResourceToDb(imageDetails, dynamodbClient);
                    await addImageRegisteredEvent(
                      imageDetails,
                      dynamodbClient,
                      discoveredViaEvent
                    );
                    const snapshots = await getSnapshotsData(image, ec2Client);
                    const KeyPermissionStatus = await grantKmsPermissionsForSnapshot(
                      kmsClient,
                      sa,
                      defaultEbsKeyId,
                      snapshots
                    );
                    console.log(`${image.ImageId}: ${KeyPermissionStatus}`);
                    if (KeyPermissionStatus === "FAILURE") {
                      await updateImageState(
                        imageDetails,
                        dynamodbClient,
                        snapshots.map((a) => a.SnapshotId),
                        "SNAPSHOT_FAILED" /* SnapshotFailed */,
                        "INVALID_KEY_PERMISSIONS" /* INVALID_KEY_PERMISSIONS */
                      );
                    } else if (KeyPermissionStatus === "SNAPSHOT_PERMISSION_REQUIRED") {
                      if (sa !== targetAccountId) {
                        await addCopyPermission(ec2Client, snapshots[0].SnapshotId, sa);
                      }
                      await updateImageState(
                        imageDetails,
                        dynamodbClient,
                        snapshots.map((a) => a.SnapshotId),
                        "SNAPSHOT_COMPLETED" /* SnapshotCompleted */
                      );
                      await saveResourceToScanStatus(
                        {
                          ResourceId: imageDetails.ImageId,
                          ResourceName: imageDetails.ResourceName,
                          ResourceType: imageDetails.ResourceType,
                          VolumeCount: imageDetails.VolumeCount,
                          ScanTypes: imageDetails.ScanTypes,
                          Platform: imageDetails.Platform,
                          TargetRegion: targetRegion,
                          TargetAccount: targetAccountId,
                          ExpiresAt: imageDetails.ExpiresAtAfterSnapshot,
                          DiscoveryTaskId: discoveryTaskId
                        },
                        { dynamodbClient }
                      );
                    } else {
                      console.log(
                        "Permissions not added for aws managed key, delegating task to step function"
                      );
                      const stateMachineArn = `arn:${process.env.AWS_PARTITION}:states:${process.env.AWS_REGION}:${sa}:stateMachine:${process.env.SfnImageCopySnapshot}`;
                      const startCommand = new import_client_sfn.StartExecutionCommand({
                        stateMachineArn,
                        input: JSON.stringify({
                          Image: imageDetails,
                          Snapshots: snapshots,
                          ScanTypes: imageDetails.ScanTypes
                        })
                      });
                      const execution = await sfnClient.send(startCommand);
                      const executionArn = execution.executionArn;
                      console.log(`Trigger sfn with execution arn ${executionArn}`);
                    }
                    results.saved++;
                  } catch (error) {
                    console.error(error);
                    if (isConditionalCheckFailed(error)) {
                      results.alreadyExists++;
                    } else {
                      handleImageSaveError(error, image.ImageId, errors, results);
                    }
                  }
                })
              );
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            }
            return { saveResult: results, errors };
          }

          // src/lambda/code/discovery/scheduledAmiDiscoveryTask.ts
          async function scheduledAmiDiscoveryTask({
            targetAccountId,
            targetRegion,
            tagConfig,
            lastState,
            imageIdFilter,
            correlationId,
            task
          }) {
            const logSource = "ScheduledDiscoveryTask";
            let nextMarker = lastState && lastState.length ? lastState[lastState.length - 1] : void 0;
            const config2 = {
              region: targetRegion,
              logger: getLogger({ CorrelationId: correlationId })
            };
            await loadCredentials(config2, createRoleArn(targetAccountId));
            await task.trackProgress(logSource, "credentials loaded");
            const ec2Client = new import_client_ec22.EC2Client(config2);
            const kmsClient = new import_client_kms2.KMSClient(config2);
            const SERVICE_ACCOUNT_ID = process.env.SERVICE_ACCOUNT_ID;
            if (SERVICE_ACCOUNT_ID == null) {
              throw new Error("Service account id not defined");
            }
            const localConfig = {
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId: correlationId })
            };
            const dynamodbClient2 = new import_client_dynamodb3.DynamoDBClient(localConfig);
            const sfnClient = new import_client_sfn2.SFNClient(localConfig);
            const parameterName = process.env.SSMAccountsParameterName;
            const accountConfig = await configActionHandler({
              action: "find",
              configName: parameterName,
              lookupValue: targetAccountId
            });
            if (accountConfig == null || accountConfig.data == null || accountConfig.data.amiScanTypes == null || accountConfig.data.amiScanTypes.length === 0) {
              await task.trackProgress(logSource, "account config not found");
              return false;
            }
            await task.trackProgress(logSource, "account config loaded");
            const scanTypes = accountConfig.data.amiScanTypes;
            const discoveryTaskId = task.opts.taskId;
            do {
              const params = {
                MaxResults: 50,
                Owners: ["self"]
              };
              if (imageIdFilter && Array.isArray(imageIdFilter) && imageIdFilter.length) {
                params.ImageIds = imageIdFilter;
                delete params.MaxResults;
              } else if (nextMarker) {
                params.NextToken = nextMarker;
              }
              formatTagParams({ params, requiredTags: tagConfig.mustHaveTags });
              try {
                const describeImagesCommand = new import_client_ec22.DescribeImagesCommand(params);
                const { Images, NextToken } = await ec2Client.send(describeImagesCommand);
                await task.trackProgress(logSource, "describe images success");
                nextMarker = NextToken;
                await task.trackProgress(logSource, "nextMarkerExists?=" + !!nextMarker);
                const images = Images;
                await task.trackProgress(
                  logSource,
                  "describe images length=" + images.length
                );
                const {
                  images: filteredImages,
                  skippedImages,
                  filterInfo
                } = await filterValidImages(
                  images,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  tagConfig
                );
                await saveBulkResourcesToDb(skippedImages, dynamodbClient2);
                const filterInfoStr = Object.entries(filterInfo).map(([k, v]) => `${k}=${v}`).join(",");
                await task.trackProgress(
                  logSource,
                  "filter images details: " + filterInfoStr
                );
                const { saveResult, errors } = await saveImages(
                  {
                    images: filteredImages.map((a) => ({ ...a, ScanTypes: scanTypes })),
                    targetAccountId,
                    targetRegion,
                    discoveryTaskId
                  },
                  {
                    dynamodbClient: dynamodbClient2,
                    sfnClient,
                    sa: SERVICE_ACCOUNT_ID,
                    ec2Client,
                    kmsClient
                  },
                  !!imageIdFilter
                  // this is event based payload if this property exists
                );
                await task.trackProgress(
                  logSource,
                  "save images result=: " + Object.entries(saveResult).map(([k, v]) => `${k}=${v}`).join(",")
                );
                if (errors.length) {
                  for (const error of errors) {
                    await task.trackProgress(
                      logSource,
                      error.id + "-> save images failed, " + error.message
                    );
                    await task.trackProgress(logSource, error.stack.slice(0, 1024));
                  }
                  return false;
                }
                if (nextMarker) {
                  await task.updateTaskContext(nextMarker);
                }
              } catch (e) {
                await task.trackProgress(
                  logSource,
                  "describe & save instances failed, " + e.message
                );
                await task.trackProgress(logSource, e.stack.slice(0, 1024));
                return false;
              }
            } while (nextMarker && !task.isTimedOut);
            return true;
          }

          // src/lambda/code/discovery/scheduledDiscoveryTask.ts
          var import_client_dynamodb6 = require("@aws-sdk/client-dynamodb");
          var import_client_ec24 = require("@aws-sdk/client-ec2");
          var import_client_sqs2 = require("@aws-sdk/client-sqs");
          var import_differenceBy3 = __toESM(require_differenceBy());

          // src/lambda/code/lib/filterInstances.ts
          var import_client_ec23 = require("@aws-sdk/client-ec2");
          var import_differenceBy2 = __toESM(require_differenceBy());
          function filterInstancesByTags(instances, tagConfig) {
            return filterInstancesWrapper({
              instances,
              mustHaveTags: tagConfig.mustHaveTags,
              atLeastOneTags: tagConfig.anyInListTags,
              noneTags: tagConfig.noneInTheList,
              qualysTags: tagConfig.qualysTags
            });
          }
          function filterInstancesByProperty(instances) {
            return customFilter({
              array: instances,
              conditions: [
                {
                  id: "isMarketplace",
                  key: "ProductCodes.*.ProductCodeType",
                  value: "marketplace",
                  operator: "includes"
                },
                {
                  id: "isARM",
                  key: "Architecture",
                  value: "arm64",
                  operator: "=="
                },
                {
                  id: "doesNotSupportEna",
                  key: "EnaSupport",
                  value: true,
                  operator: "!="
                }
              ],
              expression: "!( isMarketplace && isARM ) && !( isMarketplace && doesNotSupportEna )"
            });
          }
          async function filterInstancesByVolumeId(instances, tagConfig, ec2) {
            let allVolumes = [];
            let nextMarker;
            do {
              const { Volumes, NextToken } = await ec2.send(
                new import_client_ec23.DescribeVolumesCommand({
                  // no pagination since instances length is less than 50
                  Filters: [
                    {
                      Name: "attachment.instance-id",
                      Values: instances.map((e) => e.InstanceId)
                    }
                  ],
                  MaxResults: 500,
                  ...nextMarker ? { NextToken: nextMarker } : {}
                })
              );
              nextMarker = NextToken;
              allVolumes = [...allVolumes, ...Volumes];
            } while (nextMarker);
            const safeVolumes = filterInstancesWrapper({
              instances: allVolumes,
              noneTags: tagConfig.noneOnVolume
            });
            const safeInstanceIds = safeVolumes.flatMap(
              (s) => s.Attachments.map((u) => u.InstanceId)
            );
            const instancesWithValidVolumes = customFilter({
              array: instances,
              conditions: [
                {
                  id: "C1",
                  key: "InstanceId",
                  value: safeInstanceIds,
                  operator: "in"
                }
              ],
              expression: "C1"
            });
            const safeVolumeId = safeVolumes.map((v) => v.VolumeId);
            instancesWithValidVolumes.forEach((instance) => {
              instance.BlockDeviceMappings = instance.BlockDeviceMappings.filter(
                (b) => safeVolumeId.includes(b.Ebs?.VolumeId)
              );
            });
            return instancesWithValidVolumes;
          }
          async function filterValidEC2Instances(instances, targetAccountId, targetRegion, discoveryTaskId, tagConfig, ec2) {
            let skippedInstances = [];
            const initialCount = instances.length;
            let filteredByVolumeCount = "NA";
            const instances1 = filterInstancesByTags(instances, tagConfig);
            const filteredByTagCount = instances1.length;
            skippedInstances = [
              ...skippedInstances,
              ...(0, import_differenceBy2.default)(instances, instances1, (a) => a.InstanceId).map(
                (a) => mapInstanceToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "INVALID_TAGS" /* INVALID_TAGS */
                )
              )
            ];
            const instances2 = filterInstancesByProperty(instances1);
            const filteredByPropertyCount = instances2.length;
            skippedInstances = [
              ...skippedInstances,
              ...(0, import_differenceBy2.default)(instances1, instances2, (a) => a.InstanceId).map(
                (a) => mapInstanceToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "INVALID_PROPERTIES" /* INVALID_PROPERTIES */
                )
              )
            ];
            let instances3 = instances2;
            if (instances2.length && tagConfig.noneOnVolume) {
              instances3 = await filterInstancesByVolumeId(instances2, tagConfig, ec2);
              skippedInstances = [
                ...skippedInstances,
                ...(0, import_differenceBy2.default)(instances2, instances3, (a) => a.InstanceId).map(
                  (a) => mapInstanceToSkippedResource(
                    a,
                    targetAccountId,
                    targetRegion,
                    discoveryTaskId,
                    "INVALID_VOLUMES" /* INVALID_VOLUMES */
                  )
                )
              ];
              filteredByVolumeCount = instances3.length;
            } else {
              instances3 = instances2;
            }
            return {
              instances: instances3,
              skippedInstances,
              filterInfo: {
                initialCount,
                filteredByTagCount,
                filteredByPropertyCount,
                filteredByVolumeCount
              }
            };
          }

          // src/lambda/code/lib/utils.ts
          async function promisePool(tasks, concurrency) {
            let index = 0;
            const results = [];
            const executing = /* @__PURE__ */ new Set();
            function enqueue() {
              if (index >= tasks.length) {
                return Promise.resolve();
              }
              const taskIndex = index++;
              const taskPromise = tasks[taskIndex]().then((result) => {
                results[taskIndex] = result;
              }).catch((error) => {
                console.error(`Task ${taskIndex + 1} failed:`, error);
                results[taskIndex] = null;
              }).finally(() => executing.delete(taskPromise));
              executing.add(taskPromise);
              const nextTask = taskPromise.finally(enqueue);
              return nextTask;
            }
            const initialTasks = Array.from(
              { length: Math.min(concurrency, tasks.length) },
              enqueue
            );
            await Promise.all(initialTasks);
            await Promise.all(executing);
            return results;
          }
          function shuffleArray(array) {
            for (let i = 0; i < array.length; i++) {
              const j = Math.floor(Math.random() * array.length);
              [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
          }

          // src/lambda/code/discovery/samplingProvision.ts
          var sdb = __toESM(require("@aws-sdk/client-dynamodb"));
          var import_client_dynamodb4 = require("@aws-sdk/client-dynamodb");
          var sdbl = __toESM(require("@aws-sdk/lib-dynamodb"));
          var import_lib_dynamodb4 = require("@aws-sdk/lib-dynamodb");
          var sdbu = __toESM(require("@aws-sdk/util-dynamodb"));
          var config = {
            region: process.env.AWS_REGION || "us-east-1"
            // logger: getLogger({ CorrelationId: correlationId }),
          };
          var DbScanSamplingIndex = "byScanSampling";
          var client = new import_client_dynamodb4.DynamoDBClient(config);
          var ddbDocClient = import_lib_dynamodb4.DynamoDBDocumentClient.from(client);
          var SourceTable = {
            Inventory: process.env.InventoryTableName || RESOURCE_INVENTORY_TABLE
          };
          var SamplingEnabled = () => process.env.SamplingEnabled === "Enabled";
          var SamplingGroups = [
            {
              id: "asg",
              fields: [
                "ImageId",
                "Tags.aws:autoscaling:groupName",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version",
                "SecurityGroups.GroupId"
              ],
              conditions: [
                "ImageId",
                "Tags.aws:autoscaling:groupName",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version"
              ],
              min: 2
            },
            {
              id: "fleet",
              fields: [
                "ImageId",
                "Tags.aws:ec2:fleet-id",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version",
                "SecurityGroups.GroupId"
              ],
              conditions: [
                "ImageId",
                "Tags.aws:ec2:fleet-id",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version"
              ],
              min: 2
            },
            {
              id: "spot-request",
              fields: [
                "ImageId",
                "Tags.aws:ec2spot:fleet-request-id",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version",
                "SecurityGroups.GroupId"
              ],
              conditions: [
                "ImageId",
                "Tags.aws:ec2spot:fleet-request-id",
                "Tags.aws:ec2launchtemplate:id",
                "Tags.aws:ec2launchtemplate:version"
              ],
              min: 2
            }
          ];
          var getDbInstances = async (instances) => {
            const keys = [];
            instances.forEach((instance) => {
              if (instance.IsScanGroupLeader === -1) {
                keys.push({
                  UID: instance.InstanceId
                });
              }
            });
            const _instances = /* @__PURE__ */ new Map();
            if (!keys.length) {
              return _instances;
            }
            const params = {
              RequestItems: {
                [SourceTable.Inventory]: {
                  Keys: keys.map((key) => sdbu.marshall(key)),
                  ProjectionExpression: "UID, ScanGroup, IsScanGroupLeader"
                }
              }
              // ReturnConsumedCapacity: "TOTAL",
            };
            const { Responses } = await ddbDocClient.send(
              new sdb.BatchGetItemCommand(params)
            );
            for (const { UID, ScanGroup, IsScanGroupLeader } of Responses?.[SourceTable.Inventory] || []) {
              _instances.set(UID, { ScanGroup, IsScanGroupLeader });
            }
            return _instances;
          };
          var getScanGroupCount = async (groupId, value) => {
            const _query = {
              TableName: SourceTable.Inventory,
              IndexName: DbScanSamplingIndex,
              KeyConditionExpression: "ScanGroup = :scanGroup and IsScanGroupLeader >= :isScanGroupLeader",
              ExpressionAttributeValues: {
                ":isScanGroupLeader": value,
                ":scanGroup": groupId
              },
              Select: "COUNT",
              ReturnConsumedCapacity: "TOTAL"
            };
            const { Count } = await client.send(new sdbl.QueryCommand(_query));
            return Count ?? 0;
          };
          function checkConditions(obj, conditionGroups) {
            return conditionGroups.every((group) => {
              const conditions = group.split(" OR ").map(parseCondition);
              return conditions.some((condition) => condition(obj));
            });
          }
          function parseCondition(condition) {
            const [field, operator, value] = condition.split(" ");
            return function(o) {
              if (!operator && !value) {
                return Boolean(o[field]);
              }
              switch (operator) {
                case ">":
                  return o[field] > value;
                case "<":
                  return o[field] < value;
                case ">=":
                  return o[field] >= value;
                case "<=":
                  return o[field] <= value;
                case "==":
                  return o[field] == value;
                case "!=":
                  return o[field] != value;
                case "startsWith":
                  return o[field].startsWith(value);
                case "endsWith":
                  return o[field].endsWith(value);
                case "includes":
                  return o[field].includes(value);
                default:
                  throw new Error("Invalid condition");
              }
            };
          }
          function pickValues(obj, keyPaths) {
            const result = {};
            function isObject(val) {
              return val && typeof val === "object" && !Array.isArray(val);
            }
            function extractKeyValueArray(arr) {
              return arr.reduce((acc, { Key, Value }) => {
                acc[Key] = Value;
                return acc;
              }, {});
            }
            function getValueByPath(obj2, path) {
              return path.split(".").reduce((acc, key) => acc ? acc[key] : void 0, obj2);
            }
            keyPaths.forEach((path) => {
              const pathSegments = path.split(".");
              const parentPath = pathSegments.slice(0, -1).join(".");
              const lastKey = pathSegments[pathSegments.length - 1];
              const parentValue = getValueByPath(obj, parentPath);
              if (Array.isArray(parentValue) && parentValue.every(isObject)) {
                if (parentValue.every((item) => "Key" in item && "Value" in item)) {
                  const keyValueObj = extractKeyValueArray(parentValue);
                  if (lastKey in keyValueObj) {
                    result[path] = keyValueObj[lastKey];
                  }
                } else {
                  const extractedValues = parentValue.map((item) => item[lastKey]).filter((value) => value !== void 0);
                  if (extractedValues.length > 0) {
                    result[path] = extractedValues;
                  }
                }
              } else {
                const value = getValueByPath(obj, path);
                if (value !== void 0) {
                  result[path] = value;
                }
              }
            });
            return result;
          }
          function checkForSampling(instance) {
            if (SamplingEnabled()) {
              const keyPaths = [
                ...new Set(SamplingGroups.flatMap(({ fields }) => fields))
              ];
              const metadata = pickValues(instance, keyPaths);
              for (const { id, fields, conditions } of SamplingGroups) {
                if (!checkConditions(metadata, conditions)) {
                  continue;
                }
                const hash = [];
                for (const field of fields) {
                  if (metadata[field]) {
                    if (Array.isArray(metadata[field])) {
                      hash.push(metadata[field].sort().join(","));
                    } else if (typeof metadata[field] === "string" || typeof metadata[field] === "number" || typeof metadata[field] === "boolean") {
                      hash.push(String(metadata[field]));
                    } else {
                      hash.push("");
                    }
                  }
                }
                if (hash.length) {
                  return { group: `${id}|${hash.join("|")}`, unassessed: true };
                }
              }
            }
            return { group: instance.InstanceId };
          }
          function isSamplingEnabled(config2) {
            if (config2 && config2.forceDisableInstanceGrouping) {
              return false;
            }
            return SamplingEnabled();
          }
          var samplingProvision = {
            getDbInstances,
            isSamplingEnabled,
            checkForSampling,
            getScanGroupCount
          };

          // src/lambda/code/discovery/saveInstances.ts
          var import_client_dynamodb5 = require("@aws-sdk/client-dynamodb");
          var import_client_sqs = require("@aws-sdk/client-sqs");
          var import_lib_dynamodb5 = require("@aws-sdk/lib-dynamodb");
          var import_crypto2 = __toESM(require("crypto"));
          var uuid = import_crypto2.default.randomUUID;
          var SourceTableInventory2 = process.env.SourceTableInventory ?? "RESOURCE_INVENTORY";
          var SourceTableLogs = process.env.SourceTableLogs ?? "EVENT_LOGS";
          var EventStatesRegistered = process.env.EventStatesRegistered ?? "INSTANCE_REGISTERED";
          var EventStatesReceived = process.env.EventStatesReceived ?? "EVENT_RECEIVED";
          var EventLogsTableName = process.env.DbTableEventLogs ?? EVENT_LOGS_TABLE;
          var DefaultExpiryHours2 = parseInt(
            process.env.SCAN_INTERVAL_HOURS ?? "24",
            10
          );
          var LogExpiry = 7 * 24 * 3600;
          async function addInstanceRegisteredEvent(instanceDetails, dynamodbClient, discoveredViaEvent) {
            const event = {
              InstanceId: instanceDetails.InstanceId,
              TargetAccount: instanceDetails.TargetAccount,
              TargetRegion: instanceDetails.TargetRegion,
              Source: SourceTableLogs,
              Metadata: "",
              ExpiresAt: Math.floor(Date.now() / 1e3) + LogExpiry,
              ExecutionId: "INSTANCE_DISCOVERY_LAMBDA",
              Time: (/* @__PURE__ */ new Date()).toISOString()
            };
            if (discoveredViaEvent) {
              const commandEventReceived = new import_lib_dynamodb5.PutCommand({
                TableName: EventLogsTableName,
                Item: {
                  UID: `${instanceDetails.InstanceId}.${uuid()}`,
                  EventName: EventStatesReceived,
                  ...event
                }
              });
              await dynamodbClient.send(commandEventReceived);
            }
            const commandEventRegistered = new import_lib_dynamodb5.PutCommand({
              TableName: EventLogsTableName,
              Item: {
                UID: `${instanceDetails.InstanceId}.${uuid()}`,
                EventName: EventStatesRegistered,
                ...event
              }
            });
            await dynamodbClient.send(commandEventRegistered);
          }
          async function notifySnapshotFlow(instanceDetails, sqsClient) {
            const snapshotNotifyQueue = process.env.SNAPSHOT_NOTIFY_QUEUE_URL;
            const command = new import_client_sqs.SendMessageCommand({
              QueueUrl: snapshotNotifyQueue,
              MessageBody: JSON.stringify({
                Instance: instanceDetails,
                ScanTypes: instanceDetails.ScanTypes
              })
            });
            await sqsClient.send(command);
          }
          function extractInstanceName(instance) {
            if (instance.Tags) {
              for (const Tag of instance.Tags) {
                if (Tag.Key === "Name" && Tag.Value) {
                  return Tag.Value;
                }
              }
            }
            return "-";
          }
          function formatInstanceDetails(instance, targetAccountId, targetRegion, discoveryTaskId) {
            const knownKeys = [
              "ImageId",
              "InstanceId",
              "InstanceType",
              "KeyName",
              "LaunchTime",
              "Placement",
              "PrivateDnsName",
              "PrivateIpAddress",
              "Ipv6Address",
              "ProductCodes",
              "PublicDnsName",
              "PublicIpAddress",
              "State",
              "SubnetId",
              "VpcId",
              "Architecture",
              "BlockDeviceMappings",
              "EbsOptimized",
              "EnaSupport",
              "Hypervisor",
              "RootDeviceName",
              "RootDeviceType",
              "SourceDestCheck",
              "Tags",
              "VirtualizationType",
              "CpuOptions",
              "PlatformDetails",
              "UsageOperation",
              "UsageOperationUpdateTime",
              "PrivateDnsNameOptions",
              "CurrentInstanceBootMode",
              "NetworkInterfaces",
              "ScanGroup",
              "IsScanGroupLeader",
              "ScanTypes"
            ];
            for (const key of Object.keys(instance)) {
              if (!knownKeys.includes(key)) {
                delete instance[key];
              }
            }
            const rootEbs = instance.BlockDeviceMappings?.find(
              (x) => x.DeviceName === instance.RootDeviceName
            );
            const rootVolumeId = rootEbs && rootEbs.Ebs ? rootEbs.Ebs.VolumeId : instance.BlockDeviceMappings != null ? instance.BlockDeviceMappings[0].Ebs?.VolumeId ?? "" : "";
            if (!rootVolumeId) {
              throw new Error("no valid volume id found");
            }
            const volumeIds = instance.BlockDeviceMappings?.map((v) => v.Ebs?.VolumeId).filter(
              (a) => a != null
            ) ?? [];
            let VolumeIds = [rootVolumeId];
            if (instance.ScanTypes.includes("swca") || instance.ScanTypes.includes("secret")) {
              VolumeIds = volumeIds;
            }
            let scanTypes = instance.ScanTypes;
            const now = Math.floor(Date.now() / 1e3);
            const expiry = Math.min(6, DefaultExpiryHours2) * 3600;
            const expiryAfterSnapshot = DefaultExpiryHours2 * 3600;
            const priority = Number(process.env.ScanPriority || "10");
            let expiresAt = now + expiry;
            if (instance.IsScanGroupLeader === 0) {
              scanTypes = [];
              VolumeIds = [];
              expiresAt = now + Number(DefaultExpiryHours2 * 3600);
            }
            return {
              UID: instance.InstanceId,
              InstanceId: instance.InstanceId,
              ResourceType: "Instance",
              TargetAccount: targetAccountId,
              TargetRegion: targetRegion,
              TargetZone: instance.Placement?.AvailabilityZone,
              Platform: instance.PlatformDetails,
              ImageId: instance.ImageId,
              Architecture: instance.Architecture,
              RootDeviceType: instance.RootDeviceType,
              RootVolumeId: rootVolumeId,
              VolumeIds,
              PrivateIpAddress: instance.PrivateIpAddress,
              Ipv6Address: instance.Ipv6Address,
              PrivateDnsName: instance.PrivateDnsName,
              ScannerState: "DISCOVERED" /* Discovered */,
              Source: SourceTableInventory2,
              RawInstanceData: JSON.stringify(instance),
              VolumeCount: VolumeIds.length,
              ScanPriority: priority,
              ExpiresAt: expiresAt,
              ExpiresAtAfterSnapshot: now + expiryAfterSnapshot,
              ScanGroup: instance.ScanGroup || instance.InstanceId || "",
              IsScanGroupLeader: instance.IsScanGroupLeader ?? 1,
              DiscoveryTaskId: discoveryTaskId,
              ScanTypes: filterScanTypesForInstance(instance.PlatformDetails, scanTypes),
              ResourceName: extractInstanceName(instance)
            };
          }
          function filterScanTypesForInstance(platform, scanTypes) {
            if (!platform || !scanTypes) {
              return [];
            }
            const scannerPlatform = parsePlatform(platform);
            if (scannerPlatform === "WINDOWS") {
              return scanTypes.filter((a) => a !== "secret");
            }
            return scanTypes;
          }
          async function saveInstances({
            instances,
            targetAccountId,
            targetRegion,
            discoveryTaskId
          }, {
            dynamodbClient,
            sqsClient
          }, discoveredViaEvent = false) {
            let failed = 0;
            let saved = 0;
            let notified = 0;
            let alreadyExists = 0;
            const poolSize = 25;
            const errors = [];
            const instanceDetails = instances.map(
              (instance) => formatInstanceDetails(
                instance,
                targetAccountId,
                targetRegion,
                discoveryTaskId
              )
            );
            const task = (instance) => async () => {
              try {
                await saveResourceToDb(instance, dynamodbClient);
                await addInstanceRegisteredEvent(
                  instance,
                  dynamodbClient,
                  discoveredViaEvent
                );
                saved++;
                if (instance.VolumeIds.length) {
                  await notifySnapshotFlow(instance, sqsClient);
                  notified++;
                }
              } catch (e) {
                if (e instanceof import_client_dynamodb5.ConditionalCheckFailedException || e.message.includes("ConditionalCheckFailedException")) {
                  alreadyExists++;
                } else {
                  e.id = instance.InstanceId;
                  errors.push(e);
                  failed++;
                }
              }
            };
            const tasks = instanceDetails.map(task);
            await promisePool(tasks, poolSize);
            return { saveResult: { failed, saved, notified, alreadyExists }, errors };
          }

          // src/lambda/code/discovery/scheduledDiscoveryTask.ts
          var SamplingGroupScanPercentage = Number(process.env.SamplingGroupScanPercentage || 10) / 100;
          async function filterInstancesBySampleGroupId(filteredInstancesOriginal, targetAccountId, targetRegion, discoveryTaskId, GroupsCount, LeadersCount) {
            const ScanGroups = /* @__PURE__ */ new Set();
            const filteredInstances = filteredInstancesOriginal.map((i) => {
              const provisionalGroup = samplingProvision.checkForSampling(i);
              const instance = {
                ...i,
                ScanGroup: String(provisionalGroup?.group),
                IsScanGroupLeader: provisionalGroup?.unassessed ? -1 : 1
              };
              if (instance.IsScanGroupLeader === -1 && instance.ScanGroup) {
                ScanGroups.add(instance.ScanGroup);
              }
              return instance;
            });
            if (ScanGroups.size) {
              const scanGroupTasks = [];
              for (const group of Array.from(ScanGroups)) {
                const _task = (group2) => {
                  return async () => {
                    const groupCount = GroupsCount.get(group2) || await samplingProvision.getScanGroupCount(group2, 0);
                    const leadersCount = LeadersCount.get(group2) || await samplingProvision.getScanGroupCount(group2, 1);
                    GroupsCount.set(group2, groupCount || 0);
                    LeadersCount.set(group2, leadersCount || 0);
                  };
                };
                scanGroupTasks.push(_task(group));
              }
              await promisePool(scanGroupTasks, 50);
              shuffleArray(filteredInstances);
              const dbInstances = await samplingProvision.getDbInstances(filteredInstances);
              for (const instance of filteredInstances) {
                if (instance.IsScanGroupLeader !== -1) {
                  continue;
                }
                const { UID, ScanGroup } = instance;
                const skip = () => {
                  instance.IsScanGroupLeader = 0;
                };
                if (dbInstances.has(UID)) {
                  const isPastLeader = dbInstances.get(UID).IsScanGroupLeader;
                  instance.IsScanGroupLeader = isPastLeader;
                  if (!isPastLeader) {
                    skip();
                  }
                  continue;
                }
                if (!ScanGroup) {
                  continue;
                }
                GroupsCount.set(ScanGroup, (GroupsCount.get(ScanGroup) || 0) + 1);
                const coverage = (LeadersCount.get(ScanGroup) || 0) / (GroupsCount.get(ScanGroup) || 1);
                if (coverage >= SamplingGroupScanPercentage) {
                  skip();
                } else {
                  instance.IsScanGroupLeader = 1;
                  LeadersCount.set(ScanGroup, (LeadersCount.get(ScanGroup) || 0) + 1);
                }
              }
            }
            return {
              instances: filteredInstances,
              skippedInstances: (0, import_differenceBy3.default)(
                filteredInstancesOriginal,
                filteredInstances,
                (a) => a.InstanceId
              ).map(
                (a) => mapInstanceToSkippedResource(
                  a,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  "SAMPLING" /* SAMPLING */
                )
              )
            };
          }
          async function scheduledDiscoveryTask(parameters) {
            const {
              targetAccountId,
              targetRegion,
              tagConfig,
              lastState,
              instanceIdFilter,
              correlationId,
              task
            } = parameters;
            const logSource = "ScheduledDiscoveryTask";
            let nextMarker = lastState && lastState.length ? lastState[lastState.length - 1] : void 0;
            const config2 = {
              region: targetRegion,
              logger: getLogger({ CorrelationId: correlationId })
            };
            await loadCredentials(config2, createRoleArn(targetAccountId));
            await task.trackProgress(logSource, "credentials loaded");
            const ec2Client = new import_client_ec24.EC2Client(config2);
            const localConfig = {
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId: correlationId })
            };
            const dynamodbClient1 = new import_client_dynamodb6.DynamoDBClient(localConfig);
            const sqsClient = new import_client_sqs2.SQSClient(localConfig);
            const parameterName = process.env.SSMAccountsParameterName;
            const accountConfig = await configActionHandler({
              action: "find",
              configName: parameterName,
              lookupValue: targetAccountId
            });
            if (accountConfig == null || accountConfig.data == null || accountConfig.data.scanTypes == null) {
              await task.trackProgress(logSource, "account config not found");
              return false;
            }
            await task.trackProgress(
              logSource,
              `account config loaded: ${JSON.stringify(accountConfig)}`
            );
            const scanTypes = accountConfig.data.scanTypes;
            const cloudAgentSkipping = accountConfig.data.cloudAgentSkipping;
            const discoveryTaskId = task.opts.taskId;
            const LeadersCount = /* @__PURE__ */ new Map();
            const GroupsCount = /* @__PURE__ */ new Map();
            do {
              const params = {
                MaxResults: 50,
                Filters: [
                  {
                    Name: "instance-state-name",
                    Values: ["running", "stopped"]
                  }
                ]
              };
              if (instanceIdFilter && Array.isArray(instanceIdFilter) && instanceIdFilter.length) {
                params.InstanceIds = instanceIdFilter;
                delete params.MaxResults;
              } else if (nextMarker) {
                params.NextToken = nextMarker;
              }
              formatTagParams({ params, requiredTags: tagConfig.mustHaveTags });
              try {
                const command = new import_client_ec24.DescribeInstancesCommand(params);
                const { Reservations, NextToken } = await ec2Client.send(command);
                await task.trackProgress(logSource, "describe instances success");
                nextMarker = NextToken;
                await task.trackProgress(logSource, "nextMarkerExists?=" + !!nextMarker);
                const instances = Reservations ? Reservations.flatMap((e) => e.Instances) : [];
                const instancesWithScanTypes = instances.map(
                  (a) => ({
                    ...a,
                    ScanTypes: scanTypes
                  })
                );
                await task.trackProgress(
                  logSource,
                  "describe instances length=" + instances.length
                );
                const filteredValidEc2Instances = await filterValidEC2Instances(
                  instancesWithScanTypes,
                  targetAccountId,
                  targetRegion,
                  discoveryTaskId,
                  tagConfig,
                  ec2Client
                );
                const { skippedInstances, filterInfo } = filteredValidEc2Instances;
                let filteredInstances = filteredValidEc2Instances.instances;
                await saveBulkResourcesToDb(skippedInstances, dynamodbClient1);
                const filterInfoStr = Object.entries(filterInfo).map(([k, v]) => `${k}=${v}`).join(",");
                await task.trackProgress(
                  logSource,
                  "filter instances details: " + filterInfoStr
                );
                if (samplingProvision.isSamplingEnabled(parameters)) {
                  const sampledFilteredInstances = await filterInstancesBySampleGroupId(
                    filteredInstances,
                    targetAccountId,
                    targetRegion,
                    discoveryTaskId,
                    GroupsCount,
                    LeadersCount
                  );
                  filteredInstances = sampledFilteredInstances.instances;
                  await saveBulkResourcesToDb(
                    sampledFilteredInstances.skippedInstances,
                    dynamodbClient1
                  );
                }
                const { saveResult, errors } = await saveInstances(
                  {
                    instances: filteredInstances,
                    targetAccountId,
                    targetRegion,
                    discoveryTaskId
                  },
                  { dynamodbClient: dynamodbClient1, sqsClient },
                  !!instanceIdFilter
                );
                await task.trackProgress(
                  logSource,
                  "save instances result=: " + Object.entries(saveResult).map(([k, v]) => `${k}=${v}`).join(",")
                );
                if (errors.length) {
                  for (const error of errors) {
                    await task.trackProgress(
                      logSource,
                      error.id + "-> save instances failed, " + error.message
                    );
                    await task.trackProgress(logSource, error.stack.slice(0, 1024));
                  }
                  return false;
                }
                if (nextMarker) {
                  await task.updateTaskContext(nextMarker);
                }
              } catch (e) {
                await task.trackProgress(
                  logSource,
                  "describe & save instances failed, " + e.message
                );
                await task.trackProgress(logSource, e.stack.slice(0, 1024));
                return false;
              }
            } while (nextMarker && !task.isTimedOut);
            return true;
          }

          // src/lambda/code/task/taskManager.ts
          var import_client_dynamodb7 = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb6 = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/task/taskStatus.ts
          var TaskStatus = {
            Ready: "Ready",
            InProgress: "InProgress",
            Completed: "Completed",
            Failed: "Failed",
            TimedOut: "TimedOut"
          };

          // src/lambda/code/task/taskManager.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var DEFAULT_EXPIRY = 3600;
          var LogLineBatchSize = 10;
          var dynamoDbClient = new import_client_dynamodb7.DynamoDBClient({
            region: process.env.AWS_REGION || "us-east-1"
          });
          var documentClient = import_lib_dynamodb6.DynamoDBDocumentClient.from(dynamoDbClient);
          function getNormalisedDateTime() {
            const d = /* @__PURE__ */ new Date();
            const size = Number(process.env.NORMALIZED_TIMESTAMP_LENGTH || "13");
            return d.toISOString().slice(0, size).replace(/[-:T]/g, "_");
          }
          var DurableTask = class _DurableTask {
            logBatch = [];
            Time;
            isTimedOut = false;
            opts;
            constructor({
              taskId,
              taskDetails,
              tableName
            }) {
              this.opts = { tableName, taskId };
              Object.freeze(this.opts);
              Object.assign(this, taskDetails);
            }
            async trackProgress(source, logLine) {
              this.ensureTaskIsNotTimedOut();
              const timeElapsed = Math.floor(Date.now() / 1e3) - (this.Time || 0);
              const log = `[${source}, ${timeElapsed}s] ${logLine.toString()}`;
              console.log(log);
              this.logBatch.push(log);
              if (this.logBatch.length > LogLineBatchSize) {
                const ss = this.logBatch;
                this.logBatch = [];
                await this.__saveProgress(ss);
              }
            }
            async __saveProgress(batch = this.logBatch) {
              if (!batch.length) return;
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #listAttribute = list_append(#listAttribute, :newItems), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#listAttribute": "TaskProgress",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":newItems": batch,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb6.UpdateCommand(params));
            }
            async updateTaskStatus(status) {
              if (!TaskStatus[status])
                throw new Error("unknown status " + status);
              this.ensureTaskIsNotTimedOut();
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #statusAttribute = :status, #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#statusAttribute": "TaskStatus",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":status": status,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              if (status === TaskStatus.InProgress) {
                params.UpdateExpression += ", RetryAttempts = RetryAttempts + :val";
                params.ExpressionAttributeValues[":val"] = 1;
              }
              await documentClient.send(new import_lib_dynamodb6.UpdateCommand(params));
              if (status === TaskStatus.TimedOut) {
                this.isTimedOut = true;
              }
            }
            ensureTaskIsNotTimedOut() {
              if (this.isTimedOut) {
                throw new Error(
                  "Cannot update task status since it is in timed-out state"
                );
              }
            }
            async updateTaskContext(data) {
              this.ensureTaskIsNotTimedOut();
              if (typeof data === "string") data = [data];
              else throw new Error("Only strings or lists of strings are allowed");
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #stateInfoAttribute = list_append(#stateInfoAttribute, :data), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#stateInfoAttribute": "TaskContext",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":data": data,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb6.UpdateCommand(params));
            }
            async __load() {
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                ConsistentRead: true
              };
              const dbItem = await documentClient.send(new import_lib_dynamodb6.GetCommand(params));
              Object.assign(this, dbItem.Item);
            }
            async __save(task) {
              const params = {
                TableName: this.opts.tableName,
                Item: task,
                ConditionExpression: "attribute_not_exists(TaskId)"
              };
              await documentClient.send(new import_lib_dynamodb6.PutCommand(params));
              Object.assign(this, task);
            }
            static async loadTaskById(taskId, opts) {
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId,
                taskDetails: {}
              });
              await task.__load();
              return task;
            }
            static async createNewTask({
              region,
              accountId,
              taskInfo,
              opts,
              taskPrefix = "poll-inventory-task",
              taskSuffix = getNormalisedDateTime()
            }) {
              const id = `${taskPrefix}:${accountId}:${region}:${taskSuffix}`;
              const taskInput = {
                targetRegion: region,
                targetAccountId: accountId,
                ...taskInfo
              };
              const now = Math.floor(Date.now() / 1e3);
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId: id,
                taskDetails: {}
              });
              await task.__save({
                TaskId: id,
                TargetRegion: region,
                TargetAccount: accountId,
                TaskInput: JSON.stringify(taskInput),
                TaskContext: [],
                TaskStatus: TaskStatus.Ready,
                RetryAttempts: 0,
                TaskProgress: [],
                Time: now,
                ExpireAt: now + DEFAULT_EXPIRY,
                Source: process.env.SourceTableDiscoveryTask ?? "DISCOVERY_TASK"
              });
              return task;
            }
          };

          // src/lambda/code/taskWorker.ts
          var handler = async function(event) {
            if (event.Records) {
              event = JSON.parse(event.Records[0].body);
            }
            const taskId = event && event.TaskId;
            if (!taskId) {
              throw new Error("TaskId is required parameter");
            }
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const taskTimeout = parseInt(process.env.TaskTimeout ?? "275");
            const logSource = "TaskWorker";
            const task = await DurableTask.loadTaskById(taskId, { tableName });
            await task.trackProgress(logSource, "Retry Attempt is " + task.RetryAttempts);
            async function doTask() {
              const { TaskInput, TaskContext } = task;
              console.log(TaskInput, TaskContext);
              const input = JSON.parse(TaskInput);
              if (input.env && Object.keys(input.env).length > 0) {
                for (const envKey of Object.keys(input.env)) {
                  process.env[envKey] = input.env[envKey];
                }
                delete input.env;
              }
              await task.updateTaskStatus(TaskStatus.InProgress);
              await task.trackProgress(logSource, "Starting task execution");
              let success = false;
              if (taskId.startsWith("poll-ami-task") || taskId.startsWith("ami-event-discovery-task")) {
                success = await scheduledAmiDiscoveryTask({
                  ...input,
                  task,
                  lastState: TaskContext
                });
              } else {
                success = await scheduledDiscoveryTask({
                  ...input,
                  task,
                  lastState: TaskContext
                });
              }
              if (success) {
                await task.updateTaskStatus(TaskStatus.Completed);
              } else {
                await task.updateTaskStatus(TaskStatus.Failed);
              }
              return success;
            }
            async function doTaskSafe() {
              try {
                return await doTask();
              } catch (e) {
                await task.trackProgress(
                  logSource,
                  "Task Failed with Error: " + e.message
                );
                await task.updateTaskStatus(TaskStatus.Failed);
                return false;
              }
            }
            async function doTaskWithTimeout() {
              try {
                return await Promise.race([
                  doTaskSafe(),
                  new Promise((resolve, reject) => {
                    setTimeout(reject, taskTimeout * 1e3);
                  })
                ]);
              } catch (e) {
                await task.trackProgress(
                  logSource,
                  `Task timed out after ${taskTimeout} seconds`
                );
                await task.updateTaskStatus(TaskStatus.TimedOut);
                return false;
              }
            }
            const isSuccess = await doTaskWithTimeout();
            await task.__saveProgress();
            if (!isSuccess) {
              throw Error("Task with id " + taskId + " failed");
            }
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          DISCOVERY_TASK_TABLE: qualys-discovery-task
          IamTargetAccountRoleName: qualys-snapshot-scanner-cross-account
          InventoryStatesSkipped: SKIPPED
          InventoryStatesDiscovered: DISCOVERED
          ImageStatesDiscovered: DISCOVERED
          SourceTableInventory: RESOURCE_INVENTORY
          AmiSourceTableInventory: RESOURCE_INVENTORY
          SourceTableLogs: EVENT_LOGS
          SourceTableDiscoveryTask: DISCOVERY_TASK
          SourceTableEventDiscoveryTask: EVENT_DISCOVERY_TASK
          SourceTableAmiDiscoveryTask: DISCOVERY_TASK
          InventoryTableName: qualys-resource-inventory
          AmiInventoryTableName: qualys-resource-inventory
          SCAN_INTERVAL_HOURS:
            Ref: IntervalHours
          AMI_SCAN_INTERVAL_HOURS: "168"
          SNAPSHOT_NOTIFY_QUEUE_URL:
            Ref: SqsSnapshotNotifications
          DbTableEventLogs: qualys-event-logs
          SwCAEnabled:
            Ref: SwCA
          SecretEnabled:
            Ref: Secret
          SamplingEnabled:
            Ref: ScanSampling
          SamplingGroupScanPercentage:
            Ref: SamplingGroupScanPercentage
          QualysAppConfigTable: qualys-app-config
          SSMAccountsParameterName: /qualys/snapshot-scanner/account-config
          SERVICE_ACCOUNT_ID:
            Ref: AWS::AccountId
          SfnImageCopySnapshot: qualys-sfn-image-copy-snapshot
          ScanStatesPending: PENDING
          ScanStatusTableName: qualys-inventory-scan-status
          QUALYS_GATEWAY_URL:
            Ref: QEndpoint
          AUTH_TOKEN_SECRET_ARN:
            Ref: QualysSecrets
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-poll-task-worker
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 512
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 300
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaTaskWorkerSqsEventSourceQualysDiscoveryTaskQueue5470762A:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn:
        Fn::GetAtt:
          - DiscoveryTaskQueue
          - Arn
      FunctionName:
        Ref: LambdaTaskWorker
      ScalingConfig:
        MaximumConcurrency: 100
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  LambdaTaskScheduler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/taskGenerator.ts
          var taskGenerator_exports = {};
          __export(taskGenerator_exports, {
            handler: () => handler,
            taskGenerator: () => taskGenerator
          });
          module.exports = __toCommonJS(taskGenerator_exports);
          var import_client_sqs = require("@aws-sdk/client-sqs");

          // src/lambda/code/task/taskManager.ts
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/task/taskStatus.ts
          var TaskStatus = {
            Ready: "Ready",
            InProgress: "InProgress",
            Completed: "Completed",
            Failed: "Failed",
            TimedOut: "TimedOut"
          };

          // src/lambda/code/task/taskManager.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var DEFAULT_EXPIRY = 3600;
          var LogLineBatchSize = 10;
          var dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
            region: process.env.AWS_REGION || "us-east-1"
          });
          var documentClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
          function getNormalisedDateTime() {
            const d = /* @__PURE__ */ new Date();
            const size = Number(process.env.NORMALIZED_TIMESTAMP_LENGTH || "13");
            return d.toISOString().slice(0, size).replace(/[-:T]/g, "_");
          }
          var DurableTask = class _DurableTask {
            logBatch = [];
            Time;
            isTimedOut = false;
            opts;
            constructor({
              taskId,
              taskDetails,
              tableName
            }) {
              this.opts = { tableName, taskId };
              Object.freeze(this.opts);
              Object.assign(this, taskDetails);
            }
            async trackProgress(source, logLine) {
              this.ensureTaskIsNotTimedOut();
              const timeElapsed = Math.floor(Date.now() / 1e3) - (this.Time || 0);
              const log = `[${source}, ${timeElapsed}s] ${logLine.toString()}`;
              console.log(log);
              this.logBatch.push(log);
              if (this.logBatch.length > LogLineBatchSize) {
                const ss = this.logBatch;
                this.logBatch = [];
                await this.__saveProgress(ss);
              }
            }
            async __saveProgress(batch = this.logBatch) {
              if (!batch.length) return;
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #listAttribute = list_append(#listAttribute, :newItems), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#listAttribute": "TaskProgress",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":newItems": batch,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async updateTaskStatus(status) {
              if (!TaskStatus[status])
                throw new Error("unknown status " + status);
              this.ensureTaskIsNotTimedOut();
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #statusAttribute = :status, #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#statusAttribute": "TaskStatus",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":status": status,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              if (status === TaskStatus.InProgress) {
                params.UpdateExpression += ", RetryAttempts = RetryAttempts + :val";
                params.ExpressionAttributeValues[":val"] = 1;
              }
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
              if (status === TaskStatus.TimedOut) {
                this.isTimedOut = true;
              }
            }
            ensureTaskIsNotTimedOut() {
              if (this.isTimedOut) {
                throw new Error(
                  "Cannot update task status since it is in timed-out state"
                );
              }
            }
            async updateTaskContext(data) {
              this.ensureTaskIsNotTimedOut();
              if (typeof data === "string") data = [data];
              else throw new Error("Only strings or lists of strings are allowed");
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #stateInfoAttribute = list_append(#stateInfoAttribute, :data), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#stateInfoAttribute": "TaskContext",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":data": data,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async __load() {
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                ConsistentRead: true
              };
              const dbItem = await documentClient.send(new import_lib_dynamodb.GetCommand(params));
              Object.assign(this, dbItem.Item);
            }
            async __save(task) {
              const params = {
                TableName: this.opts.tableName,
                Item: task,
                ConditionExpression: "attribute_not_exists(TaskId)"
              };
              await documentClient.send(new import_lib_dynamodb.PutCommand(params));
              Object.assign(this, task);
            }
            static async loadTaskById(taskId, opts) {
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId,
                taskDetails: {}
              });
              await task.__load();
              return task;
            }
            static async createNewTask({
              region,
              accountId,
              taskInfo,
              opts,
              taskPrefix = "poll-inventory-task",
              taskSuffix = getNormalisedDateTime()
            }) {
              const id = `${taskPrefix}:${accountId}:${region}:${taskSuffix}`;
              const taskInput = {
                targetRegion: region,
                targetAccountId: accountId,
                ...taskInfo
              };
              const now = Math.floor(Date.now() / 1e3);
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId: id,
                taskDetails: {}
              });
              await task.__save({
                TaskId: id,
                TargetRegion: region,
                TargetAccount: accountId,
                TaskInput: JSON.stringify(taskInput),
                TaskContext: [],
                TaskStatus: TaskStatus.Ready,
                RetryAttempts: 0,
                TaskProgress: [],
                Time: now,
                ExpireAt: now + DEFAULT_EXPIRY,
                Source: process.env.SourceTableDiscoveryTask ?? "DISCOVERY_TASK"
              });
              return task;
            }
          };

          // src/lambda/code/taskGenerator.ts
          async function taskGenerator(event = {
            targetAccounts: [],
            targetRegions: []
          }) {
            const { targetRegions, targetAccounts, tagConfig } = event;
            [targetRegions, targetAccounts, tagConfig].forEach((v) => {
              if (!v) throw new Error("Invalid Parameters");
            });
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const region = process.env.AWS_REGION || "us-east-1";
            const taskQueueUrl = process.env.TASK_QUEUE;
            const taskPrefix = event.taskPrefix || process.env.TASK_PREFIX || "poll-inventory-task";
            const sqsClient = new import_client_sqs.SQSClient({ region });
            const todo = [];
            const taskIds = [];
            let success = 0;
            let failure = 0;
            for (const targetAccount of targetAccounts || []) {
              for (const targetRegion of targetRegions || []) {
                todo.push(async () => {
                  try {
                    const task = await DurableTask.createNewTask({
                      region: targetRegion,
                      accountId: targetAccount,
                      taskInfo: {
                        tagConfig,
                        env: { ScanPriority: process.env.ScanPriority }
                      },
                      opts: { tableName },
                      taskPrefix
                    });
                    const sendCommand = new import_client_sqs.SendMessageCommand({
                      QueueUrl: taskQueueUrl,
                      MessageBody: JSON.stringify({ TaskId: task.TaskId })
                    });
                    await sqsClient.send(sendCommand);
                    taskIds.push(task.TaskId);
                    success++;
                  } catch (e) {
                    console.error("Failed to create Task, Error " + e.message);
                    console.error(e.stack);
                    failure++;
                  }
                });
              }
            }
            const batchCount = 100;
            for (let i = 0; i < todo.length; i += batchCount) {
              const batch = todo.slice(i, i + batchCount).map((fn) => fn());
              await Promise.allSettled(batch);
            }
            return { success, failure, taskIds };
          }
          var handler = taskGenerator;
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler,
            taskGenerator
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          DISCOVERY_TASK_TABLE: qualys-discovery-task
          TASK_QUEUE:
            Ref: DiscoveryTaskQueue
          SourceTableDiscoveryTask: DISCOVERY_TASK
          TASK_PREFIX: poll-inventory-task
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-poll-task-scheduler
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 180
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaAmiTaskScheduler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/taskGenerator.ts
          var taskGenerator_exports = {};
          __export(taskGenerator_exports, {
            handler: () => handler,
            taskGenerator: () => taskGenerator
          });
          module.exports = __toCommonJS(taskGenerator_exports);
          var import_client_sqs = require("@aws-sdk/client-sqs");

          // src/lambda/code/task/taskManager.ts
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/task/taskStatus.ts
          var TaskStatus = {
            Ready: "Ready",
            InProgress: "InProgress",
            Completed: "Completed",
            Failed: "Failed",
            TimedOut: "TimedOut"
          };

          // src/lambda/code/task/taskManager.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var DEFAULT_EXPIRY = 3600;
          var LogLineBatchSize = 10;
          var dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
            region: process.env.AWS_REGION || "us-east-1"
          });
          var documentClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
          function getNormalisedDateTime() {
            const d = /* @__PURE__ */ new Date();
            const size = Number(process.env.NORMALIZED_TIMESTAMP_LENGTH || "13");
            return d.toISOString().slice(0, size).replace(/[-:T]/g, "_");
          }
          var DurableTask = class _DurableTask {
            logBatch = [];
            Time;
            isTimedOut = false;
            opts;
            constructor({
              taskId,
              taskDetails,
              tableName
            }) {
              this.opts = { tableName, taskId };
              Object.freeze(this.opts);
              Object.assign(this, taskDetails);
            }
            async trackProgress(source, logLine) {
              this.ensureTaskIsNotTimedOut();
              const timeElapsed = Math.floor(Date.now() / 1e3) - (this.Time || 0);
              const log = `[${source}, ${timeElapsed}s] ${logLine.toString()}`;
              console.log(log);
              this.logBatch.push(log);
              if (this.logBatch.length > LogLineBatchSize) {
                const ss = this.logBatch;
                this.logBatch = [];
                await this.__saveProgress(ss);
              }
            }
            async __saveProgress(batch = this.logBatch) {
              if (!batch.length) return;
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #listAttribute = list_append(#listAttribute, :newItems), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#listAttribute": "TaskProgress",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":newItems": batch,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async updateTaskStatus(status) {
              if (!TaskStatus[status])
                throw new Error("unknown status " + status);
              this.ensureTaskIsNotTimedOut();
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #statusAttribute = :status, #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#statusAttribute": "TaskStatus",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":status": status,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              if (status === TaskStatus.InProgress) {
                params.UpdateExpression += ", RetryAttempts = RetryAttempts + :val";
                params.ExpressionAttributeValues[":val"] = 1;
              }
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
              if (status === TaskStatus.TimedOut) {
                this.isTimedOut = true;
              }
            }
            ensureTaskIsNotTimedOut() {
              if (this.isTimedOut) {
                throw new Error(
                  "Cannot update task status since it is in timed-out state"
                );
              }
            }
            async updateTaskContext(data) {
              this.ensureTaskIsNotTimedOut();
              if (typeof data === "string") data = [data];
              else throw new Error("Only strings or lists of strings are allowed");
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #stateInfoAttribute = list_append(#stateInfoAttribute, :data), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#stateInfoAttribute": "TaskContext",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":data": data,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async __load() {
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                ConsistentRead: true
              };
              const dbItem = await documentClient.send(new import_lib_dynamodb.GetCommand(params));
              Object.assign(this, dbItem.Item);
            }
            async __save(task) {
              const params = {
                TableName: this.opts.tableName,
                Item: task,
                ConditionExpression: "attribute_not_exists(TaskId)"
              };
              await documentClient.send(new import_lib_dynamodb.PutCommand(params));
              Object.assign(this, task);
            }
            static async loadTaskById(taskId, opts) {
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId,
                taskDetails: {}
              });
              await task.__load();
              return task;
            }
            static async createNewTask({
              region,
              accountId,
              taskInfo,
              opts,
              taskPrefix = "poll-inventory-task",
              taskSuffix = getNormalisedDateTime()
            }) {
              const id = `${taskPrefix}:${accountId}:${region}:${taskSuffix}`;
              const taskInput = {
                targetRegion: region,
                targetAccountId: accountId,
                ...taskInfo
              };
              const now = Math.floor(Date.now() / 1e3);
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId: id,
                taskDetails: {}
              });
              await task.__save({
                TaskId: id,
                TargetRegion: region,
                TargetAccount: accountId,
                TaskInput: JSON.stringify(taskInput),
                TaskContext: [],
                TaskStatus: TaskStatus.Ready,
                RetryAttempts: 0,
                TaskProgress: [],
                Time: now,
                ExpireAt: now + DEFAULT_EXPIRY,
                Source: process.env.SourceTableDiscoveryTask ?? "DISCOVERY_TASK"
              });
              return task;
            }
          };

          // src/lambda/code/taskGenerator.ts
          async function taskGenerator(event = {
            targetAccounts: [],
            targetRegions: []
          }) {
            const { targetRegions, targetAccounts, tagConfig } = event;
            [targetRegions, targetAccounts, tagConfig].forEach((v) => {
              if (!v) throw new Error("Invalid Parameters");
            });
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const region = process.env.AWS_REGION || "us-east-1";
            const taskQueueUrl = process.env.TASK_QUEUE;
            const taskPrefix = event.taskPrefix || process.env.TASK_PREFIX || "poll-inventory-task";
            const sqsClient = new import_client_sqs.SQSClient({ region });
            const todo = [];
            const taskIds = [];
            let success = 0;
            let failure = 0;
            for (const targetAccount of targetAccounts || []) {
              for (const targetRegion of targetRegions || []) {
                todo.push(async () => {
                  try {
                    const task = await DurableTask.createNewTask({
                      region: targetRegion,
                      accountId: targetAccount,
                      taskInfo: {
                        tagConfig,
                        env: { ScanPriority: process.env.ScanPriority }
                      },
                      opts: { tableName },
                      taskPrefix
                    });
                    const sendCommand = new import_client_sqs.SendMessageCommand({
                      QueueUrl: taskQueueUrl,
                      MessageBody: JSON.stringify({ TaskId: task.TaskId })
                    });
                    await sqsClient.send(sendCommand);
                    taskIds.push(task.TaskId);
                    success++;
                  } catch (e) {
                    console.error("Failed to create Task, Error " + e.message);
                    console.error(e.stack);
                    failure++;
                  }
                });
              }
            }
            const batchCount = 100;
            for (let i = 0; i < todo.length; i += batchCount) {
              const batch = todo.slice(i, i + batchCount).map((fn) => fn());
              await Promise.allSettled(batch);
            }
            return { success, failure, taskIds };
          }
          var handler = taskGenerator;
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler,
            taskGenerator
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          DISCOVERY_TASK_TABLE: qualys-discovery-task
          TASK_QUEUE:
            Ref: DiscoveryTaskQueue
          SourceTableDiscoveryTask: DISCOVERY_TASK
          TASK_PREFIX: poll-ami-task
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-poll-ami-task-scheduler
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 180
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaEventBasedTaskScheduler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/taskGeneratorForEC2Event.ts
          var taskGeneratorForEC2Event_exports = {};
          __export(taskGeneratorForEC2Event_exports, {
            createTasksForEvent: () => createTasksForEvent,
            handler: () => handler
          });
          module.exports = __toCommonJS(taskGeneratorForEC2Event_exports);
          var import_client_sqs = require("@aws-sdk/client-sqs");

          // src/lambda/code/appConfig.ts
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_util_dynamodb = require("@aws-sdk/util-dynamodb");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/appConfig.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var AppConfig = class {
            opts;
            client;
            constructor({
              region,
              tableName,
              configId,
              isArray,
              lookupKey,
              lookupKeyIndex
            }) {
              this.opts = { tableName, configId, isArray, lookupKey, lookupKeyIndex };
              Object.freeze(this.opts);
              this.client = new import_client_dynamodb.DynamoDBClient({ region });
            }
            serialize(value) {
              return JSON.stringify({ __v: value });
            }
            deserialize(value) {
              return JSON.parse(value).__v;
            }
            async listCfg(args) {
              return this.getCfg(args);
            }
            async getCfg({
              nextMarker,
              maxItems = 100
            }) {
              const { Items, LastEvaluatedKey } = await this.query({
                keyExpression: this.opts.isArray || nextMarker ? this.getKeyExpression({ configId: this.opts.configId }) : this.getKeyExpression({ configId: this.opts.configId, idx: 0 }),
                nextMarker,
                maxItems
              });
              const result = Items.map((u) => this.deserialize(u.value));
              return {
                data: result.length > 1 || this.opts.isArray ? result : result[0],
                nextMarker: LastEvaluatedKey || false
              };
            }
            getKeyExpression(obj) {
              return {
                KeyConditionExpression: Object.keys(obj).map((j) => `${j} = :${j}`).join(" and "),
                ExpressionAttributeValues: (0, import_util_dynamodb.marshall)(
                  Object.fromEntries(Object.entries(obj).map(([k, v]) => [`:${k}`, v]))
                )
              };
            }
            async query({
              keyExpression,
              nextMarker,
              maxItems,
              ascOrder = true,
              indexName
            }) {
              const params = {
                TableName: this.opts.tableName,
                ...keyExpression,
                Limit: maxItems,
                ExclusiveStartKey: nextMarker ? (0, import_util_dynamodb.marshall)(nextMarker) : void 0,
                ConsistentRead: true,
                ScanIndexForward: ascOrder,
                IndexName: indexName
              };
              const command = new import_client_dynamodb.QueryCommand(params);
              const { Items, LastEvaluatedKey } = await this.client.send(command);
              return {
                Items: Items.map((item) => (0, import_util_dynamodb.unmarshall)(item)),
                LastEvaluatedKey: LastEvaluatedKey ? (0, import_util_dynamodb.unmarshall)(LastEvaluatedKey) : null
              };
            }
            async putCfg({ value }) {
              await this.appendCfg({ value, startFromZero: true });
              await this.destroyCfg({
                nextMarker: {
                  idx: Array.isArray(value) && value.length > 0 ? value.length - 1 : 0,
                  configId: this.opts.configId
                }
              });
            }
            async appendCfg({
              value,
              startFromZero = false
            }) {
              if (!Array.isArray(value)) value = [value];
              let startIndex = 0;
              if (!startFromZero) {
                const result = await this.query({
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId }),
                  maxItems: 1,
                  ascOrder: false
                });
                startIndex = result.Items.length > 0 ? result.Items[0].idx + 1 : 0;
              }
              const batchSize = 25;
              for (let i = 0; i < value.length; i += batchSize) {
                const batch = value.slice(i, i + batchSize);
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: batch.map((e, j) => ({
                      PutRequest: {
                        Item: (0, import_util_dynamodb.marshall)({
                          configId: this.opts.configId,
                          idx: i + j + startIndex,
                          value: this.serialize(e),
                          ...this.opts.lookupKey && e[this.opts.lookupKey] && {
                            uid: e[this.opts.lookupKey].toString()
                          }
                        })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              }
            }
            async destroyCfg({
              nextMarker
            }) {
              do {
                const { Items, LastEvaluatedKey } = await this.query({
                  nextMarker,
                  maxItems: 25,
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId })
                });
                nextMarker = LastEvaluatedKey;
                if (!Items.length) break;
                const command = new import_client_dynamodb.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: Items.map((e) => ({
                      DeleteRequest: {
                        Key: (0, import_util_dynamodb.marshall)({ configId: e.configId, idx: e.idx })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              } while (nextMarker);
            }
            async findCfg({ lookupValue }) {
              const { Items } = await this.query({
                keyExpression: this.getKeyExpression({
                  configId: this.opts.configId,
                  uid: lookupValue
                }),
                maxItems: 1,
                indexName: this.opts.lookupKeyIndex
              });
              const data = Items.map((u) => this.deserialize(u.value));
              return { data: data.length ? data[0] : void 0 };
            }
          };
          async function configActionHandler(event) {
            const {
              region = process.env.AWS_REGION || "us-east-1",
              configName,
              action,
              value,
              maxItems,
              nextMarker,
              lookupKey,
              lookupValue,
              lookupKeyIndex = process.env.LookupIndex || "byConfigValue"
            } = event;
            if (!["put", "get", "append", "destroy", "list", "find"].includes(action)) {
              throw new Error("Invalid value for field `action`");
            }
            const isArray = Array.isArray(value) || ["append", "list", "destroy"].includes(action);
            const tableName = process.env.QualysAppConfigTable || APP_CONFIG_TABLE;
            const cfg = new AppConfig({
              region,
              tableName,
              configId: configName,
              isArray,
              lookupKey,
              lookupKeyIndex
            });
            return cfg[`${action}Cfg`]({ nextMarker, value, lookupValue, maxItems });
          }

          // src/lambda/code/task/taskManager.ts
          var import_client_dynamodb2 = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/task/taskStatus.ts
          var TaskStatus = {
            Ready: "Ready",
            InProgress: "InProgress",
            Completed: "Completed",
            Failed: "Failed",
            TimedOut: "TimedOut"
          };

          // src/lambda/code/task/taskManager.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var DEFAULT_EXPIRY = 3600;
          var LogLineBatchSize = 10;
          var dynamoDbClient = new import_client_dynamodb2.DynamoDBClient({
            region: process.env.AWS_REGION || "us-east-1"
          });
          var documentClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
          function getNormalisedDateTime() {
            const d = /* @__PURE__ */ new Date();
            const size = Number(process.env.NORMALIZED_TIMESTAMP_LENGTH || "13");
            return d.toISOString().slice(0, size).replace(/[-:T]/g, "_");
          }
          var DurableTask = class _DurableTask {
            logBatch = [];
            Time;
            isTimedOut = false;
            opts;
            constructor({
              taskId,
              taskDetails,
              tableName
            }) {
              this.opts = { tableName, taskId };
              Object.freeze(this.opts);
              Object.assign(this, taskDetails);
            }
            async trackProgress(source, logLine) {
              this.ensureTaskIsNotTimedOut();
              const timeElapsed = Math.floor(Date.now() / 1e3) - (this.Time || 0);
              const log = `[${source}, ${timeElapsed}s] ${logLine.toString()}`;
              console.log(log);
              this.logBatch.push(log);
              if (this.logBatch.length > LogLineBatchSize) {
                const ss = this.logBatch;
                this.logBatch = [];
                await this.__saveProgress(ss);
              }
            }
            async __saveProgress(batch = this.logBatch) {
              if (!batch.length) return;
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #listAttribute = list_append(#listAttribute, :newItems), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#listAttribute": "TaskProgress",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":newItems": batch,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async updateTaskStatus(status) {
              if (!TaskStatus[status])
                throw new Error("unknown status " + status);
              this.ensureTaskIsNotTimedOut();
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #statusAttribute = :status, #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#statusAttribute": "TaskStatus",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":status": status,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              if (status === TaskStatus.InProgress) {
                params.UpdateExpression += ", RetryAttempts = RetryAttempts + :val";
                params.ExpressionAttributeValues[":val"] = 1;
              }
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
              if (status === TaskStatus.TimedOut) {
                this.isTimedOut = true;
              }
            }
            ensureTaskIsNotTimedOut() {
              if (this.isTimedOut) {
                throw new Error(
                  "Cannot update task status since it is in timed-out state"
                );
              }
            }
            async updateTaskContext(data) {
              this.ensureTaskIsNotTimedOut();
              if (typeof data === "string") data = [data];
              else throw new Error("Only strings or lists of strings are allowed");
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #stateInfoAttribute = list_append(#stateInfoAttribute, :data), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#stateInfoAttribute": "TaskContext",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":data": data,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async __load() {
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                ConsistentRead: true
              };
              const dbItem = await documentClient.send(new import_lib_dynamodb.GetCommand(params));
              Object.assign(this, dbItem.Item);
            }
            async __save(task) {
              const params = {
                TableName: this.opts.tableName,
                Item: task,
                ConditionExpression: "attribute_not_exists(TaskId)"
              };
              await documentClient.send(new import_lib_dynamodb.PutCommand(params));
              Object.assign(this, task);
            }
            static async loadTaskById(taskId, opts) {
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId,
                taskDetails: {}
              });
              await task.__load();
              return task;
            }
            static async createNewTask({
              region,
              accountId,
              taskInfo,
              opts,
              taskPrefix = "poll-inventory-task",
              taskSuffix = getNormalisedDateTime()
            }) {
              const id = `${taskPrefix}:${accountId}:${region}:${taskSuffix}`;
              const taskInput = {
                targetRegion: region,
                targetAccountId: accountId,
                ...taskInfo
              };
              const now = Math.floor(Date.now() / 1e3);
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId: id,
                taskDetails: {}
              });
              await task.__save({
                TaskId: id,
                TargetRegion: region,
                TargetAccount: accountId,
                TaskInput: JSON.stringify(taskInput),
                TaskContext: [],
                TaskStatus: TaskStatus.Ready,
                RetryAttempts: 0,
                TaskProgress: [],
                Time: now,
                ExpireAt: now + DEFAULT_EXPIRY,
                Source: process.env.SourceTableDiscoveryTask ?? "DISCOVERY_TASK"
              });
              return task;
            }
          };

          // src/lambda/code/taskGeneratorForEC2Event.ts
          async function isAccountValid(instanceRunEvent, memory) {
            const accountId = instanceRunEvent.account;
            if (memory && Object.hasOwn(memory, accountId)) return memory[accountId];
            const parameterName = process.env.SSMAccountsParameterName;
            const result = await configActionHandler({
              action: "find",
              configName: parameterName,
              lookupValue: accountId
            });
            memory[accountId] = !!(result && result.data);
            return memory[accountId];
          }
          function isRegionValid(instanceRunEvent, targetRegions) {
            return targetRegions.includes(instanceRunEvent.region);
          }
          function createGroupKey(instanceRunEvent) {
            const accountId = instanceRunEvent.account;
            const region = instanceRunEvent.region;
            const type = instanceRunEvent.detail && instanceRunEvent.detail.ImageId ? "image" : "instance";
            return `${accountId}##${region}##${type}`;
          }
          async function filterEvents(instanceRunEvents, targetRegions) {
            const validInstances = [];
            let invalidByAccount = 0;
            let invalidByRegion = 0;
            const accountIdMemory = {};
            for (const instanceRunEvent of instanceRunEvents) {
              if (!await isAccountValid(instanceRunEvent, accountIdMemory)) {
                invalidByAccount++;
                continue;
              }
              if (!isRegionValid(instanceRunEvent, targetRegions)) {
                invalidByRegion++;
                continue;
              }
              validInstances.push(instanceRunEvent);
            }
            return { validInstances, invalidByAccount, invalidByRegion };
          }
          function createGroupsByRegionAndAccount(validInstances) {
            const groups = {};
            for (const instanceEvent of validInstances) {
              const groupId = createGroupKey(instanceEvent);
              if (!groups[groupId]) groups[groupId] = [];
              groups[groupId].push(instanceEvent);
            }
            return groups;
          }
          async function createTask({
            groupId,
            batchId,
            group,
            tagConfig,
            tableName,
            additionalTaskInfo,
            taskPrefix
          }) {
            const [targetAccount, targetRegion] = groupId.split("##");
            const instanceIds = group.map((g) => g.detail["instance-id"]).filter((n) => n);
            const imageIds = group.map((g) => g.detail.ImageId).filter((n) => n);
            if (instanceIds.length) {
              return await DurableTask.createNewTask({
                region: targetRegion,
                accountId: targetAccount,
                taskInfo: {
                  tagConfig,
                  instanceIdFilter: instanceIds,
                  ...additionalTaskInfo
                },
                opts: { tableName },
                taskPrefix: taskPrefix || "event-discovery-task",
                taskSuffix: batchId
              });
            }
            if (imageIds.length) {
              return await DurableTask.createNewTask({
                region: targetRegion,
                accountId: targetAccount,
                taskInfo: {
                  tagConfig,
                  imageIdFilter: imageIds
                },
                opts: { tableName },
                taskPrefix: taskPrefix || "ami-event-discovery-task",
                taskSuffix: batchId
              });
            }
            return null;
          }
          async function createTasksForEvent(event) {
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const region = process.env.AWS_REGION || "us-east-1";
            const taskQueueUrl = process.env.TASK_QUEUE;
            const {
              sqsRecords = [],
              tagConfig,
              targetRegions,
              additionalTaskInfo = {},
              taskPrefix
            } = event;
            const instanceRunEvents = sqsRecords.map((r) => JSON.parse(r.body));
            const { validInstances, invalidByAccount, invalidByRegion } = await filterEvents(instanceRunEvents, targetRegions);
            console.log(
              "Instance Event Count =",
              instanceRunEvents.length,
              "Instances with valid account =",
              validInstances.length,
              "Instance with invalid accounts",
              invalidByAccount,
              "Instance with invalid regions",
              invalidByRegion
            );
            const batchId = Date.now();
            if (!validInstances.length) {
              return {
                error: "No action taken since none of the instances are valid",
                success: false,
                result: []
              };
            }
            const groups = createGroupsByRegionAndAccount(validInstances);
            const sqsClient = new import_client_sqs.SQSClient({ region });
            const result = [];
            for (const [groupId, group] of Object.entries(groups)) {
              const task = await createTask({
                groupId,
                group,
                batchId,
                tagConfig,
                tableName,
                additionalTaskInfo,
                taskPrefix
              });
              const sendCommand = new import_client_sqs.SendMessageCommand({
                QueueUrl: taskQueueUrl,
                MessageBody: JSON.stringify({ TaskId: task.TaskId })
              });
              await sqsClient.send(sendCommand);
              result.push(task.TaskId);
            }
            return { error: null, success: true, result, taskIds: result };
          }
          var handler = createTasksForEvent;
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            createTasksForEvent,
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          DISCOVERY_TASK_TABLE: qualys-discovery-task
          TASK_QUEUE:
            Ref: DiscoveryTaskQueue
          SourceTableDiscoveryTask: EVENT_DISCOVERY_TASK
          QualysAppConfigTable: qualys-app-config
          SSMAccountsParameterName: /qualys/snapshot-scanner/account-config
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-event-based-task-scheduler
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 30
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaScheduledSfnCheck:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/scheduledSfnCheck.ts
          var scheduledSfnCheck_exports = {};
          __export(scheduledSfnCheck_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(scheduledSfnCheck_exports);
          var import_client_sfn = require("@aws-sdk/client-sfn");
          var region = process.env.AWS_REGION || "us-east-1";
          var sfnClient = new import_client_sfn.SFNClient({ region });
          var StateMachineParallelLimits = {
            "qualys-sfn-copy-snapshot": 20
          };
          var handleErrors = async (e, params) => {
            console.error(e);
            try {
              await sfnClient.send(
                new import_client_sfn.SendTaskFailureCommand({
                  taskToken: params.TaskToken,
                  error: e.toString()
                })
              );
            } catch (error) {
              console.error("Failed to send task failure:", error);
            }
          };
          var sfnCheck = async function(params, context) {
            console.log("params", JSON.stringify(params));
            try {
              const ACCOUNT_ID = context.invokedFunctionArn.split(":")[4];
              const MaxExecutions = StateMachineParallelLimits[params.SfnName];
              const MAX_ITERATIONS = 10;
              let i = 0;
              let executions = [];
              let nextToken;
              do {
                const result = await sfnClient.send(
                  new import_client_sfn.ListExecutionsCommand({
                    stateMachineArn: `arn:${process.env.AWS_PARTITION}:states:${region}:${ACCOUNT_ID}:stateMachine:${params.SfnName}`,
                    maxResults: 1e3,
                    statusFilter: "RUNNING",
                    nextToken
                  })
                );
                if (result.executions) {
                  executions = [...executions, ...result.executions];
                }
                nextToken = result.nextToken;
                i += 1;
              } while (nextToken != null && i < MAX_ITERATIONS);
              const filteredExecutions = executions.filter(
                (execution) => execution.executionArn?.includes(params.Region) && execution.executionArn.includes(params.TargetAccount)
              );
              const CurrentExecutions = filteredExecutions.length;
              if (CurrentExecutions < MaxExecutions) {
                let retry = 0;
                let error = null;
                while (retry < 3) {
                  try {
                    await sfnClient.send(
                      new import_client_sfn.SendTaskSuccessCommand({
                        taskToken: params.TaskToken,
                        output: JSON.stringify({
                          CurrentExecutions,
                          MaxExecutions
                        })
                      })
                    );
                    return { continue: true };
                  } catch (e) {
                    retry += 1;
                    error = e;
                  }
                }
                if (error) throw error;
                return { continue: false };
              } else {
                return { continue: false };
              }
            } catch (e) {
              await handleErrors(e, params);
              return { continue: true, error: e };
            }
          };
          var handler = async function(event, context) {
            if (event.Records) {
              const params = JSON.parse(event.Records[0].body);
              const result = await sfnCheck(params, context);
              if (result.continue === false) {
                throw new Error("This will wait for 5 mins and then retrigger");
              }
            }
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-util-scheduled-sfn-check
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      ReservedConcurrentExecutions: 1
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 15
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaScheduledSfnCheckSqsEventSourceQualysScheduleSfnQueue08C506CF:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn:
        Fn::GetAtt:
          - ScheduleSfnQueue
          - Arn
      FunctionName:
        Ref: LambdaScheduledSfnCheck
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  LambdaPostProcessScan:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/postProcessScan.ts
          var postProcessScan_exports = {};
          __export(postProcessScan_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(postProcessScan_exports);
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_client_sfn = require("@aws-sdk/client-sfn");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/lib/awsUtils.ts
          var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
          var import_client_sts = require("@aws-sdk/client-sts");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/awsUtils.ts
          var cachedSecrets = {};
          if (process.env.SKIP_CACHE_EVICTION_INTERVAL !== "true") {
            setInterval(() => cachedSecrets = {}, 3e5);
          }
          async function loadSecret(secretArn) {
            if (cachedSecrets[secretArn]) {
              return cachedSecrets[secretArn];
            }
            const secretsManagerClient = new import_client_secrets_manager.SecretsManagerClient({
              region: process.env.AWS_REGION
            });
            const secretValue = await secretsManagerClient.send(
              new import_client_secrets_manager.GetSecretValueCommand({ SecretId: secretArn })
            );
            const secret = JSON.parse(secretValue.SecretString ?? "");
            cachedSecrets[secretArn] = secret;
            return secret;
          }

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/outputFileName.ts
          var import_crypto2 = require("crypto");

          // node_modules/jwt-decode/build/esm/index.js
          var InvalidTokenError = class extends Error {
          };
          InvalidTokenError.prototype.name = "InvalidTokenError";
          function b64DecodeUnicode(str) {
            return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
              let code = p.charCodeAt(0).toString(16).toUpperCase();
              if (code.length < 2) {
                code = "0" + code;
              }
              return "%" + code;
            }));
          }
          function base64UrlDecode(str) {
            let output = str.replace(/-/g, "+").replace(/_/g, "/");
            switch (output.length % 4) {
              case 0:
                break;
              case 2:
                output += "==";
                break;
              case 3:
                output += "=";
                break;
              default:
                throw new Error("base64 string is not of the correct length");
            }
            try {
              return b64DecodeUnicode(output);
            } catch (err) {
              return atob(output);
            }
          }
          function jwtDecode(token, options) {
            if (typeof token !== "string") {
              throw new InvalidTokenError("Invalid token specified: must be a string");
            }
            options || (options = {});
            const pos = options.header === true ? 0 : 1;
            const part = token.split(".")[pos];
            if (typeof part !== "string") {
              throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
            }
            let decoded;
            try {
              decoded = base64UrlDecode(part);
            } catch (e) {
              throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
            }
            try {
              return JSON.parse(decoded);
            } catch (e) {
              throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
            }
          }

          // node_modules/uuid/dist/esm/regex.js
          var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

          // node_modules/uuid/dist/esm/validate.js
          function validate(uuid) {
            return typeof uuid === "string" && regex_default.test(uuid);
          }
          var validate_default = validate;

          // node_modules/uuid/dist/esm/parse.js
          function parse(uuid) {
            if (!validate_default(uuid)) {
              throw TypeError("Invalid UUID");
            }
            let v;
            return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
          }
          var parse_default = parse;

          // node_modules/uuid/dist/esm/stringify.js
          var byteToHex = [];
          for (let i = 0; i < 256; ++i) {
            byteToHex.push((i + 256).toString(16).slice(1));
          }
          function unsafeStringify(arr, offset = 0) {
            return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
          }

          // node_modules/uuid/dist/esm/v35.js
          function stringToBytes(str) {
            str = unescape(encodeURIComponent(str));
            const bytes = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i) {
              bytes[i] = str.charCodeAt(i);
            }
            return bytes;
          }
          var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
          var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
          function v35(version, hash, value, namespace, buf, offset) {
            const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
            const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
            if (typeof namespace === "string") {
              namespace = parse_default(namespace);
            }
            if (namespace?.length !== 16) {
              throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            }
            let bytes = new Uint8Array(16 + valueBytes.length);
            bytes.set(namespaceBytes);
            bytes.set(valueBytes, namespaceBytes.length);
            bytes = hash(bytes);
            bytes[6] = bytes[6] & 15 | version;
            bytes[8] = bytes[8] & 63 | 128;
            if (buf) {
              offset = offset || 0;
              for (let i = 0; i < 16; ++i) {
                buf[offset + i] = bytes[i];
              }
              return buf;
            }
            return unsafeStringify(bytes);
          }

          // node_modules/uuid/dist/esm/sha1.js
          var import_crypto = require("crypto");
          function sha1(bytes) {
            if (Array.isArray(bytes)) {
              bytes = Buffer.from(bytes);
            } else if (typeof bytes === "string") {
              bytes = Buffer.from(bytes, "utf8");
            }
            return (0, import_crypto.createHash)("sha1").update(bytes).digest();
          }
          var sha1_default = sha1;

          // node_modules/uuid/dist/esm/v5.js
          function v5(value, namespace, buf, offset) {
            return v35(80, sha1_default, value, namespace, buf, offset);
          }
          v5.DNS = DNS;
          v5.URL = URL;
          var v5_default = v5;

          // src/lambda/code/lib/outputFileName.ts
          var getOutputFileName = ({
            ResourceId,
            ScanType,
            FileName,
            AuthToken
          }) => {
            let Decoded = FileName || (0, import_crypto2.randomUUID)();
            if (FileName != null && !FileName.endsWith(".log")) {
              Decoded = `${ResourceId}-${ScanType}-${FileName}`;
            }
            let MasifPath = Decoded;
            if (FileName != null && FileName.endsWith("SecretResult.json.xz")) {
              const decoded = jwtDecode(AuthToken);
              const customerId = decoded.subscriptionUuid;
              const MASIF_UUID = "c8240a8d-223c-4a8b-95a1-d6463ab0eaa8";
              MasifPath = v5_default(Decoded + customerId, MASIF_UUID);
            }
            let DestPath = `/qflow/snapshot/v1/multipart/upload/${MasifPath}`;
            if (Decoded.endsWith(".log")) {
              DestPath = `/qflow/snapshot-logs/v1/multipart/upload/${MasifPath}`;
            }
            return {
              DestPath,
              Decoded
            };
          };

          // src/lambda/code/lib/retry.ts
          async function retryAsyncFunction(fn, retries_left = 3) {
            try {
              return await fn();
            } catch (e) {
              if (retries_left >= 0) {
                return retryAsyncFunction(fn, retries_left - 1);
              }
              throw e;
            }
          }

          // src/lambda/code/postProcessScan.ts
          var ScanStatusTableName = process.env.ScanStatusTableName ?? RESOURCE_INVENTORY_SCAN_STATUS_TABLE;
          var InventoryTableName = process.env.InventoryTableName ?? RESOURCE_INVENTORY_TABLE;
          var MAX_SCAN_ATTEMPTS = parseInt(process.env.MAX_SCAN_ATTEMPTS || "2");
          var fetchCurrentScanStatus = async ({ ResourceId }, { ddbDocClient }) => {
            const { Items } = await ddbDocClient.send(
              new import_lib_dynamodb.QueryCommand({
                TableName: ScanStatusTableName,
                KeyConditionExpression: "ResourceId = :uid",
                ExpressionAttributeValues: {
                  ":uid": ResourceId
                },
                ProjectionExpression: "ResourceId, ScanType, ResultFileName, ScanStatus",
                ConsistentRead: true
                // Since this lambda might get triggerred right after updating state, we want most up-to date info
              })
            );
            return Items;
          };
          var fetchResourceInventory = async ({ ResourceId }, { ddbDocClient }) => {
            const { Item } = await ddbDocClient.send(
              new import_lib_dynamodb.GetCommand({
                TableName: InventoryTableName,
                Key: {
                  UID: ResourceId
                }
              })
            );
            return Item;
          };
          var triggerNotifyQflowSfn = async (parameters, { ACCOUNT_ID, sfnClient }) => {
            const stateMachineArn = `arn:${process.env.AWS_PARTITION}:states:${process.env.AWS_REGION}:${ACCOUNT_ID}:stateMachine:${process.env.SfnNotifyQflow}`;
            const startCommand = new import_client_sfn.StartExecutionCommand({
              stateMachineArn,
              input: JSON.stringify(parameters)
            });
            const execution = await sfnClient.send(startCommand);
            const executionArn = execution.executionArn;
            console.log(`Trigger sfn with execution arn ${executionArn}`);
          };
          var updateInventoryScanStatus = async ({
            ResourceId,
            ScanType,
            ScanStatus,
            ResultFileName,
            ScanAttempts,
            StateReason
          }, { ddbDocClient }) => {
            if (ScanStatus === "SCAN_COMPLETED" /* ScanCompleted */ || ScanAttempts >= MAX_SCAN_ATTEMPTS - 1) {
              const params = { ScanStatus };
              if (StateReason) {
                params.StateReason = StateReason;
              }
              if (ResultFileName) {
                params.ResultFileName = ResultFileName;
              }
              const UpdateExpression = Object.keys(params).map((key) => `${key} = :${key}`).join(", ");
              const ExpressionAttributeValues = Object.fromEntries(
                Object.entries(params).map(([k, v]) => [`:${k}`, v])
              );
              await ddbDocClient.send(
                new import_lib_dynamodb.UpdateCommand({
                  TableName: ScanStatusTableName,
                  Key: {
                    ResourceId,
                    ScanType
                  },
                  ExpressionAttributeValues,
                  UpdateExpression: `SET ${UpdateExpression}`
                })
              );
            }
          };
          var updateResourceInventoryStatus = async ({
            ResourceId,
            ResourceInventoryStatus,
            StateReason,
            MasifPaths
          }, { ddbDocClient }) => {
            const params = {
              ScannerState: ResourceInventoryStatus
            };
            if (StateReason) {
              params.StateReason = StateReason;
            }
            if (MasifPaths.length > 0) {
              params.MasifPaths = MasifPaths;
            }
            const UpdateExpression = Object.keys(params).map((key) => `${key} = :${key}`).join(", ");
            const ExpressionAttributeValues = Object.fromEntries(
              Object.entries(params).map(([k, v]) => [`:${k}`, v])
            );
            await ddbDocClient.send(
              new import_lib_dynamodb.UpdateCommand({
                TableName: InventoryTableName,
                Key: {
                  UID: ResourceId
                },
                ConditionExpression: "attribute_exists(UID)",
                ExpressionAttributeValues,
                UpdateExpression: `SET ${UpdateExpression}`
              })
            );
          };
          var evaluateActions = async ({
            CurrentScanStatuses,
            ResourceInventory
          }) => {
            console.log({
              CurrentScanStatuses,
              ResourceInventory
            });
            const PendingStatuses = CurrentScanStatuses.filter(
              (a) => a.ScanStatus === "PENDING" /* Pending */
            );
            const CompletedStatuses = CurrentScanStatuses.filter(
              (a) => a.ScanStatus === "SCAN_COMPLETED" /* ScanCompleted */
            );
            const FailedStatuses = CurrentScanStatuses.filter(
              (a) => a.ScanStatus === "SCAN_FAILED" /* ScanFailed */
            );
            if (PendingStatuses.length > 0) {
              return null;
            } else {
              const parameters = {
                DeleteSnapshot: true,
                ResourceInventory,
                ResourceInventoryStatus: "SCAN_COMPLETED" /* ScanCompleted */,
                NotifyQflow: false
              };
              if (CompletedStatuses.length > 0) {
                parameters.NotifyQflow = true;
                if (FailedStatuses.length > 0) {
                  if (FailedStatuses.find((a) => a.ScanType === "os")) {
                    parameters.ResourceInventoryStatus = "SCAN_FAILED" /* ScanFailed */;
                    parameters.NotifyQflow = false;
                  } else {
                    parameters.ResourceInventoryStatus = "PARTIAL_SUCCESS" /* PartialSuccess */;
                  }
                } else {
                  parameters.ResourceInventoryStatus = "SCAN_COMPLETED" /* ScanCompleted */;
                }
              } else {
                parameters.ResourceInventoryStatus = "SCAN_FAILED" /* ScanFailed */;
              }
              return parameters;
            }
          };
          var postProcessScan = async (params, context, {
            sfnClient,
            ddbDocClient
          }) => {
            console.log(params, context);
            const ACCOUNT_ID = context.invokedFunctionArn.split(":")[4];
            const {
              ResourceId,
              ScannerInstanceId,
              ScanType,
              ScanStatus,
              ScanAttempts,
              ResultFileName,
              CorrelationId,
              StateReason
            } = params;
            const ResourceInventory = await fetchResourceInventory(
              { ResourceId },
              { ddbDocClient }
            );
            if (ResourceInventory == null) {
              return {
                ResourceInventory
              };
            }
            await updateInventoryScanStatus(
              {
                ResourceId,
                ScanType,
                ScanStatus,
                ScanAttempts,
                ResultFileName,
                StateReason
              },
              { ddbDocClient }
            );
            const CurrentScanStatuses = await fetchCurrentScanStatus(
              { ResourceId },
              { ddbDocClient }
            );
            if (CurrentScanStatuses == null) {
              return {
                CurrentScanStatuses,
                ResourceInventory
              };
            }
            const parameters = await evaluateActions({
              CurrentScanStatuses,
              ResourceInventory
            });
            if (parameters) {
              let AuthToken = process.env.AUTH_TOKEN || "";
              if (!AuthToken) {
                const secretArn = process.env.AUTH_TOKEN_SECRET_ARN || "";
                AuthToken = (await loadSecret(secretArn)).QToken;
              }
              const ResultFileNames = CurrentScanStatuses.filter(
                (a) => a.ScanType !== "secret" && a.ResultFileName != null
              ).map(
                (a) => getOutputFileName({
                  ResourceId: a.ResourceId,
                  ScanType: a.ScanType,
                  FileName: a.ResultFileName,
                  AuthToken
                }).Decoded
              );
              await updateResourceInventoryStatus(
                {
                  ResourceId,
                  ResourceInventoryStatus: parameters.ResourceInventoryStatus,
                  StateReason,
                  MasifPaths: ResultFileNames
                },
                {
                  ddbDocClient
                }
              );
              const SecretsResultFileNames = CurrentScanStatuses.filter(
                (a) => a.ScanType === "secret" && a.ResultFileName != null
              ).map(
                (a) => getOutputFileName({
                  ResourceId: a.ResourceId,
                  ScanType: a.ScanType,
                  FileName: a.ResultFileName,
                  AuthToken
                }).Decoded
              );
              const SecretsResultFileName = SecretsResultFileNames.length > 0 ? SecretsResultFileNames[0] : null;
              await triggerNotifyQflowSfn(
                {
                  ...parameters,
                  ResultFileNames,
                  SecretsResultFileName,
                  ScannerInstanceId,
                  CorrelationId
                },
                {
                  ACCOUNT_ID,
                  sfnClient
                }
              );
            }
            return {
              CurrentScanStatuses,
              ResourceInventory,
              parameters
            };
          };
          var postProcessScanHandler = async function(params, context) {
            const sfnClient = new import_client_sfn.SFNClient({
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId: params.CorrelationId })
            });
            const dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
              region: process.env.AWS_REGION || "us-east-1",
              logger: getLogger({ CorrelationId: params.CorrelationId })
            });
            const ddbDocClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
            try {
              const response = await retryAsyncFunction(
                () => postProcessScan(params, context, {
                  sfnClient,
                  ddbDocClient
                })
              );
              if (params.TaskToken) {
                await sfnClient.send(
                  new import_client_sfn.SendTaskSuccessCommand({
                    taskToken: params.TaskToken,
                    output: JSON.stringify(response)
                  })
                );
              }
            } catch (e) {
              console.error(e);
              if (params.TaskToken) {
                const errorStr = e.toString();
                await sfnClient.send(
                  new import_client_sfn.SendTaskFailureCommand({
                    taskToken: params.TaskToken,
                    error: errorStr.substring(0, 200)
                  })
                );
              } else {
                throw e;
              }
            }
          };
          var handler = async function(event, context) {
            if (event.Records) {
              for (const record of event.Records) {
                const params = JSON.parse(record.body);
                await postProcessScanHandler(params, context);
              }
            }
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          SfnNotifyQflow: qualys-sfn-notify-qflow
          InventoryTableName: qualys-resource-inventory
          ScanStatusTableName: qualys-inventory-scan-status
          ScanStatesPending: PENDING
          ScanStatesCompleted: SCAN_COMPLETED
          ScanStatesFailed: SCAN_FAILED
          AUTH_TOKEN_SECRET_ARN:
            Ref: QualysSecrets
          MAX_SCAN_ATTEMPTS: "2"
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-post-process-scan
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 300
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaPostProcessScanSqsEventSourceQualysPostProcessScanQueueF2012A43:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn:
        Fn::GetAtt:
          - PostProcessScanQueue
          - Arn
      FunctionName:
        Ref: LambdaPostProcessScan
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  LambdaProcessScanS3Files:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __create = Object.create;
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __getProtoOf = Object.getPrototypeOf;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
            mod
          ));
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/processScanS3Files.ts
          var processScanS3Files_exports = {};
          __export(processScanS3Files_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(processScanS3Files_exports);
          var import_client_s32 = require("@aws-sdk/client-s3");

          // src/lambda/code/lib/apiClient.ts
          var import_querystring = __toESM(require("querystring"));

          // src/lambda/code/lib/awsUtils.ts
          var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
          var import_client_sts = require("@aws-sdk/client-sts");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/awsUtils.ts
          var cachedSecrets = {};
          if (process.env.SKIP_CACHE_EVICTION_INTERVAL !== "true") {
            setInterval(() => cachedSecrets = {}, 3e5);
          }
          async function loadSecret(secretArn) {
            if (cachedSecrets[secretArn]) {
              return cachedSecrets[secretArn];
            }
            const secretsManagerClient = new import_client_secrets_manager.SecretsManagerClient({
              region: process.env.AWS_REGION
            });
            const secretValue = await secretsManagerClient.send(
              new import_client_secrets_manager.GetSecretValueCommand({ SecretId: secretArn })
            );
            const secret = JSON.parse(secretValue.SecretString ?? "");
            cachedSecrets[secretArn] = secret;
            return secret;
          }

          // src/lambda/code/lib/httpReq.ts
          var import_https = __toESM(require("https"));

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/httpReq.ts
          var httpsReq = (url, method, headers = {}, body = null, logger = getLogger({})) => {
            logger.log("api call intiating", { url, method, headers });
            return new Promise((resolve, reject) => {
              const req = import_https.default.request(url, { method, headers }, (res) => {
                let responseData = "";
                res.on("data", (chunk) => {
                  responseData += chunk;
                });
                res.on("end", () => {
                  try {
                    if (res.statusCode != null && res.statusCode >= 200 && res.statusCode < 300) {
                      if (headers.accept === "application/json") {
                        const parsedData = JSON.parse(responseData);
                        logger.log("api call success", url, parsedData);
                        resolve(parsedData);
                      } else {
                        logger.log("api call success", url, responseData);
                        resolve(responseData);
                      }
                    } else {
                      logger.error("Api call failed:", url, res.statusCode, responseData);
                      reject(
                        new Error(
                          `Request failed with status code ${res.statusCode}: ${responseData}`
                        )
                      );
                    }
                  } catch (error) {
                    logger.error("Api call failed:", url, responseData);
                    reject(error);
                  }
                });
              });
              req.on("error", (err) => {
                reject(err);
              });
              if (body) {
                req.write(body);
              }
              req.end();
            });
          };

          // src/lambda/code/lib/apiClient.ts
          var ApiClient = class _ApiClient {
            constructor(baseUrl, authToken, logger) {
              this.baseUrl = baseUrl;
              this.authToken = authToken;
              this.logger = logger;
            }
            static async getInstance(logger) {
              const QUALYS_GATEWAY_URL = process.env.QUALYS_GATEWAY_URL || "";
              let AUTH_TOKEN = process.env.AUTH_TOKEN || "";
              if (!AUTH_TOKEN) {
                const secretArn = process.env.AUTH_TOKEN_SECRET_ARN || "";
                AUTH_TOKEN = (await loadSecret(secretArn)).QToken;
              }
              return new _ApiClient(
                QUALYS_GATEWAY_URL,
                AUTH_TOKEN,
                logger ?? getLogger({})
              );
            }
            _makeRequest(method, path, queryString = null, additionalHeaders = {}, rawBody = null) {
              let url = `${this.baseUrl}${path}`;
              if (queryString) {
                const qs = import_querystring.default.stringify(queryString);
                url += `?${qs}`;
              }
              return httpsReq(
                url,
                method,
                {
                  ...additionalHeaders,
                  Authorization: `Bearer ${this.authToken}`
                },
                rawBody,
                this.logger
              );
            }
            async makeRequest(method, path, queryString = null, additionalHeaders = {}, rawBody = null, retriesLeft = 3) {
              try {
                return await this._makeRequest(
                  method,
                  path,
                  queryString,
                  additionalHeaders,
                  rawBody
                );
              } catch (e) {
                console.error(e);
                if (retriesLeft === 0) {
                  throw e;
                }
                return this.makeRequest(
                  method,
                  path,
                  queryString,
                  additionalHeaders,
                  rawBody,
                  retriesLeft - 1
                );
              }
            }
            // GET method: takes path and query string
            get(path, queryString) {
              return this.makeRequest("GET", path, queryString, {
                accept: "application/json",
                "Content-Type": "application/json"
              });
            }
            // POST method: takes path and body
            post(path, body) {
              return this.makeRequest(
                "POST",
                path,
                null,
                {
                  accept: "application/json",
                  "Content-Type": "application/json"
                },
                JSON.stringify(body)
              );
            }
            readableToBuffer(res) {
              return new Promise((resolve, reject) => {
                res.setEncoding("binary");
                const data = [];
                res.on("data", function(chunk) {
                  const d = Buffer.from(chunk, "binary");
                  data.push(d);
                });
                res.on("end", function() {
                  const binary = Buffer.concat(data);
                  resolve(binary);
                });
                res.on("error", function(err) {
                  reject(err);
                });
              });
            }
          };

          // src/lambda/code/lib/outputFileName.ts
          var import_crypto2 = require("crypto");

          // node_modules/jwt-decode/build/esm/index.js
          var InvalidTokenError = class extends Error {
          };
          InvalidTokenError.prototype.name = "InvalidTokenError";
          function b64DecodeUnicode(str) {
            return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
              let code = p.charCodeAt(0).toString(16).toUpperCase();
              if (code.length < 2) {
                code = "0" + code;
              }
              return "%" + code;
            }));
          }
          function base64UrlDecode(str) {
            let output = str.replace(/-/g, "+").replace(/_/g, "/");
            switch (output.length % 4) {
              case 0:
                break;
              case 2:
                output += "==";
                break;
              case 3:
                output += "=";
                break;
              default:
                throw new Error("base64 string is not of the correct length");
            }
            try {
              return b64DecodeUnicode(output);
            } catch (err) {
              return atob(output);
            }
          }
          function jwtDecode(token, options) {
            if (typeof token !== "string") {
              throw new InvalidTokenError("Invalid token specified: must be a string");
            }
            options || (options = {});
            const pos = options.header === true ? 0 : 1;
            const part = token.split(".")[pos];
            if (typeof part !== "string") {
              throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
            }
            let decoded;
            try {
              decoded = base64UrlDecode(part);
            } catch (e) {
              throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
            }
            try {
              return JSON.parse(decoded);
            } catch (e) {
              throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
            }
          }

          // node_modules/uuid/dist/esm/regex.js
          var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

          // node_modules/uuid/dist/esm/validate.js
          function validate(uuid) {
            return typeof uuid === "string" && regex_default.test(uuid);
          }
          var validate_default = validate;

          // node_modules/uuid/dist/esm/parse.js
          function parse(uuid) {
            if (!validate_default(uuid)) {
              throw TypeError("Invalid UUID");
            }
            let v;
            return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
          }
          var parse_default = parse;

          // node_modules/uuid/dist/esm/stringify.js
          var byteToHex = [];
          for (let i = 0; i < 256; ++i) {
            byteToHex.push((i + 256).toString(16).slice(1));
          }
          function unsafeStringify(arr, offset = 0) {
            return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
          }

          // node_modules/uuid/dist/esm/v35.js
          function stringToBytes(str) {
            str = unescape(encodeURIComponent(str));
            const bytes = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i) {
              bytes[i] = str.charCodeAt(i);
            }
            return bytes;
          }
          var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
          var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
          function v35(version, hash, value, namespace, buf, offset) {
            const valueBytes = typeof value === "string" ? stringToBytes(value) : value;
            const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
            if (typeof namespace === "string") {
              namespace = parse_default(namespace);
            }
            if (namespace?.length !== 16) {
              throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            }
            let bytes = new Uint8Array(16 + valueBytes.length);
            bytes.set(namespaceBytes);
            bytes.set(valueBytes, namespaceBytes.length);
            bytes = hash(bytes);
            bytes[6] = bytes[6] & 15 | version;
            bytes[8] = bytes[8] & 63 | 128;
            if (buf) {
              offset = offset || 0;
              for (let i = 0; i < 16; ++i) {
                buf[offset + i] = bytes[i];
              }
              return buf;
            }
            return unsafeStringify(bytes);
          }

          // node_modules/uuid/dist/esm/sha1.js
          var import_crypto = require("crypto");
          function sha1(bytes) {
            if (Array.isArray(bytes)) {
              bytes = Buffer.from(bytes);
            } else if (typeof bytes === "string") {
              bytes = Buffer.from(bytes, "utf8");
            }
            return (0, import_crypto.createHash)("sha1").update(bytes).digest();
          }
          var sha1_default = sha1;

          // node_modules/uuid/dist/esm/v5.js
          function v5(value, namespace, buf, offset) {
            return v35(80, sha1_default, value, namespace, buf, offset);
          }
          v5.DNS = DNS;
          v5.URL = URL;
          var v5_default = v5;

          // src/lambda/code/lib/outputFileName.ts
          var getOutputFileName = ({
            ResourceId,
            ScanType,
            FileName,
            AuthToken
          }) => {
            let Decoded = FileName || (0, import_crypto2.randomUUID)();
            if (FileName != null && !FileName.endsWith(".log")) {
              Decoded = `${ResourceId}-${ScanType}-${FileName}`;
            }
            let MasifPath = Decoded;
            if (FileName != null && FileName.endsWith("SecretResult.json.xz")) {
              const decoded = jwtDecode(AuthToken);
              const customerId = decoded.subscriptionUuid;
              const MASIF_UUID = "c8240a8d-223c-4a8b-95a1-d6463ab0eaa8";
              MasifPath = v5_default(Decoded + customerId, MASIF_UUID);
            }
            let DestPath = `/qflow/snapshot/v1/multipart/upload/${MasifPath}`;
            if (Decoded.endsWith(".log")) {
              DestPath = `/qflow/snapshot-logs/v1/multipart/upload/${MasifPath}`;
            }
            return {
              DestPath,
              Decoded
            };
          };

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/lib/s3Upload.ts
          var import_client_s3 = require("@aws-sdk/client-s3");
          var formRange = (ContentLength, chunkSize) => {
            const ranges = [];
            let currentByte = 0;
            while (currentByte < ContentLength) {
              let endByte = currentByte + chunkSize;
              if (endByte > ContentLength) {
                endByte = ContentLength;
              }
              ranges.push(`bytes=${currentByte}-${endByte}`);
              currentByte += chunkSize;
            }
            return ranges;
          };
          var s3PartReadAndUpload = async ({
            Bucket,
            Key,
            Range,
            path
          }, { s3Client, apiClient }) => {
            const { Body } = await s3Client.send(
              new import_client_s3.GetObjectCommand({ Bucket, Key, Range })
            );
            const buffer = await apiClient.readableToBuffer(Body);
            console.log(buffer.length);
            await apiClient.makeRequest(
              "POST",
              path,
              null,
              {
                "Content-Type": "application/octet-stream",
                "Content-Length": buffer.length
              },
              buffer,
              10
            );
          };
          var s3MultiPartUpload = async ({
            Bucket,
            Key,
            DestPath,
            ChunkSize
          }, { s3Client, apiClient }) => {
            const Response = await s3Client.send(new import_client_s3.HeadObjectCommand({ Bucket, Key }));
            console.log(Response.ContentLength);
            const ranges = formRange(Response.ContentLength ?? 0, ChunkSize);
            let i = 0;
            while (i < ranges.length - 1) {
              await s3PartReadAndUpload(
                {
                  Bucket,
                  Key,
                  Range: ranges[i],
                  path: `${DestPath}/fragment/${i + 1}`
                },
                { s3Client, apiClient }
              );
              i += 1;
            }
            await s3PartReadAndUpload(
              {
                Bucket,
                Key,
                Range: ranges[i],
                path: `${DestPath}/fragment/${i + 1}/finalize`
              },
              { s3Client, apiClient }
            );
          };

          // src/lambda/code/processScanS3Files.ts
          var UPLOAD_CHUNK_SIZE = parseInt(
            process.env.UPLOAD_CHUNK_SIZE || (10 * 1024 * 1024).toString()
          );
          var processS3FilesByPrefix = async ({
            Prefix,
            ResourceId,
            ScanType,
            AuthToken,
            TargetRegion,
            DeleteAfterUpload
          }, { s3Client, apiClient }) => {
            const Items = await s3Client.send(
              new import_client_s32.ListObjectsV2Command({
                Bucket: getS3BucketName(TargetRegion),
                Prefix: `${Prefix}/${ResourceId}/${ScanType}`
              })
            );
            if (Items.Contents == null) {
              return;
            }
            for (const Content of Items.Contents) {
              if (Content.Key == null) {
                continue;
              }
              const KeySplit = Content.Key.split("/");
              const FileName = KeySplit[KeySplit.length - 1];
              const { DestPath } = getOutputFileName({
                ResourceId,
                ScanType,
                FileName,
                AuthToken
              });
              await s3MultiPartUpload(
                {
                  Bucket: getS3BucketName(TargetRegion),
                  Key: Content.Key,
                  DestPath,
                  ChunkSize: UPLOAD_CHUNK_SIZE
                },
                { s3Client, apiClient }
              );
              if (DeleteAfterUpload) {
                await s3Client.send(
                  new import_client_s32.DeleteObjectCommand({
                    Bucket: getS3BucketName(TargetRegion),
                    Key: Content.Key
                  })
                );
              }
            }
          };
          var processS3Files = async ({
            ResourceId,
            ScanType,
            TargetRegion,
            DeleteAfterUpload,
            CorrelationId
          }, { s3Client }) => {
            const apiClient = await ApiClient.getInstance(getLogger({ CorrelationId }));
            await processS3FilesByPrefix(
              {
                Prefix: "data",
                ResourceId,
                ScanType,
                AuthToken: apiClient.authToken,
                DeleteAfterUpload,
                TargetRegion
              },
              {
                s3Client,
                apiClient
              }
            );
            await processS3FilesByPrefix(
              {
                Prefix: "logs",
                ResourceId,
                ScanType,
                AuthToken: apiClient.authToken,
                DeleteAfterUpload,
                TargetRegion
              },
              {
                s3Client,
                apiClient
              }
            );
          };
          var handler = async ({
            ResourceId,
            ScanType,
            TargetRegion,
            ScanStatus,
            CorrelationId
          }) => {
            const s3Client = new import_client_s32.S3Client({
              region: TargetRegion,
              logger: getLogger({ CorrelationId })
            });
            await processS3Files(
              {
                ResourceId,
                ScanType,
                TargetRegion,
                CorrelationId,
                DeleteAfterUpload: ScanStatus === "SCAN_COMPLETED" /* ScanCompleted */
              },
              { s3Client }
            );
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          UPLOAD_CHUNK_SIZE: "10485760"
          QUALYS_GATEWAY_URL:
            Ref: QEndpoint
          AUTH_TOKEN_SECRET_ARN:
            Ref: QualysSecrets
          STACK_ID:
            Ref: AWS::StackId
          ScanStatesCompleted: SCAN_COMPLETED
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-process-scan-s3-files
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 512
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 900
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaOnDemandScanLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __create = Object.create;
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __getProtoOf = Object.getPrototypeOf;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
            mod
          ));
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/onDemandScanHandler.ts
          var onDemandScanHandler_exports = {};
          __export(onDemandScanHandler_exports, {
            handleOnDemandScanTaskSync: () => handleOnDemandScanTaskSync,
            handleScanInstancesTask: () => handleScanInstancesTask,
            handleScanInventoryTask: () => handleScanInventoryTask,
            handler: () => handler,
            pollForTasks: () => pollForTasks,
            submitTaskStatus: () => submitTaskStatus
          });
          module.exports = __toCommonJS(onDemandScanHandler_exports);

          // src/lambda/code/lib/apiClient.ts
          var import_querystring = __toESM(require("querystring"));

          // src/lambda/code/lib/awsUtils.ts
          var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
          var import_client_sts = require("@aws-sdk/client-sts");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/awsUtils.ts
          var cachedSecrets = {};
          if (process.env.SKIP_CACHE_EVICTION_INTERVAL !== "true") {
            setInterval(() => cachedSecrets = {}, 3e5);
          }
          async function loadSecret(secretArn) {
            if (cachedSecrets[secretArn]) {
              return cachedSecrets[secretArn];
            }
            const secretsManagerClient = new import_client_secrets_manager.SecretsManagerClient({
              region: process.env.AWS_REGION
            });
            const secretValue = await secretsManagerClient.send(
              new import_client_secrets_manager.GetSecretValueCommand({ SecretId: secretArn })
            );
            const secret = JSON.parse(secretValue.SecretString ?? "");
            cachedSecrets[secretArn] = secret;
            return secret;
          }

          // src/lambda/code/lib/httpReq.ts
          var import_https = __toESM(require("https"));

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/httpReq.ts
          var httpsReq = (url, method, headers = {}, body = null, logger = getLogger({})) => {
            logger.log("api call intiating", { url, method, headers });
            return new Promise((resolve, reject) => {
              const req = import_https.default.request(url, { method, headers }, (res) => {
                let responseData = "";
                res.on("data", (chunk) => {
                  responseData += chunk;
                });
                res.on("end", () => {
                  try {
                    if (res.statusCode != null && res.statusCode >= 200 && res.statusCode < 300) {
                      if (headers.accept === "application/json") {
                        const parsedData = JSON.parse(responseData);
                        logger.log("api call success", url, parsedData);
                        resolve(parsedData);
                      } else {
                        logger.log("api call success", url, responseData);
                        resolve(responseData);
                      }
                    } else {
                      logger.error("Api call failed:", url, res.statusCode, responseData);
                      reject(
                        new Error(
                          `Request failed with status code ${res.statusCode}: ${responseData}`
                        )
                      );
                    }
                  } catch (error) {
                    logger.error("Api call failed:", url, responseData);
                    reject(error);
                  }
                });
              });
              req.on("error", (err) => {
                reject(err);
              });
              if (body) {
                req.write(body);
              }
              req.end();
            });
          };

          // src/lambda/code/lib/apiClient.ts
          var ApiClient = class _ApiClient {
            constructor(baseUrl, authToken, logger) {
              this.baseUrl = baseUrl;
              this.authToken = authToken;
              this.logger = logger;
            }
            static async getInstance(logger) {
              const QUALYS_GATEWAY_URL = process.env.QUALYS_GATEWAY_URL || "";
              let AUTH_TOKEN = process.env.AUTH_TOKEN || "";
              if (!AUTH_TOKEN) {
                const secretArn = process.env.AUTH_TOKEN_SECRET_ARN || "";
                AUTH_TOKEN = (await loadSecret(secretArn)).QToken;
              }
              return new _ApiClient(
                QUALYS_GATEWAY_URL,
                AUTH_TOKEN,
                logger ?? getLogger({})
              );
            }
            _makeRequest(method, path, queryString = null, additionalHeaders = {}, rawBody = null) {
              let url = `${this.baseUrl}${path}`;
              if (queryString) {
                const qs = import_querystring.default.stringify(queryString);
                url += `?${qs}`;
              }
              return httpsReq(
                url,
                method,
                {
                  ...additionalHeaders,
                  Authorization: `Bearer ${this.authToken}`
                },
                rawBody,
                this.logger
              );
            }
            async makeRequest(method, path, queryString = null, additionalHeaders = {}, rawBody = null, retriesLeft = 3) {
              try {
                return await this._makeRequest(
                  method,
                  path,
                  queryString,
                  additionalHeaders,
                  rawBody
                );
              } catch (e) {
                console.error(e);
                if (retriesLeft === 0) {
                  throw e;
                }
                return this.makeRequest(
                  method,
                  path,
                  queryString,
                  additionalHeaders,
                  rawBody,
                  retriesLeft - 1
                );
              }
            }
            // GET method: takes path and query string
            get(path, queryString) {
              return this.makeRequest("GET", path, queryString, {
                accept: "application/json",
                "Content-Type": "application/json"
              });
            }
            // POST method: takes path and body
            post(path, body) {
              return this.makeRequest(
                "POST",
                path,
                null,
                {
                  accept: "application/json",
                  "Content-Type": "application/json"
                },
                JSON.stringify(body)
              );
            }
            readableToBuffer(res) {
              return new Promise((resolve, reject) => {
                res.setEncoding("binary");
                const data = [];
                res.on("data", function(chunk) {
                  const d = Buffer.from(chunk, "binary");
                  data.push(d);
                });
                res.on("end", function() {
                  const binary = Buffer.concat(data);
                  resolve(binary);
                });
                res.on("error", function(err) {
                  reject(err);
                });
              });
            }
          };

          // src/lambda/code/lib/deleteDDBTaskWorker.ts
          var import_client_dynamodb3 = require("@aws-sdk/client-dynamodb");
          var import_client_ssm = require("@aws-sdk/client-ssm");
          var import_lib_dynamodb2 = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/taskGenerator.ts
          var import_client_sqs = require("@aws-sdk/client-sqs");

          // src/lambda/code/task/taskManager.ts
          var import_client_dynamodb = require("@aws-sdk/client-dynamodb");
          var import_lib_dynamodb = require("@aws-sdk/lib-dynamodb");

          // src/lambda/code/task/taskStatus.ts
          var TaskStatus = {
            Ready: "Ready",
            InProgress: "InProgress",
            Completed: "Completed",
            Failed: "Failed",
            TimedOut: "TimedOut"
          };

          // src/lambda/code/task/taskManager.ts
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var DEFAULT_EXPIRY = 3600;
          var LogLineBatchSize = 10;
          var dynamoDbClient = new import_client_dynamodb.DynamoDBClient({
            region: process.env.AWS_REGION || "us-east-1"
          });
          var documentClient = import_lib_dynamodb.DynamoDBDocumentClient.from(dynamoDbClient);
          function getNormalisedDateTime() {
            const d = /* @__PURE__ */ new Date();
            const size = Number(process.env.NORMALIZED_TIMESTAMP_LENGTH || "13");
            return d.toISOString().slice(0, size).replace(/[-:T]/g, "_");
          }
          var DurableTask = class _DurableTask {
            logBatch = [];
            Time;
            isTimedOut = false;
            opts;
            constructor({
              taskId,
              taskDetails,
              tableName
            }) {
              this.opts = { tableName, taskId };
              Object.freeze(this.opts);
              Object.assign(this, taskDetails);
            }
            async trackProgress(source, logLine) {
              this.ensureTaskIsNotTimedOut();
              const timeElapsed = Math.floor(Date.now() / 1e3) - (this.Time || 0);
              const log = `[${source}, ${timeElapsed}s] ${logLine.toString()}`;
              console.log(log);
              this.logBatch.push(log);
              if (this.logBatch.length > LogLineBatchSize) {
                const ss = this.logBatch;
                this.logBatch = [];
                await this.__saveProgress(ss);
              }
            }
            async __saveProgress(batch = this.logBatch) {
              if (!batch.length) return;
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #listAttribute = list_append(#listAttribute, :newItems), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#listAttribute": "TaskProgress",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":newItems": batch,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async updateTaskStatus(status) {
              if (!TaskStatus[status])
                throw new Error("unknown status " + status);
              this.ensureTaskIsNotTimedOut();
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #statusAttribute = :status, #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#statusAttribute": "TaskStatus",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":status": status,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              if (status === TaskStatus.InProgress) {
                params.UpdateExpression += ", RetryAttempts = RetryAttempts + :val";
                params.ExpressionAttributeValues[":val"] = 1;
              }
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
              if (status === TaskStatus.TimedOut) {
                this.isTimedOut = true;
              }
            }
            ensureTaskIsNotTimedOut() {
              if (this.isTimedOut) {
                throw new Error(
                  "Cannot update task status since it is in timed-out state"
                );
              }
            }
            async updateTaskContext(data) {
              this.ensureTaskIsNotTimedOut();
              if (typeof data === "string") data = [data];
              else throw new Error("Only strings or lists of strings are allowed");
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                UpdateExpression: "SET #stateInfoAttribute = list_append(#stateInfoAttribute, :data), #lastUpdatedField = :LastUpdatedAt",
                ExpressionAttributeNames: {
                  "#stateInfoAttribute": "TaskContext",
                  "#lastUpdatedField": "LastUpdatedAt"
                },
                ExpressionAttributeValues: {
                  ":data": data,
                  ":LastUpdatedAt": Math.floor(Date.now() / 1e3)
                }
              };
              await documentClient.send(new import_lib_dynamodb.UpdateCommand(params));
            }
            async __load() {
              const params = {
                TableName: this.opts.tableName,
                Key: { TaskId: this.opts.taskId },
                ConsistentRead: true
              };
              const dbItem = await documentClient.send(new import_lib_dynamodb.GetCommand(params));
              Object.assign(this, dbItem.Item);
            }
            async __save(task) {
              const params = {
                TableName: this.opts.tableName,
                Item: task,
                ConditionExpression: "attribute_not_exists(TaskId)"
              };
              await documentClient.send(new import_lib_dynamodb.PutCommand(params));
              Object.assign(this, task);
            }
            static async loadTaskById(taskId, opts) {
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId,
                taskDetails: {}
              });
              await task.__load();
              return task;
            }
            static async createNewTask({
              region,
              accountId,
              taskInfo,
              opts,
              taskPrefix = "poll-inventory-task",
              taskSuffix = getNormalisedDateTime()
            }) {
              const id = `${taskPrefix}:${accountId}:${region}:${taskSuffix}`;
              const taskInput = {
                targetRegion: region,
                targetAccountId: accountId,
                ...taskInfo
              };
              const now = Math.floor(Date.now() / 1e3);
              const task = new _DurableTask({
                tableName: opts.tableName,
                taskId: id,
                taskDetails: {}
              });
              await task.__save({
                TaskId: id,
                TargetRegion: region,
                TargetAccount: accountId,
                TaskInput: JSON.stringify(taskInput),
                TaskContext: [],
                TaskStatus: TaskStatus.Ready,
                RetryAttempts: 0,
                TaskProgress: [],
                Time: now,
                ExpireAt: now + DEFAULT_EXPIRY,
                Source: process.env.SourceTableDiscoveryTask ?? "DISCOVERY_TASK"
              });
              return task;
            }
          };

          // src/lambda/code/taskGenerator.ts
          async function taskGenerator(event = {
            targetAccounts: [],
            targetRegions: []
          }) {
            const { targetRegions, targetAccounts, tagConfig } = event;
            [targetRegions, targetAccounts, tagConfig].forEach((v) => {
              if (!v) throw new Error("Invalid Parameters");
            });
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const region = process.env.AWS_REGION || "us-east-1";
            const taskQueueUrl = process.env.TASK_QUEUE;
            const taskPrefix = event.taskPrefix || process.env.TASK_PREFIX || "poll-inventory-task";
            const sqsClient = new import_client_sqs.SQSClient({ region });
            const todo = [];
            const taskIds = [];
            let success = 0;
            let failure = 0;
            for (const targetAccount of targetAccounts || []) {
              for (const targetRegion of targetRegions || []) {
                todo.push(async () => {
                  try {
                    const task = await DurableTask.createNewTask({
                      region: targetRegion,
                      accountId: targetAccount,
                      taskInfo: {
                        tagConfig,
                        env: { ScanPriority: process.env.ScanPriority }
                      },
                      opts: { tableName },
                      taskPrefix
                    });
                    const sendCommand = new import_client_sqs.SendMessageCommand({
                      QueueUrl: taskQueueUrl,
                      MessageBody: JSON.stringify({ TaskId: task.TaskId })
                    });
                    await sqsClient.send(sendCommand);
                    taskIds.push(task.TaskId);
                    success++;
                  } catch (e) {
                    console.error("Failed to create Task, Error " + e.message);
                    console.error(e.stack);
                    failure++;
                  }
                });
              }
            }
            const batchCount = 100;
            for (let i = 0; i < todo.length; i += batchCount) {
              const batch = todo.slice(i, i + batchCount).map((fn) => fn());
              await Promise.allSettled(batch);
            }
            return { success, failure, taskIds };
          }

          // src/lambda/code/taskGeneratorForEC2Event.ts
          var import_client_sqs2 = require("@aws-sdk/client-sqs");

          // src/lambda/code/appConfig.ts
          var import_client_dynamodb2 = require("@aws-sdk/client-dynamodb");
          var import_util_dynamodb = require("@aws-sdk/util-dynamodb");
          process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = "1";
          var AppConfig = class {
            opts;
            client;
            constructor({
              region,
              tableName,
              configId,
              isArray,
              lookupKey,
              lookupKeyIndex
            }) {
              this.opts = { tableName, configId, isArray, lookupKey, lookupKeyIndex };
              Object.freeze(this.opts);
              this.client = new import_client_dynamodb2.DynamoDBClient({ region });
            }
            serialize(value) {
              return JSON.stringify({ __v: value });
            }
            deserialize(value) {
              return JSON.parse(value).__v;
            }
            async listCfg(args) {
              return this.getCfg(args);
            }
            async getCfg({
              nextMarker,
              maxItems = 100
            }) {
              const { Items, LastEvaluatedKey } = await this.query({
                keyExpression: this.opts.isArray || nextMarker ? this.getKeyExpression({ configId: this.opts.configId }) : this.getKeyExpression({ configId: this.opts.configId, idx: 0 }),
                nextMarker,
                maxItems
              });
              const result = Items.map((u) => this.deserialize(u.value));
              return {
                data: result.length > 1 || this.opts.isArray ? result : result[0],
                nextMarker: LastEvaluatedKey || false
              };
            }
            getKeyExpression(obj) {
              return {
                KeyConditionExpression: Object.keys(obj).map((j) => `${j} = :${j}`).join(" and "),
                ExpressionAttributeValues: (0, import_util_dynamodb.marshall)(
                  Object.fromEntries(Object.entries(obj).map(([k, v]) => [`:${k}`, v]))
                )
              };
            }
            async query({
              keyExpression,
              nextMarker,
              maxItems,
              ascOrder = true,
              indexName
            }) {
              const params = {
                TableName: this.opts.tableName,
                ...keyExpression,
                Limit: maxItems,
                ExclusiveStartKey: nextMarker ? (0, import_util_dynamodb.marshall)(nextMarker) : void 0,
                ConsistentRead: true,
                ScanIndexForward: ascOrder,
                IndexName: indexName
              };
              const command = new import_client_dynamodb2.QueryCommand(params);
              const { Items, LastEvaluatedKey } = await this.client.send(command);
              return {
                Items: Items.map((item) => (0, import_util_dynamodb.unmarshall)(item)),
                LastEvaluatedKey: LastEvaluatedKey ? (0, import_util_dynamodb.unmarshall)(LastEvaluatedKey) : null
              };
            }
            async putCfg({ value }) {
              await this.appendCfg({ value, startFromZero: true });
              await this.destroyCfg({
                nextMarker: {
                  idx: Array.isArray(value) && value.length > 0 ? value.length - 1 : 0,
                  configId: this.opts.configId
                }
              });
            }
            async appendCfg({
              value,
              startFromZero = false
            }) {
              if (!Array.isArray(value)) value = [value];
              let startIndex = 0;
              if (!startFromZero) {
                const result = await this.query({
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId }),
                  maxItems: 1,
                  ascOrder: false
                });
                startIndex = result.Items.length > 0 ? result.Items[0].idx + 1 : 0;
              }
              const batchSize = 25;
              for (let i = 0; i < value.length; i += batchSize) {
                const batch = value.slice(i, i + batchSize);
                const command = new import_client_dynamodb2.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: batch.map((e, j) => ({
                      PutRequest: {
                        Item: (0, import_util_dynamodb.marshall)({
                          configId: this.opts.configId,
                          idx: i + j + startIndex,
                          value: this.serialize(e),
                          ...this.opts.lookupKey && e[this.opts.lookupKey] && {
                            uid: e[this.opts.lookupKey].toString()
                          }
                        })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              }
            }
            async destroyCfg({
              nextMarker
            }) {
              do {
                const { Items, LastEvaluatedKey } = await this.query({
                  nextMarker,
                  maxItems: 25,
                  keyExpression: this.getKeyExpression({ configId: this.opts.configId })
                });
                nextMarker = LastEvaluatedKey;
                if (!Items.length) break;
                const command = new import_client_dynamodb2.BatchWriteItemCommand({
                  RequestItems: {
                    [this.opts.tableName]: Items.map((e) => ({
                      DeleteRequest: {
                        Key: (0, import_util_dynamodb.marshall)({ configId: e.configId, idx: e.idx })
                      }
                    }))
                  }
                });
                await this.client.send(command);
              } while (nextMarker);
            }
            async findCfg({ lookupValue }) {
              const { Items } = await this.query({
                keyExpression: this.getKeyExpression({
                  configId: this.opts.configId,
                  uid: lookupValue
                }),
                maxItems: 1,
                indexName: this.opts.lookupKeyIndex
              });
              const data = Items.map((u) => this.deserialize(u.value));
              return { data: data.length ? data[0] : void 0 };
            }
          };
          async function configActionHandler(event) {
            const {
              region = process.env.AWS_REGION || "us-east-1",
              configName,
              action,
              value,
              maxItems,
              nextMarker,
              lookupKey,
              lookupValue,
              lookupKeyIndex = process.env.LookupIndex || "byConfigValue"
            } = event;
            if (!["put", "get", "append", "destroy", "list", "find"].includes(action)) {
              throw new Error("Invalid value for field `action`");
            }
            const isArray = Array.isArray(value) || ["append", "list", "destroy"].includes(action);
            const tableName = process.env.QualysAppConfigTable || APP_CONFIG_TABLE;
            const cfg = new AppConfig({
              region,
              tableName,
              configId: configName,
              isArray,
              lookupKey,
              lookupKeyIndex
            });
            return cfg[`${action}Cfg`]({ nextMarker, value, lookupValue, maxItems });
          }

          // src/lambda/code/taskGeneratorForEC2Event.ts
          async function isAccountValid(instanceRunEvent, memory) {
            const accountId = instanceRunEvent.account;
            if (memory && Object.hasOwn(memory, accountId)) return memory[accountId];
            const parameterName = process.env.SSMAccountsParameterName;
            const result = await configActionHandler({
              action: "find",
              configName: parameterName,
              lookupValue: accountId
            });
            memory[accountId] = !!(result && result.data);
            return memory[accountId];
          }
          function isRegionValid(instanceRunEvent, targetRegions) {
            return targetRegions.includes(instanceRunEvent.region);
          }
          function createGroupKey(instanceRunEvent) {
            const accountId = instanceRunEvent.account;
            const region = instanceRunEvent.region;
            const type = instanceRunEvent.detail && instanceRunEvent.detail.ImageId ? "image" : "instance";
            return `${accountId}##${region}##${type}`;
          }
          async function filterEvents(instanceRunEvents, targetRegions) {
            const validInstances = [];
            let invalidByAccount = 0;
            let invalidByRegion = 0;
            const accountIdMemory = {};
            for (const instanceRunEvent of instanceRunEvents) {
              if (!await isAccountValid(instanceRunEvent, accountIdMemory)) {
                invalidByAccount++;
                continue;
              }
              if (!isRegionValid(instanceRunEvent, targetRegions)) {
                invalidByRegion++;
                continue;
              }
              validInstances.push(instanceRunEvent);
            }
            return { validInstances, invalidByAccount, invalidByRegion };
          }
          function createGroupsByRegionAndAccount(validInstances) {
            const groups = {};
            for (const instanceEvent of validInstances) {
              const groupId = createGroupKey(instanceEvent);
              if (!groups[groupId]) groups[groupId] = [];
              groups[groupId].push(instanceEvent);
            }
            return groups;
          }
          async function createTask({
            groupId,
            batchId,
            group,
            tagConfig,
            tableName,
            additionalTaskInfo,
            taskPrefix
          }) {
            const [targetAccount, targetRegion] = groupId.split("##");
            const instanceIds = group.map((g) => g.detail["instance-id"]).filter((n) => n);
            const imageIds = group.map((g) => g.detail.ImageId).filter((n) => n);
            if (instanceIds.length) {
              return await DurableTask.createNewTask({
                region: targetRegion,
                accountId: targetAccount,
                taskInfo: {
                  tagConfig,
                  instanceIdFilter: instanceIds,
                  ...additionalTaskInfo
                },
                opts: { tableName },
                taskPrefix: taskPrefix || "event-discovery-task",
                taskSuffix: batchId
              });
            }
            if (imageIds.length) {
              return await DurableTask.createNewTask({
                region: targetRegion,
                accountId: targetAccount,
                taskInfo: {
                  tagConfig,
                  imageIdFilter: imageIds
                },
                opts: { tableName },
                taskPrefix: taskPrefix || "ami-event-discovery-task",
                taskSuffix: batchId
              });
            }
            return null;
          }
          async function createTasksForEvent(event) {
            const tableName = process.env.DISCOVERY_TASK_TABLE;
            const region = process.env.AWS_REGION || "us-east-1";
            const taskQueueUrl = process.env.TASK_QUEUE;
            const {
              sqsRecords = [],
              tagConfig,
              targetRegions,
              additionalTaskInfo = {},
              taskPrefix
            } = event;
            const instanceRunEvents = sqsRecords.map((r) => JSON.parse(r.body));
            const { validInstances, invalidByAccount, invalidByRegion } = await filterEvents(instanceRunEvents, targetRegions);
            console.log(
              "Instance Event Count =",
              instanceRunEvents.length,
              "Instances with valid account =",
              validInstances.length,
              "Instance with invalid accounts",
              invalidByAccount,
              "Instance with invalid regions",
              invalidByRegion
            );
            const batchId = Date.now();
            if (!validInstances.length) {
              return {
                error: "No action taken since none of the instances are valid",
                success: false,
                result: []
              };
            }
            const groups = createGroupsByRegionAndAccount(validInstances);
            const sqsClient = new import_client_sqs2.SQSClient({ region });
            const result = [];
            for (const [groupId, group] of Object.entries(groups)) {
              const task = await createTask({
                groupId,
                group,
                batchId,
                tagConfig,
                tableName,
                additionalTaskInfo,
                taskPrefix
              });
              const sendCommand = new import_client_sqs2.SendMessageCommand({
                QueueUrl: taskQueueUrl,
                MessageBody: JSON.stringify({ TaskId: task.TaskId })
              });
              await sqsClient.send(sendCommand);
              result.push(task.TaskId);
            }
            return { error: null, success: true, result, taskIds: result };
          }

          // src/lambda/code/lib/deleteDDBTaskWorker.ts
          var DeleteDDBTaskWorker = class {
            region;
            logger;
            dynamoDBClient;
            documentClient;
            ssmClient;
            inventoryTableName;
            inventoryScanStatusTableName;
            accountsTableName;
            targetAccountId;
            targetRegion;
            targetInstances;
            targetInstanceIds;
            constructor({
              correlationId,
              targetAccountId,
              targetRegion,
              targetInstanceIds,
              targetInstances
            }) {
              this.region = process.env.AWS_REGION || "us-east-1";
              this.logger = getLogger({ CorrelationId: correlationId });
              this.dynamoDBClient = new import_client_dynamodb3.DynamoDBClient({ region: this.region });
              this.documentClient = import_lib_dynamodb2.DynamoDBDocumentClient.from(this.dynamoDBClient);
              this.ssmClient = new import_client_ssm.SSMClient({ region: this.region });
              this.inventoryTableName = process.env.InventoryTableName || RESOURCE_INVENTORY_TABLE;
              this.inventoryScanStatusTableName = process.env.ScanStatusTableName || RESOURCE_INVENTORY_SCAN_STATUS_TABLE;
              this.accountsTableName = process.env.ConfigTableName || APP_CONFIG_TABLE;
              this.targetAccountId = targetAccountId;
              this.targetRegion = targetRegion;
              this.targetInstances = targetInstances;
              this.targetInstanceIds = targetInstanceIds || (targetInstances || []).map((e) => e.instanceId);
            }
            createBatch(arr, batchSize) {
              const batches = [];
              for (let i = 0; i < arr.length; i += batchSize) {
                batches.push(arr.slice(i, i + batchSize));
              }
              return batches;
            }
            async getSelectedRegions() {
              const ssmScanParameterName = process.env.SSMScanParameterName;
              const { Parameter } = await this.ssmClient.send(
                new import_client_ssm.GetParameterCommand({ Name: ssmScanParameterName })
              );
              return JSON.parse(Parameter?.Value ?? "").regions.split(",").map((region) => region.trim());
            }
            async getTagConfig() {
              const ssmTagsParameterName = process.env.SSMTagsParameterName;
              const { Parameter } = await this.ssmClient.send(
                new import_client_ssm.GetParameterCommand({ Name: ssmTagsParameterName })
              );
              return JSON.parse(Parameter?.Value ?? "");
            }
            async deleteTableItems(tableName, items, Keys) {
              const batchLength = 25;
              let failed = 0;
              let succeeded = 0;
              for (const batch of this.createBatch(items, batchLength)) {
                await Promise.all(
                  batch.map(async (item) => {
                    try {
                      const Key = {};
                      for (const key of Keys) {
                        Key[key] = item[key];
                      }
                      await this.documentClient.send(
                        new import_lib_dynamodb2.DeleteCommand({
                          TableName: tableName,
                          Key
                        })
                      );
                      succeeded++;
                    } catch (e) {
                      console.error(e);
                      failed++;
                    }
                  })
                );
              }
              return {
                failed,
                succeeded
              };
            }
            async *listItems(tableName, Keys, filter) {
              let lastEvaluatedKey;
              while (true) {
                const params = {
                  TableName: tableName,
                  ProjectionExpression: Keys.join(","),
                  ExclusiveStartKey: lastEvaluatedKey
                };
                if (filter) {
                  params.FilterExpression = Object.keys(filter).map((key) => `${key} = :${key}`).join(" and ");
                  params.ExpressionAttributeValues = Object.fromEntries(
                    Object.entries(filter).map(([k, v]) => [`:${k}`, v])
                  );
                }
                const data = await this.documentClient.send(new import_lib_dynamodb2.ScanCommand(params));
                lastEvaluatedKey = data.LastEvaluatedKey;
                if (data.Items?.length) {
                  yield data.Items;
                }
                if (!lastEvaluatedKey) break;
              }
            }
            async listItemsById(tableName, idList) {
              const batchLength = 25;
              const res = [];
              for (let i = 0; i < idList.length; i += batchLength) {
                const batch = idList.slice(i, i + batchLength);
                const obj = await this.documentClient.send(
                  new import_lib_dynamodb2.BatchGetCommand({
                    RequestItems: {
                      [tableName]: {
                        Keys: batch.map((item) => ({ UID: item })),
                        AttributesToGet: ["UID", "TargetRegion", "TargetAccount"]
                      }
                    }
                  })
                );
                res.push(...obj.Responses[tableName]);
              }
              return res;
            }
            async runPollBasedScan(targetAccounts, targetRegions, tagConfig) {
              if (!tagConfig) tagConfig = await this.getTagConfig();
              if (!targetRegions) targetRegions = await this.getSelectedRegions();
              return await taskGenerator({
                targetRegions,
                targetAccounts,
                tagConfig,
                taskPrefix: "on-demand-scan-inventory"
              });
            }
            async runEventBasedScan(targetInstances, tagConfig) {
              if (!tagConfig) tagConfig = await this.getTagConfig();
              const regions = await this.getSelectedRegions();
              const payload = targetInstances.map(
                ({ TargetAccount, TargetRegion, UID }) => ({
                  body: JSON.stringify({
                    account: TargetAccount,
                    region: TargetRegion,
                    detail: { "instance-id": UID }
                  })
                })
              );
              const { taskIds } = await createTasksForEvent({
                tagConfig,
                targetRegions: regions,
                sqsRecords: payload,
                additionalTaskInfo: {
                  forceDisableInstanceGrouping: true,
                  env: { ScanPriority: process.env.ScanPriority }
                },
                taskPrefix: "on-demand-scan-instances"
              });
              return { taskIds, success: targetInstances.length, failure: 0 };
            }
            async retryAll() {
              for await (const data of this.listItems(this.inventoryTableName, ["UID"], {
                ResourceType: "Instance"
              })) {
                await this.deleteTableItems(this.inventoryTableName, data, ["UID"]);
              }
              let sA = 0;
              let fA = 0;
              const idA = [];
              for await (const accounts of this.listItems(
                this.accountsTableName,
                ["uid"],
                {
                  ResourceType: "Instance"
                }
              )) {
                const { success, failure, taskIds } = await this.runPollBasedScan(accounts);
                sA += success;
                fA += failure;
                idA.push(...taskIds);
              }
              return { success: sA, failure: fA, taskIds: idA };
            }
            async retryAccount() {
              if (!this.targetAccountId) throw new Error("targetAccountId is required");
              for await (const data of this.listItems(this.inventoryTableName, ["UID"], {
                TargetAccount: this.targetAccountId,
                ResourceType: "Instance"
              })) {
                await this.deleteTableItems(this.inventoryTableName, data, ["UID"]);
              }
              for await (const data of this.listItems(
                this.inventoryScanStatusTableName,
                ["ResourceId", "ScanType"],
                {
                  TargetAccount: this.targetAccountId,
                  ResourceType: "Instance"
                }
              )) {
                await this.deleteTableItems(this.inventoryScanStatusTableName, data, [
                  "ResourceId",
                  "ScanType"
                ]);
              }
              return await this.runPollBasedScan([this.targetAccountId]);
            }
            async retryRegion() {
              if (!this.targetAccountId) throw new Error("targetAccountId is required");
              if (!this.targetRegion) throw new Error("targetRegion is required");
              for await (const data of this.listItems(this.inventoryTableName, ["UID"], {
                TargetAccount: this.targetAccountId,
                TargetRegion: this.targetRegion,
                ResourceType: "Instance"
              })) {
                await this.deleteTableItems(this.inventoryTableName, data, ["UID"]);
              }
              for await (const data of this.listItems(
                this.inventoryScanStatusTableName,
                ["ResourceId", "ScanType"],
                {
                  TargetAccount: this.targetAccountId,
                  TargetRegion: this.targetRegion,
                  ResourceType: "Instance"
                }
              )) {
                await this.deleteTableItems(this.inventoryScanStatusTableName, data, [
                  "ResourceId",
                  "ScanType"
                ]);
              }
              return await this.runPollBasedScan(
                [this.targetAccountId],
                [this.targetRegion]
              );
            }
            async retryInstances(forceRun = false) {
              if (!Array.isArray(this.targetInstanceIds) || !this.targetInstanceIds.length)
                throw new Error("targetInstanceId(List<string>) is required");
              if (this.targetInstanceIds.length > 50)
                throw new Error("targetInstanceId list max 50");
              const tagConfig = await this.getTagConfig();
              let instanceInfo = await this.listItemsById(
                this.inventoryTableName,
                this.targetInstanceIds
              );
              const instancesInInventory = instanceInfo.map((u) => u.UID);
              for (const targetInstanceId of this.targetInstanceIds) {
                for await (const data of this.listItems(
                  this.inventoryScanStatusTableName,
                  ["ResourceId", "ScanType"],
                  {
                    ResourceId: targetInstanceId,
                    ResourceType: "Instance"
                  }
                )) {
                  await this.deleteTableItems(this.inventoryScanStatusTableName, data, [
                    "ResourceId",
                    "ScanType"
                  ]);
                }
              }
              await this.deleteTableItems(this.inventoryTableName, instanceInfo, ["UID"]);
              if (this.targetInstances && this.targetInstances.length > 0) {
                for (const info of instanceInfo) {
                  const eventInfo = this.targetInstances.find(
                    (e) => e.instanceId === info.UID
                  );
                  info.TargetAccount = eventInfo.accountId || info.TargetAccount;
                  info.TargetRegion = eventInfo.region || info.TargetRegion;
                }
              } else {
                instanceInfo = instanceInfo.filter(
                  (e) => e.TargetAccount && e.TargetRegion
                );
              }
              if (forceRun) {
                const missingInstances = this.targetInstances.filter((e) => !instancesInInventory.includes(e.instanceId)).map((e) => ({
                  UID: e.instanceId,
                  TargetRegion: e.region,
                  TargetAccount: e.accountId
                }));
                instanceInfo.push(...missingInstances);
                Object.assign(tagConfig, {
                  mustHaveTags: "",
                  anyInListTags: "",
                  noneInTheList: "",
                  noneOnVolume: ""
                });
              }
              return await this.runEventBasedScan(instanceInfo, tagConfig);
            }
          };

          // src/lambda/code/onDemandScanHandler.ts
          var MAX_TASK_AGE = 24 * 60 * 60 * 1e3;
          async function getHttpConfig(event) {
            const onDemandScanTaskSyncPath = process.env.ON_DEMAND_SCAN_SYNC_PATH || event.OnDemandSyncPath;
            const serviceAccountId = process.env.SERVICE_ACCOUNT_ID || "";
            return {
              onDemandScanTaskSyncPath,
              serviceAccountId
            };
          }
          async function pollForTasks(event) {
            const { onDemandScanTaskSyncPath, serviceAccountId } = await getHttpConfig(event);
            const apiClient = await ApiClient.getInstance();
            try {
              return await apiClient.get(onDemandScanTaskSyncPath, {
                cloudAccountId: serviceAccountId
              });
            } catch (e) {
              console.error("Could not fetch pending tasks");
              console.error(e);
              return [];
            }
          }
          async function submitTaskStatus(event, taskId, cloudTaskIds, error) {
            const { onDemandScanTaskSyncPath } = await getHttpConfig(event);
            const apiClient = await ApiClient.getInstance();
            return await apiClient.post(onDemandScanTaskSyncPath, {
              taskId,
              cloudTaskIds,
              syncStatus: error ? "Failed" : "Success"
            });
          }
          async function handleScanInventoryTask(taskParameters, correlationId) {
            const DEFAULT_VALUE = "$Default";
            const {
              parameters: { excludeTags, includeTags, requiredTags, includeRegions },
              targetAccountId
            } = taskParameters;
            const worker = new DeleteDDBTaskWorker({
              correlationId,
              targetAccountId
            });
            const defaultRegions = await worker.getSelectedRegions();
            function getUserSelectedRegions() {
              const usr = includeRegions.split(",").map((u) => u.trim()).filter((region) => {
                return defaultRegions.includes(region);
              });
              if (!usr.length) {
                throw new Error(
                  `No valid regions were selected, default=${defaultRegions.join(
                    ","
                  )}, selected=${includeRegions}`
                );
              }
              return usr;
            }
            const targetRegions = includeRegions === DEFAULT_VALUE ? defaultRegions : getUserSelectedRegions();
            const defaultTags = await worker.getTagConfig();
            const tagConfig = {
              mustHaveTags: requiredTags === DEFAULT_VALUE ? defaultTags.mustHaveTags : requiredTags,
              anyInListTags: includeTags === DEFAULT_VALUE ? defaultTags.anyInListTags : includeTags,
              noneInTheList: excludeTags === DEFAULT_VALUE ? defaultTags.noneInTheList : excludeTags,
              noneOnVolume: "",
              qualysTags: defaultTags.qualysTags
            };
            for (const targetRegion of targetRegions) {
              for await (const data of worker.listItems(
                worker.inventoryTableName,
                ["UID"],
                {
                  TargetAccount: targetAccountId,
                  TargetRegion: targetRegion,
                  ResourceType: "Instance"
                }
              )) {
                await worker.deleteTableItems(worker.inventoryTableName, data, ["UID"]);
              }
              for await (const data of worker.listItems(
                worker.inventoryScanStatusTableName,
                ["ResourceId", "ScanType"],
                {
                  TargetAccount: targetAccountId,
                  TargetRegion: targetRegion,
                  ResourceType: "Instance"
                }
              )) {
                await worker.deleteTableItems(worker.inventoryScanStatusTableName, data, [
                  "ResourceId",
                  "ScanType"
                ]);
              }
            }
            return await worker.runPollBasedScan(
              [targetAccountId],
              targetRegions,
              tagConfig
            );
          }
          async function handleScanInstancesTask(taskParameters, correlationId) {
            const {
              parameters: { instances }
            } = taskParameters;
            const worker = new DeleteDDBTaskWorker({
              correlationId,
              targetInstances: instances
            });
            return await worker.retryInstances(true);
          }
          async function handleOnDemandScanTaskSync(task) {
            const { id, correlationId, scanType, taskParameters, createdAt } = task;
            if (scanType !== "ON_DEMAND_SCAN") {
              const error = new Error(
                `Evaluating OnDemandTaskId: ${id}, unknown scanType: ${scanType}`
              );
              console.error(error);
              throw error;
            }
            const timeNow = Date.now();
            const timeDiff = timeNow - (typeof createdAt === "string" ? parseInt(createdAt) : createdAt);
            if (timeDiff > MAX_TASK_AGE) {
              const error = new Error(
                `Task with id ${id} was created at ${createdAt}, which is older than acceptable ${MAX_TASK_AGE}ms`
              );
              console.error(error);
              throw error;
            }
            console.log(
              "Evaluating OnDemandTaskId = ",
              id,
              "correlationId = ",
              correlationId
            );
            if (taskParameters.actionType === "SCAN_INVENTORY") {
              const { taskIds } = await handleScanInventoryTask(
                taskParameters,
                correlationId
              );
              return taskIds;
            } else if (taskParameters.actionType === "SCAN_INSTANCES") {
              const { taskIds } = await handleScanInstancesTask(
                taskParameters,
                correlationId
              );
              return taskIds ?? [];
            } else {
              console.error(
                `Evaluating OnDemandTaskId: ${id}, unknown actionType: ${taskParameters.actionType}`
              );
              return [];
            }
          }
          var handler = async (event) => {
            const tasks = await pollForTasks(event);
            if (tasks.length) {
              console.log(`Received ${tasks.length} tasks`);
              for (const task of tasks) {
                try {
                  const cloudTaskIds = await handleOnDemandScanTaskSync(task);
                  await submitTaskStatus(event, task.id, cloudTaskIds, null);
                } catch (err) {
                  console.error(err);
                  await submitTaskStatus(event, task.id, [], err);
                }
              }
            }
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handleOnDemandScanTaskSync,
            handleScanInstancesTask,
            handleScanInventoryTask,
            handler,
            pollForTasks,
            submitTaskStatus
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          SSMTagsParameterName: /qualys/snapshot-scanner/tags-config
          SSMScanParameterName: /qualys/snapshot-scanner/scan-config
          SSMAccountsParameterName: /qualys/snapshot-scanner/account-config
          ConfigTableName: qualys-app-config
          InventoryTableName: qualys-resource-inventory
          DISCOVERY_TASK_TABLE: qualys-discovery-task
          TASK_QUEUE:
            Ref: DiscoveryTaskQueue
          SourceTableDiscoveryTask: DISCOVERY_TASK
          QualysAppConfigTable: qualys-app-config
          NORMALIZED_TIMESTAMP_LENGTH: "19"
          ScanPriority: "100"
          QUALYS_GATEWAY_URL:
            Ref: QEndpoint
          ON_DEMAND_SCAN_SYNC_PATH: /qflow/gw-api-v1/snapshot-scanner/on-demand-scan-task
          AUTH_TOKEN_SECRET_ARN:
            Ref: QualysSecrets
          SERVICE_ACCOUNT_ID:
            Ref: AWS::AccountId
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-on-demand-scan
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 256
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 30
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaDownloadToS3:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __create = Object.create;
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __getProtoOf = Object.getPrototypeOf;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
            // If the importer is in node compatibility mode or this is not an ESM
            // file that has been converted to a CommonJS file using a Babel-
            // compatible transform (i.e. "__esModule" has not been set), then set
            // "default" to the CommonJS "module.exports" for node compatibility.
            isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
            mod
          ));
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/downloadToS3.ts
          var downloadToS3_exports = {};
          __export(downloadToS3_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(downloadToS3_exports);
          var import_client_s3 = require("@aws-sdk/client-s3");
          var import_https = __toESM(require("https"));

          // src/lambda/code/lib/logger.ts
          function getLogger(event) {
            const correlationId = event.CorrelationId || "CORRELATION_ID_NOT_SET";
            return {
              log: (...data) => console.log(correlationId, ...data),
              info: (...data) => console.info(correlationId, ...data),
              warn: (...data) => console.warn(correlationId, ...data),
              error: (...data) => console.error(correlationId, ...data),
              debug: (...data) => process.env.DEBUG === "true" && console.debug(correlationId, ...data)
            };
          }

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/downloadToS3.ts
          var messageToBuffer = (res) => {
            return new Promise((resolve, reject) => {
              res.setEncoding("binary");
              const data = [];
              res.on("data", function(chunk) {
                data.push(Buffer.from(chunk, "binary"));
              });
              res.on("end", function() {
                const binary = Buffer.concat(data);
                resolve(binary);
              });
              res.on("error", function(err) {
                reject(err);
              });
            });
          };
          var doesSameVersionExists = async ({ Key, Version, Region }, { s3Client }) => {
            try {
              const existing = await s3Client.send(
                new import_client_s3.HeadObjectCommand({
                  Bucket: getS3BucketName(Region),
                  Key
                })
              );
              if (existing && existing.Metadata) {
                console.log(existing.Metadata);
                const existingVersion = existing.Metadata.version;
                return existingVersion === Version;
              }
              return false;
            } catch (e) {
              console.log(e);
              return false;
            }
          };
          var uploadIncomingHttpToS3 = async ({
            res,
            Region,
            Dest,
            Metadata
          }, { s3Client }) => {
            const contentLengthStr = res.headers["content-length"];
            if (!contentLengthStr) {
              const buffer = await messageToBuffer(res);
              await s3Client.send(
                new import_client_s3.PutObjectCommand({
                  Bucket: getS3BucketName(Region),
                  Key: Dest,
                  Body: buffer,
                  Metadata
                })
              );
            } else {
              const contentLength = parseInt(contentLengthStr);
              await s3Client.send(
                new import_client_s3.PutObjectCommand({
                  Bucket: getS3BucketName(Region),
                  Key: Dest,
                  Body: res,
                  ContentLength: contentLength,
                  Metadata
                })
              );
            }
          };
          var downloadToS3 = async (event, { s3Client }) => {
            const { Url, Authorization, Dest, Method, DefaultRegion, Version } = event;
            if (Version) {
              if (await doesSameVersionExists(
                { Key: Dest, Version, Region: DefaultRegion || "us-east-1" },
                { s3Client }
              )) {
                return { Uploaded: false };
              }
            }
            const headers = {};
            if (Authorization) {
              headers.Authorization = Authorization;
            }
            return new Promise((resolve, reject) => {
              const req = import_https.default.request(
                Url,
                {
                  method: Method,
                  headers
                },
                (res) => {
                  if (res.statusCode != null && res.statusCode >= 200 && res.statusCode < 300) {
                    console.log(res.headers);
                    const Metadata = {};
                    if (Version) {
                      Metadata.Version = Version;
                    }
                    uploadIncomingHttpToS3(
                      { res, Region: DefaultRegion, Dest, Metadata },
                      { s3Client }
                    ).then(() => resolve({ Uploaded: true })).catch(reject);
                  } else {
                    console.error("Api call failed:", Url, res.statusCode);
                    reject(
                      new Error(`Request failed with status code ${res.statusCode}`)
                    );
                  }
                }
              );
              req.on("error", (err) => {
                reject(err);
              });
              req.end();
            });
          };
          var copyToS3Region = async ({
            SourceRegion,
            TargetRegion,
            Version,
            Key,
            CorrelationId
          }) => {
            const s3Client = new import_client_s3.S3Client({
              region: TargetRegion,
              logger: getLogger({ CorrelationId }),
              requestStreamBufferSize: 64 * 1024
            });
            if (Version) {
              if (await doesSameVersionExists(
                { Key, Version, Region: TargetRegion },
                { s3Client }
              )) {
                return;
              }
            }
            const sourceBucket = getS3BucketName(SourceRegion);
            await s3Client.send(
              new import_client_s3.CopyObjectCommand({
                CopySource: `${sourceBucket}/${Key}`,
                Bucket: getS3BucketName(TargetRegion),
                Key
              })
            );
          };
          var handler = async (event) => {
            const { CorrelationId, Dest, Version, MultiRegion, ...params } = event;
            const DefaultRegion = process.env.AWS_REGION || "us-east-1";
            const s3Client = new import_client_s3.S3Client({
              region: DefaultRegion,
              logger: getLogger({ CorrelationId }),
              requestStreamBufferSize: 64 * 1024
            });
            const { Uploaded } = await downloadToS3(
              { ...params, Dest, Version, DefaultRegion },
              { s3Client }
            );
            if (MultiRegion) {
              const SERVICE_REGIONS = process.env.SERVICE_REGIONS;
              if (SERVICE_REGIONS) {
                const serviceRegions = SERVICE_REGIONS.split(",").filter(
                  (a) => a != DefaultRegion
                );
                await Promise.all(
                  serviceRegions.map(
                    (serviceRegion) => copyToS3Region({
                      SourceRegion: DefaultRegion,
                      TargetRegion: serviceRegion,
                      Version,
                      CorrelationId,
                      Key: Dest
                    })
                  )
                );
              }
            }
            return { Uploaded };
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          AWS_PARTITION:
            Ref: AWS::Partition
          SERVICE_REGIONS:
            Fn::Join:
              - ","
              - Ref: Regions
      FunctionName: qualys-utils-download-to-s3
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 512
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 900
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaUpdateLambdaCode:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/updateLambdaCode.ts
          var updateLambdaCode_exports = {};
          __export(updateLambdaCode_exports, {
            handler: () => handler
          });
          module.exports = __toCommonJS(updateLambdaCode_exports);
          var import_client_lambda = require("@aws-sdk/client-lambda");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/updateLambdaCode.ts
          var handler = async ({
            LambdaName,
            Key
          }) => {
            const lambdaClient = new import_client_lambda.LambdaClient({
              region: process.env.AWS_REGION || "us-east-1"
            });
            console.log("Updating code");
            await lambdaClient.send(
              new import_client_lambda.UpdateFunctionCodeCommand({
                FunctionName: LambdaName,
                // ZipFile: Uint8Array.from(await messageToBuffer(lambdaZip.Body)),
                S3Bucket: getS3BucketName(process.env.AWS_REGION || "us-east-1"),
                S3Key: Key,
                Publish: true
              })
            );
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          AWS_PARTITION:
            Ref: AWS::Partition
      FunctionName: qualys-utils-update-lambda-code
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 900
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  LambdaS3CreateBucket:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          "use strict";
          var __defProp = Object.defineProperty;
          var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
          var __getOwnPropNames = Object.getOwnPropertyNames;
          var __hasOwnProp = Object.prototype.hasOwnProperty;
          var __export = (target, all) => {
            for (var name in all)
              __defProp(target, name, { get: all[name], enumerable: true });
          };
          var __copyProps = (to, from, except, desc) => {
            if (from && typeof from === "object" || typeof from === "function") {
              for (let key of __getOwnPropNames(from))
                if (!__hasOwnProp.call(to, key) && key !== except)
                  __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
            }
            return to;
          };
          var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

          // src/lambda/code/s3Management.ts
          var s3Management_exports = {};
          __export(s3Management_exports, {
            handler: () => handler,
            s3Management: () => s3Management
          });
          module.exports = __toCommonJS(s3Management_exports);
          var import_client_s3 = require("@aws-sdk/client-s3");
          var import_client_cloudwatch_logs = require("@aws-sdk/client-cloudwatch-logs");

          // src/lambda/code/lib/constants.ts
          var prefix = "qualys";
          var RESOURCE_INVENTORY_TABLE = `${prefix}-resource-inventory`;
          var RESOURCE_INVENTORY_SCAN_STATUS_TABLE = `${prefix}-inventory-scan-status`;
          var APP_CONFIG_TABLE = `${prefix}-app-config`;
          var EVENT_LOGS_TABLE = `${prefix}-event-logs`;
          var IAM_ROLE_SESSION_NAME = `${prefix}-snapshot-scanner`;
          var CLI_CONFIG_PARAMETER = `/${prefix}/snapshot-scanner/cli-config`;
          var S3_BUCKET_NAME = `${prefix}-data`;
          var EC2_SCANNER_SECURITY_GROUP_NAME = `${prefix}-snapshot-scanner-sg`;

          // src/lambda/code/lib/s3BucketName.ts
          var BASE_S3_BUCKET_NAME = process.env.BASE_S3_BUCKET_NAME || S3_BUCKET_NAME;
          function getS3BucketNamePrefix() {
            const STACK_ID = process.env.STACK_ID;
            if (!STACK_ID) {
              throw new Error(`STACK_ID not found`);
            }
            const splitted = STACK_ID.split("/");
            const suffix = splitted[splitted.length - 1];
            return `${BASE_S3_BUCKET_NAME}-${suffix}`;
          }
          function getS3BucketName(region) {
            const s3Region = region;
            if (!s3Region) {
              throw new Error(`AWS_REGION not found`);
            }
            return `${getS3BucketNamePrefix()}-${s3Region}`;
          }

          // src/lambda/code/lib/sgEgress.ts
          var import_client_ec2 = require("@aws-sdk/client-ec2");
          var TagAppKey = process.env.TagAppKey || "";
          var TagAppValue = process.env.TagAppValue || "";
          async function getScannerSg(region) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { SecurityGroups } = await ec2Client.send(
              new import_client_ec2.DescribeSecurityGroupsCommand({
                Filters: [
                  {
                    Name: "group-name",
                    Values: [EC2_SCANNER_SECURITY_GROUP_NAME]
                  },
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  }
                ]
              })
            );
            if (!SecurityGroups || SecurityGroups.length == 0) {
              throw new Error("Security group not found");
            }
            return SecurityGroups[0];
          }
          async function findPrefixIdForService(region, service) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { PrefixLists } = await ec2Client.send(
              new import_client_ec2.DescribePrefixListsCommand({
                Filters: [
                  {
                    Name: "prefix-list-name",
                    Values: [`com.amazonaws.${region}.${service}`]
                  }
                ]
              })
            );
            if (!PrefixLists || PrefixLists.length == 0) {
              throw new Error("Prefix list not found");
            }
            const prefixListId = PrefixLists[0].PrefixListId;
            if (!prefixListId) {
              throw new Error("Prefix list id not found");
            }
            return prefixListId;
          }
          async function addServiceEgressToSg(region, securityGroup, service, port) {
            const prefixId = await findPrefixIdForService(region, service);
            const egress = securityGroup.IpPermissionsEgress;
            console.log(egress);
            const existingEgress = egress?.find(
              (a) => a.PrefixListIds?.find((a2) => a2.PrefixListId == prefixId) != null
            );
            if (!existingEgress) {
              const ec2Client = new import_client_ec2.EC2Client({ region });
              await ec2Client.send(
                new import_client_ec2.AuthorizeSecurityGroupEgressCommand({
                  GroupId: securityGroup.GroupId,
                  IpPermissions: [
                    {
                      IpProtocol: "tcp",
                      FromPort: port,
                      ToPort: port,
                      PrefixListIds: [
                        {
                          Description: "Allow connection to s3",
                          PrefixListId: prefixId
                        }
                      ]
                    }
                  ]
                })
              );
            }
          }
          async function addEgressToScannerSg(region) {
            const securityGroup = await getScannerSg(region);
            await addServiceEgressToSg(region, securityGroup, "s3", 443);
          }
          async function restrictDefaultSecurityGroup(region) {
            const ec2Client = new import_client_ec2.EC2Client({ region });
            const { Vpcs } = await ec2Client.send(
              new import_client_ec2.DescribeVpcsCommand({
                Filters: [
                  {
                    Name: `tag:${TagAppKey}`,
                    Values: [TagAppValue]
                  }
                ]
              })
            );
            if (!Vpcs || Vpcs.length == 0) {
              throw new Error("Vpc not found");
            }
            const vpcId = Vpcs[0].VpcId;
            if (!vpcId) {
              throw new Error("Vpc not found");
            }
            const { SecurityGroups } = await ec2Client.send(
              new import_client_ec2.DescribeSecurityGroupsCommand({
                Filters: [
                  {
                    Name: "group-name",
                    Values: ["default"]
                  },
                  {
                    Name: "vpc-id",
                    Values: [vpcId]
                  }
                ]
              })
            );
            if (!SecurityGroups || SecurityGroups.length == 0) {
              throw new Error("Security group not found");
            }
            const GroupId = SecurityGroups[0].GroupId;
            const securityGroupEgress = SecurityGroups[0].IpPermissionsEgress;
            if (securityGroupEgress && securityGroupEgress.length > 0) {
              await ec2Client.send(
                new import_client_ec2.RevokeSecurityGroupEgressCommand({
                  GroupId,
                  IpPermissions: securityGroupEgress
                })
              );
            }
            const securityGroupIngress = SecurityGroups[0].IpPermissions;
            if (securityGroupIngress && securityGroupIngress.length > 0) {
              await ec2Client.send(
                new import_client_ec2.RevokeSecurityGroupIngressCommand({
                  GroupId,
                  IpPermissions: securityGroupIngress
                })
              );
            }
          }

          // src/lambda/code/s3Management.ts
          var TagAppKey2 = process.env.TagAppKey || "";
          var TagAppValue2 = process.env.TagAppValue || "";
          async function checkIfBucketExists(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            try {
              const existingBucket = await s3Client.send(
                new import_client_s3.HeadBucketCommand({ Bucket: getS3BucketName(region) })
              );
              return existingBucket.BucketRegion != null;
            } catch (e) {
              if (e instanceof import_client_s3.NotFound) {
                return false;
              }
              console.log(e);
              return false;
            }
          }
          async function createS3Bucket(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            try {
              const exists = await checkIfBucketExists(region);
              if (exists) {
                return;
              }
              const Bucket = getS3BucketName(region);
              await s3Client.send(
                new import_client_s3.CreateBucketCommand({
                  Bucket
                })
              );
            } catch (e) {
              if (e instanceof import_client_s3.BucketAlreadyExists) {
                console.log("Bucket already exists");
              } else if (e instanceof import_client_s3.BucketAlreadyOwnedByYou) {
                console.log("Bucket already exists");
              } else {
                throw e;
              }
            }
          }
          async function createS3BucketPolicy(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketPolicyCommand({
                Bucket,
                Policy: JSON.stringify({
                  Version: "2012-10-17",
                  Statement: [
                    {
                      Sid: "DenyHttpOnly",
                      Principal: "*",
                      Effect: "Deny",
                      Action: ["s3:*"],
                      Resource: [`arn:${process.env.AWS_PARTITION}:s3:::${Bucket}/*`],
                      Condition: {
                        Bool: {
                          "aws:SecureTransport": "false"
                        }
                      }
                    }
                  ]
                })
              })
            );
          }
          async function enableBucketVersioning(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketVersioningCommand({
                Bucket,
                VersioningConfiguration: {
                  Status: "Enabled"
                }
              })
            );
          }
          async function addS3BucketTag(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketTaggingCommand({
                Bucket,
                Tagging: {
                  TagSet: [
                    {
                      Key: TagAppKey2,
                      Value: TagAppValue2
                    }
                  ]
                }
              })
            );
          }
          async function createS3LifecycleConfigurations(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            await s3Client.send(
              new import_client_s3.PutBucketLifecycleConfigurationCommand({
                Bucket,
                LifecycleConfiguration: {
                  Rules: [
                    {
                      ID: `${Bucket}-data-expiration`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Expiration: {
                        Days: 1
                      },
                      Filter: {
                        Prefix: "data"
                      },
                      Status: "Enabled"
                    },
                    {
                      ID: `${Bucket}-logs-expiration`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Expiration: {
                        Days: 1
                      },
                      Filter: {
                        Prefix: "logs"
                      },
                      Status: "Enabled"
                    },
                    {
                      ID: `${Bucket}-logs-artifacts`,
                      NoncurrentVersionExpiration: {
                        NoncurrentDays: 1,
                        NewerNoncurrentVersions: 1
                      },
                      Filter: {
                        Prefix: "artifacts"
                      },
                      Status: "Enabled"
                    }
                  ]
                }
              })
            );
          }
          async function deleteDanglingLogGroups(region) {
            if (region === (process.env.AWS_REGION || "us-east-1")) {
              return;
            }
            const logClient = new import_client_cloudwatch_logs.CloudWatchLogsClient({
              region
            });
            const { logGroups } = await logClient.send(
              new import_client_cloudwatch_logs.DescribeLogGroupsCommand({
                logGroupNamePrefix: "/qualys/logs"
              })
            );
            if (logGroups && logGroups.length > 0) {
              await logClient.send(
                new import_client_cloudwatch_logs.DeleteLogGroupCommand({
                  logGroupName: logGroups[0].logGroupName
                })
              );
            }
          }
          async function emptyS3BucketVersions(region, PreviousToken) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            const { Versions, NextKeyMarker } = await s3Client.send(
              new import_client_s3.ListObjectVersionsCommand({
                Bucket,
                KeyMarker: PreviousToken
              })
            );
            if (Versions) {
              console.log(
                `Found ${Versions.length} versions in bucket ${Bucket}, deleting all`
              );
              await s3Client.send(
                new import_client_s3.DeleteObjectsCommand({
                  Bucket,
                  Delete: {
                    Objects: Versions.map((Item) => ({
                      Key: Item.Key,
                      VersionId: Item.VersionId
                    }))
                  }
                })
              );
            }
            if (NextKeyMarker) {
              await emptyS3BucketVersions(region, NextKeyMarker);
            }
          }
          async function emptyS3BucketDeleteMarkers(region, PreviousToken) {
            const s3Client = new import_client_s3.S3Client({ region });
            const Bucket = getS3BucketName(region);
            const { DeleteMarkers, NextKeyMarker } = await s3Client.send(
              new import_client_s3.ListObjectVersionsCommand({
                Bucket,
                KeyMarker: PreviousToken
              })
            );
            if (DeleteMarkers) {
              console.log(
                `Found ${DeleteMarkers.length} Delete Markers in bucket ${Bucket}, deleting all`
              );
              await s3Client.send(
                new import_client_s3.DeleteObjectsCommand({
                  Bucket,
                  Delete: {
                    Objects: DeleteMarkers.map((Item) => ({
                      Key: Item.Key,
                      VersionId: Item.VersionId
                    }))
                  }
                })
              );
            }
            if (NextKeyMarker) {
              await emptyS3BucketDeleteMarkers(region, NextKeyMarker);
            }
          }
          async function deleteS3Bucket(region) {
            const s3Client = new import_client_s3.S3Client({ region });
            await s3Client.send(
              new import_client_s3.DeleteBucketCommand({
                Bucket: getS3BucketName(region)
              })
            );
          }
          async function createS3Region(region) {
            await createS3Bucket(region);
            await createS3BucketPolicy(region);
            await addS3BucketTag(region);
            await enableBucketVersioning(region);
            await createS3LifecycleConfigurations(region);
            await addEgressToScannerSg(region);
            await restrictDefaultSecurityGroup(region);
            await deleteDanglingLogGroups(region);
          }
          async function deleteS3Region(region) {
            const exists = await checkIfBucketExists(region);
            if (exists) {
              await emptyS3BucketVersions(region);
              await emptyS3BucketDeleteMarkers(region);
              await deleteS3Bucket(region);
            }
          }
          async function deleteDanglingS3Buckets(regions) {
            const s3Client = new import_client_s3.S3Client({
              region: process.env.AWS_REGION || "us-east-1"
            });
            const { Buckets } = await s3Client.send(
              new import_client_s3.ListBucketsCommand({
                Prefix: getS3BucketNamePrefix()
              })
            );
            for (const bucket of Buckets ?? []) {
              if (bucket.BucketRegion != null && regions.indexOf(bucket.BucketRegion) == -1) {
                await deleteS3Region(bucket.BucketRegion);
              }
            }
          }
          var getServiceRegions = () => {
            return (process.env.SERVICE_REGIONS || "").split(",");
          };
          var s3Management = async ({
            action
          }) => {
            if (action === "CREATE") {
              await Promise.all(getServiceRegions().map(createS3Region));
              await deleteDanglingS3Buckets(getServiceRegions());
            } else if (action === "DELETE") {
              await Promise.all(getServiceRegions().map(deleteS3Region));
            }
          };
          var handler = async () => {
            await s3Management({ action: "CREATE" });
            const s3BucketNameMaps = {};
            for (const serviceRegion of getServiceRegions()) {
              s3BucketNameMaps[serviceRegion] = getS3BucketName(serviceRegion);
            }
            return s3BucketNameMaps;
          };
          // Annotate the CommonJS export names for ESM import in node:
          0 && (module.exports = {
            handler,
            s3Management
          });
      DeadLetterConfig:
        TargetArn:
          Fn::GetAtt:
            - SqsFailedErrors
            - Arn
      Environment:
        Variables:
          STACK_ID:
            Ref: AWS::StackId
          AWS_PARTITION:
            Ref: AWS::Partition
          TagAppKey: App
          TagAppValue: qualys-snapshot-scanner
          SERVICE_REGIONS:
            Fn::Join:
              - ","
              - Ref: Regions
      FunctionName: qualys-utils-s3-create-bucket
      Handler: index.handler
      KmsKeyArn:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - LambdaRole
          - Arn
      Runtime: nodejs22.x
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      Timeout: 900
      TracingConfig:
        Mode: PassThrough
    DependsOn:
      - LambdaRoleDefaultPolicy
      - LambdaRole
  CommonLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      KmsKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      LogGroupName: /qualys/logs
      RetentionInDays: 7
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnSDKWrapper:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"SDKWrapperFailState","States":{"SDKWrapperFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-sdk-wrapper
      StateMachineType: EXPRESS
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCommonConfig:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CommonConfigFailState","States":{"CommonConfigFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-config-generator
      StateMachineType: EXPRESS
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnUpdateCommonConfig:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"UpdateCommonConfigFailState","States":{"UpdateCommonConfigFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-update-configs
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnDynamoDbWrapper:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"DynamoDbWrapperFailState","States":{"DynamoDbWrapperFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-dynamodb-wrapper
      StateMachineType: EXPRESS
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnRegisterServiceAccount:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"RegisterServiceAccountFailState","States":{"RegisterServiceAccountFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-register-service-account
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnDeregisterServiceAccount:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"DeregisterServiceAccountFailState","States":{"DeregisterServiceAccountFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-deregister-service-account
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnEC2Poller:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"EC2PollerFailState","States":{"EC2PollerFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-instance-discovery-scheduled
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnRetryFailedSnapshots:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"RetryFailedSnapshotsFailState","States":{"RetryFailedSnapshotsFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-retry-failed-snapshots
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnResourceEventsSyncer:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"ResourceEventsSyncerFailState","States":{"ResourceEventsSyncerFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-events-syncer
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCreateSnapshot:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CreateSnapshotFailState","States":{"CreateSnapshotFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-create-snapshot
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCopySnapshot:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CopySnapshotFailState","States":{"CopySnapshotFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-copy-snapshot
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnImageCopySnapshot:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"ImageCopySnapshotFailState","States":{"ImageCopySnapshotFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-image-copy-snapshot
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCreateSnapshotWrapper:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CreateSnapshotWrapperFailState","States":{"CreateSnapshotWrapperFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-create-encrypted-snapshot
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnFindScanCandidates:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"FindScanCandidatesFailState","States":{"FindScanCandidatesFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-find-scan-candidates
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnFindScanCandidatesByScanType:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"FindScanCandidatesByScanTypeFailState","States":{"FindScanCandidatesByScanTypeFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-find-scan-candidates-by-scan-type
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnNotifyQflow:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"NotifyQflowFailState","States":{"NotifyQflowFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-notify-qflow
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnScanInstances:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"ScanInstancesFailState","States":{"ScanInstancesFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-scan-instances
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCreateInstance:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CreateInstanceFailState","States":{"CreateInstanceFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-create-instance
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnRunScanner:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"RunScannerFailState","States":{"RunScannerFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-run-scan
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCleanup:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CleanupFailState","States":{"CleanupFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-destroy-stale-resources
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnProxyInstance:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"ProxyInstanceFailState","States":{"ProxyInstanceFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-proxy-instance-x
      StateMachineType: EXPRESS
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnScannerAmiCreation:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"ScannerAmiCreationFailState","States":{"ScannerAmiCreationFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-scanner-ami-creation
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SfnCliConfigGenerator:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      DefinitionString: '{"StartAt":"CliConfigGeneratorFailState","States":{"CliConfigGeneratorFailState":{"Type":"Fail","Error":"Not Configured Yet","Cause":"Check SFn config pipeline, this SFn does not has proper definition"}},"TimeoutSeconds":5}'
      LoggingConfiguration:
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn:
                Fn::GetAtt:
                  - CommonLogGroup
                  - Arn
        IncludeExecutionData: false
        Level: ERROR
      RoleArn:
        Fn::GetAtt:
          - SfnRole
          - Arn
      StateMachineName: qualys-sfn-cli-config-generator
      StateMachineType: STANDARD
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - SfnRoleDefaultPolicy
      - SfnRole
      - SfnRoleUpdateStepFunction
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SFAccess:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - states:StartExecution
              - states:StartSyncExecution
              - states:UpdateStateMachine
            Effect: Allow
            Resource:
              - Ref: SfnCleanup
              - Ref: SfnCliConfigGenerator
              - Ref: SfnCommonConfig
              - Ref: SfnCopySnapshot
              - Ref: SfnCreateInstance
              - Ref: SfnCreateSnapshot
              - Ref: SfnCreateSnapshotWrapper
              - Ref: SfnDeregisterServiceAccount
              - Ref: SfnDynamoDbWrapper
              - Ref: SfnEC2Poller
              - Ref: SfnFindScanCandidates
              - Ref: SfnFindScanCandidatesByScanType
              - Ref: SfnImageCopySnapshot
              - Ref: SfnNotifyQflow
              - Ref: SfnProxyInstance
              - Ref: SfnRegisterServiceAccount
              - Ref: SfnResourceEventsSyncer
              - Ref: SfnRetryFailedSnapshots
              - Ref: SfnRunScanner
              - Ref: SfnSDKWrapper
              - Ref: SfnScanInstances
              - Ref: SfnScannerAmiCreation
              - Ref: SfnUpdateCommonConfig
        Version: "2012-10-17"
      PolicyName: SFAccess
      Roles:
        - Ref: SfnRole
  StackSetAdministrationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: cloudformation.amazonaws.com
        Version: "2012-10-17"
      Policies:
        - PolicyDocument:
            Statement:
              - Action: sts:AssumeRole
                Effect: Allow
                Resource:
                  Fn::Join:
                    - ""
                    - - "arn:"
                      - Ref: AWS::Partition
                      - ":iam::"
                      - Ref: AWS::AccountId
                      - :role/qualys-stack-execution-role
            Version: "2012-10-17"
          PolicyName: assumeExecutionRolePolicy
      RoleName: qualys-stack-administration-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  StackSetExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              AWS:
                Fn::GetAtt:
                  - StackSetAdministrationRole
                  - Arn
        Version: "2012-10-17"
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - cloudformation:*
                  - ec2:AllocateAddress
                  - ec2:AssignPrivateIpAddresses
                  - ec2:AssignPrivateNatGatewayAddress
                  - ec2:AssociateAddress
                  - ec2:AssociateNatGatewayAddress
                  - ec2:AssociateRouteTable
                  - ec2:AttachInternetGateway
                  - ec2:AttachNetworkInterface
                  - ec2:AuthorizeSecurityGroupEgress
                  - ec2:AuthorizeSecurityGroupIngress
                  - ec2:CreateInternetGateway
                  - ec2:CreateNatGateway
                  - ec2:CreateNetworkInterface
                  - ec2:CreateRoute
                  - ec2:CreateRouteTable
                  - ec2:CreateSecurityGroup
                  - ec2:CreateSubnet
                  - ec2:CreateTags
                  - ec2:CreateVpc
                  - ec2:CreateVpcEndpoint
                  - ec2:DeleteNetworkInterface
                  - ec2:DeleteVpcEndpoints
                  - ec2:DescribeAccountAttributes
                  - ec2:DescribeAddresses
                  - ec2:DescribeAvailabilityZones
                  - ec2:DescribeInternetGateways
                  - ec2:DescribeNatGateways
                  - ec2:DescribeNetworkAcls
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DescribeRouteTables
                  - ec2:DescribeSecurityGroups
                  - ec2:DescribeSubnets
                  - ec2:DescribeVpcAttribute
                  - ec2:DescribeVpcEndpoints
                  - ec2:DescribeVpcs
                  - ec2:DetachNetworkInterface
                  - ec2:ModifySubnetAttribute
                  - ec2:ModifyVpcAttribute
                  - ec2:RevokeSecurityGroupEgress
                  - ec2:RevokeSecurityGroupIngress
                  - ec2:UnassignPrivateIpAddresses
                  - kms:CreateAlias
                  - kms:CreateKey
                  - kms:Describe*
                  - kms:EnableKey
                  - kms:List*
                  - kms:PutKeyPolicy
                  - kms:TagResource
                  - lambda:CreateFunction
                  - lambda:DeleteFunction
                  - lambda:GetFunction
                  - lambda:GetFunctionCodeSigningConfig
                  - lambda:GetRuntimeManagementConfig
                  - lambda:ListTags
                  - lambda:TagResource
                  - lambda:UpdateFunction
                  - lambda:UpdateFunctionCode
                  - lambda:UpdateFunctionConfiguration
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DeleteLogGroup
                  - logs:PutLogEvents
                  - logs:TagResource
                  - ssm:AddTagsToResource
                  - ssm:CreateDocument
                  - ssm:DescribeDocument
                  - ssm:DescribeParameters
                  - ssm:GetDocument
                  - ssm:GetParameters
                  - ssm:ListDocuments
                  - ssm:ListTagsForResource
                  - ssm:PutParameter
                Effect: Allow
                Resource: "*"
              - Action: iam:PassRole
                Effect: Allow
                Resource:
                  Fn::GetAtt:
                    - LambdaRole
                    - Arn
              - Action:
                  - s3:GetObject
                  - s3:PutObject
                Effect: Allow
                Resource:
                  - Fn::Join:
                      - ""
                      - - "arn:"
                        - Ref: AWS::Partition
                        - :s3:::qualys-data-*
                  - Fn::Join:
                      - ""
                      - - "arn:"
                        - Ref: AWS::Partition
                        - :s3:::qualys-data-*/*
              - Action:
                  - ec2:DeleteInternetGateway
                  - ec2:DeleteNatGateway
                  - ec2:DeleteRoute
                  - ec2:DeleteRouteTable
                  - ec2:DeleteSecurityGroup
                  - ec2:DeleteSubnet
                  - ec2:DeleteTag
                  - ec2:DeleteVpc
                  - ec2:DetachInternetGateway
                  - ec2:DetachNetworkInterface
                  - ec2:DisassociateAddress
                  - ec2:DisassociateNatGatewayAddress
                  - ec2:DisassociateRouteTable
                  - ec2:ReleaseAddress
                  - ec2:UnassignPrivateNatGatewayAddress
                  - ssm:DeleteDocument
                  - ssm:DeleteParameter
                Condition:
                  StringEquals:
                    aws:ResourceTag/App: qualys-snapshot-scanner
                Effect: Allow
                Resource: "*"
              - Action: kms:DeleteAlias
                Effect: Allow
                Resource:
                  Fn::Join:
                    - ""
                    - - "arn:"
                      - Ref: AWS::Partition
                      - ":kms:*:"
                      - Ref: AWS::AccountId
                      - :alias/qualys-snapshot-key
            Version: "2012-10-17"
          PolicyName: stackExecutionPolicy
      RoleName: qualys-stack-execution-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  RegionStackSet:
    Type: AWS::CloudFormation::StackSet
    Properties:
      AdministrationRoleARN:
        Fn::GetAtt:
          - StackSetAdministrationRole
          - Arn
      Description: deploys vpc across multiple region
      ExecutionRoleName:
        Ref: StackSetExecutionRole
      OperationPreferences:
        RegionConcurrencyType: PARALLEL
      Parameters:
        - ParameterKey: VpcCidr
          ParameterValue:
            Ref: VpcCidr
        - ParameterKey: SubnetCidr
          ParameterValue:
            Ref: SubnetCidr
        - ParameterKey: LambdaRoleArn
          ParameterValue:
            Fn::GetAtt:
              - LambdaRole
              - Arn
        - ParameterKey: StackSetExecutionRoleArn
          ParameterValue:
            Fn::GetAtt:
              - StackSetExecutionRole
              - Arn
      PermissionModel: SELF_MANAGED
      StackInstancesGroup:
        - DeploymentTargets:
            Accounts:
              - Ref: AWS::AccountId
          Regions:
            Ref: Regions
      StackSetName: qualys-cross-region-vpc
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      TemplateBody: |
        {
          "Parameters": {
            "VpcCidr": {
              "Type": "String",
              "Default": "10.10.0.0/16",
              "Description": "Provide the Vpc Cidr. Eg, 10.82.64.0/22",
              "MinLength": 1
            },
            "SubnetCidr": {
              "Type": "String",
              "Default": "10.10.1.0/24",
              "Description": "Provide the Subnet Cidr. Eg, 10.82.64.0/22",
              "MinLength": 1
            },
            "LambdaRoleArn": {
              "Type": "String",
              "Description": "role arn for lambda"
            },
            "StackSetExecutionRoleArn": {
              "Type": "String",
              "Description": "role arn for stack set execution"
            }
          },
          "Resources": {
            "KmsKey": {
              "Type": "AWS::KMS::Key",
              "Properties": {
                "Description": "Symmetric CMK for Qualys Snapshot",
                "EnableKeyRotation": true,
                "Enabled": true,
                "KeyPolicy": {
                  "Version": "2012-10-17",
                  "Id": "key-default-1",
                  "Statement": [
                    {
                      "Sid": "Enable IAM User Permissions",
                      "Effect": "Allow",
                      "Principal": {
                        "AWS": {
                          "Fn::Sub": "arn:${AWS::Partition}:iam::${AWS::AccountId}:root"
                        }
                      },
                      "Action": "kms:*",
                      "Resource": "*"
                    },
                    {
                      "Sid": "Enable Cloudformation execution role all access to this key",
                      "Effect": "Allow",
                      "Principal": {
                        "AWS": {
                          "Ref": "StackSetExecutionRoleArn"
                        }
                      },
                      "Action": "kms:*",
                      "Resource": "*"
                    }
                  ]
                },
                "KeyUsage": "ENCRYPT_DECRYPT",
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ]
              }
            },
            "KmsKeyAlias": {
              "Type": "AWS::KMS::Alias",
              "Properties": {
                "AliasName": "alias/qualys-snapshot-key",
                "TargetKeyId": {
                  "Ref": "KmsKey"
                }
              }
            },
            "PublicVpc": {
              "Type": "AWS::EC2::VPC",
              "Properties": {
                "CidrBlock": {
                  "Ref": "VpcCidr"
                },
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  },
                  {
                    "Key": "Name",
                    "Value": "qualys-snapshot-scanner-vpc"
                  }
                ]
              }
            },
            "PublicSubnet": {
              "Type": "AWS::EC2::Subnet",
              "Properties": {
                "AvailabilityZone": {
                  "Fn::Select": [
                    0,
                    {
                      "Fn::GetAZs": ""
                    }
                  ]
                },
                "CidrBlock": {
                  "Ref": "SubnetCidr"
                },
                "MapPublicIpOnLaunch": false,
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  },
                  {
                    "Key": "Name",
                    "Value": "qualys-snapshot-scanner-subnet"
                  }
                ],
                "VpcId": {
                  "Ref": "PublicVpc"
                }
              }
            },
            "PublicRouteTable": {
              "Type": "AWS::EC2::RouteTable",
              "Properties": {
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ],
                "VpcId": {
                  "Ref": "PublicVpc"
                }
              }
            },
            "PublicVpcEndpoint": {
              "Type": "AWS::EC2::VPCEndpoint",
              "Properties": {
                "RouteTableIds": [
                  {
                    "Ref": "PublicRouteTable"
                  }
                ],
                "ServiceName": {
                  "Fn::Join": [
                    "",
                    [
                      "com.amazonaws.",
                      {
                        "Ref": "AWS::Region"
                      },
                      ".s3"
                    ]
                  ]
                },
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ],
                "VpcEndpointType": "Gateway",
                "VpcId": {
                  "Ref": "PublicVpc"
                }
              }
            },
            "PublicRouteTableAssociation": {
              "Type": "AWS::EC2::SubnetRouteTableAssociation",
              "Properties": {
                "RouteTableId": {
                  "Ref": "PublicRouteTable"
                },
                "SubnetId": {
                  "Ref": "PublicSubnet"
                }
              }
            },
            "PublicLambdaSecurityGroup": {
              "Type": "AWS::EC2::SecurityGroup",
              "Properties": {
                "GroupDescription": "Security group for lambda",
                "GroupName": "qualys-snapshot-scanner-lambda-sg",
                "SecurityGroupEgress": [
                  {
                    "CidrIp": {
                      "Ref": "VpcCidr"
                    },
                    "Description": "To reach the scanner ec2 instance from this lambda",
                    "IpProtocol": "-1"
                  }
                ],
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ],
                "VpcId": {
                  "Ref": "PublicVpc"
                }
              }
            },
            "PublicSecurityGroup": {
              "Type": "AWS::EC2::SecurityGroup",
              "Properties": {
                "GroupDescription": "Security group for scanner Instance",
                "GroupName": "qualys-snapshot-scanner-sg",
                "SecurityGroupEgress": [
                  {
                    "Description": "To reach proxy-instance from ec2",
                    "DestinationSecurityGroupId": {
                      "Fn::GetAtt": [
                        "PublicLambdaSecurityGroup",
                        "GroupId"
                      ]
                    },
                    "FromPort": 8000,
                    "IpProtocol": "tcp",
                    "ToPort": 8000
                  }
                ],
                "SecurityGroupIngress": [
                  {
                    "Description": "To reach this instance from proxy-instance lambda",
                    "FromPort": 8000,
                    "IpProtocol": "tcp",
                    "SourceSecurityGroupId": {
                      "Fn::GetAtt": [
                        "PublicLambdaSecurityGroup",
                        "GroupId"
                      ]
                    },
                    "ToPort": 8000
                  }
                ],
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ],
                "VpcId": {
                  "Ref": "PublicVpc"
                }
              }
            },
            "ProxyLambdaPrivateProxyLambda": {
              "Type": "AWS::Lambda::Function",
              "Properties": {
                "Code": {
                  "ZipFile": "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/lambda/code/proxyInstance.ts\nvar proxyInstance_exports = {};\n__export(proxyInstance_exports, {\n  handler: () => handler\n});\nmodule.exports = __toCommonJS(proxyInstance_exports);\nvar import_http = __toESM(require(\"http\"));\nvar handler = function(params, context) {\n  let response = null;\n  const headers = params.headers || {};\n  if (params.body) {\n    headers[\"Content-Length\"] = Buffer.byteLength(JSON.stringify(params.body));\n  }\n  const req = import_http.default.request(\n    {\n      host: params.host,\n      port: params.port,\n      path: params.path || params[\"path.$\"],\n      method: params.method,\n      headers\n      // Use updated headers\n    },\n    (res) => {\n      const data = [];\n      const statusCode = res.statusCode;\n      res.on(\"data\", (chunk) => {\n        data.push(chunk);\n      });\n      res.on(\"end\", () => {\n        try {\n          const parsed = Buffer.concat(data).toString();\n          response = JSON.parse(parsed);\n        } catch (e) {\n          console.error(e);\n          response = Buffer.concat(data).toString();\n        }\n        if (statusCode >= 300) {\n          context.fail(response);\n        } else {\n          context.succeed(response);\n        }\n      });\n    }\n  );\n  req.on(\"error\", (error) => {\n    context.fail(error.toString());\n  });\n  if (params.body) {\n    req.write(JSON.stringify(params.body));\n  }\n  req.end();\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  handler\n});\n"
                },
                "Environment": {},
                "FunctionName": "qualys-util-proxy-instance",
                "Handler": "index.handler",
                "KmsKeyArn": {
                  "Fn::GetAtt": [
                    "KmsKey",
                    "Arn"
                  ]
                },
                "Role": {
                  "Ref": "LambdaRoleArn"
                },
                "Runtime": "nodejs22.x",
                "Tags": [
                  {
                    "Key": "App",
                    "Value": "qualys-snapshot-scanner"
                  }
                ],
                "Timeout": 180,
                "TracingConfig": {
                  "Mode": "PassThrough"
                },
                "VpcConfig": {
                  "SecurityGroupIds": [
                    {
                      "Fn::GetAtt": [
                        "PublicLambdaSecurityGroup",
                        "GroupId"
                      ]
                    }
                  ],
                  "SubnetIds": [
                    {
                      "Fn::GetAtt": [
                        "PublicSubnet",
                        "SubnetId"
                      ]
                    }
                  ]
                }
              }
            },
            "PublicVPCParameter": {
              "Type": "AWS::SSM::Parameter",
              "Properties": {
                "Description": "Stores sg and subnet Id to be used for Ec2 RunInstance",
                "Name": "/qualys/snapshot-scanner/region-config",
                "Tags": {
                  "App": "qualys-snapshot-scanner"
                },
                "Type": "String",
                "Value": {
                  "Fn::Join": [
                    "",
                    [
                      "{\"ScannerSecurityGroupId\":\"",
                      {
                        "Ref": "PublicSecurityGroup"
                      },
                      "\",\"ScannerSubnetId\":\"",
                      {
                        "Ref": "PublicSubnet"
                      },
                      "\",\"ScannerAvailabilityZone\":\"",
                      {
                        "Fn::Select": [
                          0,
                          {
                            "Fn::GetAZs": ""
                          }
                        ]
                      },
                      "\",\"EKeyId\":\"",
                      {
                        "Ref": "KmsKey"
                      },
                      "\"}"
                    ]
                  ]
                }
              }
            }
          }
        }
    DependsOn:
      - LambdaPolicy
  EBRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: events.amazonaws.com
        Version: "2012-10-17"
      RoleName: qualys-update-sf-eb-role
  EBRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action: states:StartExecution
            Effect: Allow
            Resource:
              - Ref: SfnCleanup
              - Ref: SfnEC2Poller
              - Ref: SfnFindScanCandidates
              - Ref: SfnRoleUpdateStepFunction
          - Action: events:InvokeApiDestination
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - ":events:*:"
                  - Ref: AWS::AccountId
                  - :api-destination/qualys-step-destination-qualys-flow-api/*
        Version: "2012-10-17"
      PolicyName: EBRoleDefaultPolicy
      Roles:
        - Ref: EBRole
  UpdateSFTriggerRule:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        source:
          - aws.cloudformation
        detail-type:
          - CloudFormation Stack Status Change
        detail:
          stack-id:
            - Ref: AWS::StackId
          status-details:
            status:
              - CREATE_COMPLETE
              - UPDATE_COMPLETE
      Name: qualys-rule-update-sf
      ScheduleExpression: rate(30 minutes)
      State: ENABLED
      Targets:
        - Arn:
            Ref: SfnRoleUpdateStepFunction
          Id: Target0
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  PollEC2SFRule:
    Type: AWS::Events::Rule
    Properties:
      Name: qualys-poll-ec2-sfn-rule
      ScheduleExpression:
        Fn::Join:
          - ""
          - - rate(
            - Ref: PollRetryInterval
            - " minutes)"
      State: ENABLED
      Targets:
        - Arn:
            Ref: SfnEC2Poller
          Id: Target0
          RetryPolicy:
            MaximumRetryAttempts: 3
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  ScanEC2SFRule:
    Type: AWS::Events::Rule
    Properties:
      Name: qualys-scan-ec2-sfn-rule
      ScheduleExpression:
        Fn::Join:
          - ""
          - - rate(
            - Ref: EventsBatchWindow
            - " minutes)"
      State: ENABLED
      Targets:
        - Arn:
            Ref: SfnFindScanCandidates
          Id: Target0
          RetryPolicy:
            MaximumRetryAttempts: 3
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  CleanupSFRule:
    Type: AWS::Events::Rule
    Properties:
      Name: qualys-cleanup-sfn-rule
      ScheduleExpression: rate(1 hour)
      State: ENABLED
      Targets:
        - Arn:
            Ref: SfnCleanup
          Id: Target0
          Input: '{"minInstanceAge":2,"minSnapshotAge":12}'
          RetryPolicy:
            MaximumRetryAttempts: 3
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  RoleResourceEventsListener:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
        Version: "2012-10-17"
      RoleName: qualys-api-event-listener-role
  RoleResourceEventsListenerDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
              - sqs:SendMessage
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - SqsResourceEvents
                - Arn
          - Action:
              - kms:Decrypt
              - kms:Encrypt
              - kms:GenerateDataKey*
              - kms:ReEncrypt*
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - ServiceKmsKey
                - Arn
        Version: "2012-10-17"
      PolicyName: RoleResourceEventsListenerDefaultPolicy
      Roles:
        - Ref: RoleResourceEventsListener
  RoleResourceEventsNotifier:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: pipes.amazonaws.com
        Version: "2012-10-17"
      RoleName: qualys-pipe-events-notifier-role
  RoleResourceEventsNotifierDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action: states:StartExecution
            Effect: Allow
            Resource:
              - Ref: SfnCreateSnapshotWrapper
              - Ref: SfnResourceEventsSyncer
          - Action:
              - sqs:ChangeMessageVisibility
              - sqs:DeleteMessage
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
              - sqs:ReceiveMessage
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - SqsResourceEvents
                  - Arn
              - Fn::GetAtt:
                  - SqsSnapshotNotifications
                  - Arn
          - Action: kms:Decrypt
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - ServiceKmsKey
                - Arn
        Version: "2012-10-17"
      PolicyName: RoleResourceEventsNotifierDefaultPolicy
      Roles:
        - Ref: RoleResourceEventsNotifier
  SqsResourceEventsDlq:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MessageRetentionPeriod: 1209600
      QueueName: qualys-resource-events-dlq
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  SqsResourceEvents:
    Type: AWS::SQS::Queue
    Properties:
      KmsMasterKeyId:
        Fn::GetAtt:
          - ServiceKmsKey
          - Arn
      MessageRetentionPeriod: 604800
      QueueName: qualys-resource-events-queue
      ReceiveMessageWaitTimeSeconds: 20
      RedrivePolicy:
        deadLetterTargetArn:
          Fn::GetAtt:
            - SqsResourceEventsDlq
            - Arn
        maxReceiveCount: 3
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
      VisibilityTimeout: 60
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  PipeResourceEventsNotifier:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-events-notifier
      RoleArn:
        Fn::GetAtt:
          - RoleResourceEventsNotifier
          - Arn
      Source:
        Fn::GetAtt:
          - SqsResourceEvents
          - Arn
      SourceParameters:
        SqsQueueParameters:
          BatchSize: 50
          MaximumBatchingWindowInSeconds: 180
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Ref: SfnResourceEventsSyncer
      TargetParameters:
        StepFunctionStateMachineParameters:
          InvocationType: FIRE_AND_FORGET
  CreateSnapshotEventPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-snapshot-notifier
      RoleArn:
        Fn::GetAtt:
          - RoleResourceEventsNotifier
          - Arn
      Source:
        Fn::GetAtt:
          - SqsSnapshotNotifications
          - Arn
      SourceParameters:
        SqsQueueParameters:
          BatchSize: 1
          MaximumBatchingWindowInSeconds: 20
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Ref: SfnCreateSnapshotWrapper
      TargetParameters:
        StepFunctionStateMachineParameters:
          InvocationType: FIRE_AND_FORGET
  DbStreamEventsNotifierRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: pipes.amazonaws.com
        Version: "2012-10-17"
      RoleName: qualys-pipe-db-streams-notifier-role
      Tags:
        - Key: App
          Value: qualys-snapshot-scanner
  DbStreamEventsNotifierRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action: events:InvokeApiDestination
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:"
                  - Ref: AWS::Partition
                  - ":events:*:"
                  - Ref: AWS::AccountId
                  - :api-destination/qualys-destination-qualys-flow-api/*
          - Action: dynamodb:ListStreams
            Effect: Allow
            Resource: "*"
          - Action:
              - kms:Decrypt
              - kms:DescribeKey
            Effect: Allow
            Resource:
              Fn::GetAtt:
                - ServiceKmsKey
                - Arn
          - Action:
              - dynamodb:DescribeStream
              - dynamodb:GetRecords
              - dynamodb:GetShardIterator
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - AppConfigTable
                  - StreamArn
              - Fn::GetAtt:
                  - DiscoveryTaskTable
                  - StreamArn
              - Fn::GetAtt:
                  - TableEventLogs
                  - StreamArn
              - Fn::GetAtt:
                  - TableInventoryScanStatus
                  - StreamArn
              - Fn::GetAtt:
                  - TableResourceInventory
                  - StreamArn
        Version: "2012-10-17"
      PolicyName: DbStreamEventsNotifierRoleDefaultPolicy
      Roles:
        - Ref: DbStreamEventsNotifierRole
  ApiConnectionQualysFlowConnection:
    Type: AWS::Events::Connection
    Properties:
      AuthParameters:
        ApiKeyAuthParameters:
          ApiKeyName: DUMMY_HEADER_KEY
          ApiKeyValue: DUMMY_HEADER_VALUE
        InvocationHttpParameters:
          HeaderParameters:
            - IsValueSecret: true
              Key: Authorization
              Value:
                Fn::Join:
                  - ""
                  - - "Bearer "
                    - Ref: QToken
      AuthorizationType: API_KEY
      Name: qualys-connection-qualys-flow-api
  ApiDestinationQualysFlowApiDestination:
    Type: AWS::Events::ApiDestination
    Properties:
      ConnectionArn:
        Fn::GetAtt:
          - ApiConnectionQualysFlowConnection
          - Arn
      HttpMethod: POST
      InvocationEndpoint:
        Fn::Join:
          - ""
          - - Ref: QEndpoint
            - /qflow/aws-dynamodb
      InvocationRateLimitPerSecond: 10
      Name: qualys-destination-qualys-flow-api
  DynamodbStreamPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-dynamodb-inventory-stream
      RoleArn:
        Fn::GetAtt:
          - DbStreamEventsNotifierRole
          - Arn
      Source:
        Fn::GetAtt:
          - TableResourceInventory
          - StreamArn
      SourceParameters:
        DynamoDBStreamParameters:
          BatchSize: 1
          StartingPosition: LATEST
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Fn::GetAtt:
          - ApiDestinationQualysFlowApiDestination
          - Arn
      TargetParameters:
        HttpParameters: {}
    DependsOn:
      - DbStreamEventsNotifierRole
      - DbStreamEventsNotifierRoleDefaultPolicy
  DynamodbScanStatusStreamPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-dynamodb-scan-status-stream
      RoleArn:
        Fn::GetAtt:
          - DbStreamEventsNotifierRole
          - Arn
      Source:
        Fn::GetAtt:
          - TableInventoryScanStatus
          - StreamArn
      SourceParameters:
        DynamoDBStreamParameters:
          BatchSize: 1
          StartingPosition: LATEST
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Fn::GetAtt:
          - ApiDestinationQualysFlowApiDestination
          - Arn
      TargetParameters:
        HttpParameters: {}
    DependsOn:
      - DbStreamEventsNotifierRole
      - DbStreamEventsNotifierRoleDefaultPolicy
  DynamodbEventLogsStreamPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-dynamodb-event-logs-stream
      RoleArn:
        Fn::GetAtt:
          - DbStreamEventsNotifierRole
          - Arn
      Source:
        Fn::GetAtt:
          - TableEventLogs
          - StreamArn
      SourceParameters:
        DynamoDBStreamParameters:
          BatchSize: 1
          StartingPosition: LATEST
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Fn::GetAtt:
          - ApiDestinationQualysFlowApiDestination
          - Arn
      TargetParameters:
        HttpParameters: {}
    DependsOn:
      - DbStreamEventsNotifierRole
      - DbStreamEventsNotifierRoleDefaultPolicy
  DynamodbTaskTableStreamPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-dynamodb-task-table-stream
      RoleArn:
        Fn::GetAtt:
          - DbStreamEventsNotifierRole
          - Arn
      Source:
        Fn::GetAtt:
          - DiscoveryTaskTable
          - StreamArn
      SourceParameters:
        DynamoDBStreamParameters:
          BatchSize: 1
          StartingPosition: LATEST
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Fn::GetAtt:
          - ApiDestinationQualysFlowApiDestination
          - Arn
      TargetParameters:
        HttpParameters: {}
    DependsOn:
      - DbStreamEventsNotifierRole
      - DbStreamEventsNotifierRoleDefaultPolicy
  DynamodbAppConfigStreamPipe:
    Type: AWS::Pipes::Pipe
    Properties:
      Name: qualys-pipe-dynamodb-app-config-stream
      RoleArn:
        Fn::GetAtt:
          - DbStreamEventsNotifierRole
          - Arn
      Source:
        Fn::GetAtt:
          - AppConfigTable
          - StreamArn
      SourceParameters:
        DynamoDBStreamParameters:
          BatchSize: 1
          StartingPosition: LATEST
      Tags:
        App: qualys-snapshot-scanner
      Target:
        Fn::GetAtt:
          - ApiDestinationQualysFlowApiDestination
          - Arn
      TargetParameters:
        HttpParameters: {}
    DependsOn:
      - DbStreamEventsNotifierRole
      - DbStreamEventsNotifierRoleDefaultPolicy
  ApStepDestinationQualysFlowApiDestination:
    Type: AWS::Events::ApiDestination
    Properties:
      ConnectionArn:
        Fn::GetAtt:
          - ApiConnectionQualysFlowConnection
          - Arn
      HttpMethod: POST
      InvocationEndpoint:
        Fn::Join:
          - ""
          - - Ref: QEndpoint
            - /qflow/aws-stepfunctions
      InvocationRateLimitPerSecond: 10
      Name: qualys-step-destination-qualys-flow-api
  ApStepDestinationRuleFirst:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        detail:
          status:
            - SUCCEEDED
            - FAILED
            - TIMED_OUT
            - ABORTED
          stateMachineArn:
            - Ref: SfnSDKWrapper
            - Ref: SfnCommonConfig
            - Ref: SfnUpdateCommonConfig
            - Ref: SfnDynamoDbWrapper
            - Ref: SfnRegisterServiceAccount
            - Ref: SfnDeregisterServiceAccount
            - Ref: SfnEC2Poller
            - Ref: SfnRetryFailedSnapshots
            - Ref: SfnResourceEventsSyncer
            - Ref: SfnCreateSnapshot
        detail-type:
          - Step Functions Execution Status Change
        source:
          - aws.states
      Name: qualys-step-function-event-rule-first
      State: ENABLED
      Targets:
        - Arn:
            Fn::GetAtt:
              - ApStepDestinationQualysFlowApiDestination
              - Arn
          Id: Target0
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  ApStepDestinationRuleSecond:
    Type: AWS::Events::Rule
    Properties:
      EventPattern:
        detail:
          status:
            - SUCCEEDED
            - FAILED
            - TIMED_OUT
            - ABORTED
          stateMachineArn:
            - Ref: SfnCopySnapshot
            - Ref: SfnImageCopySnapshot
            - Ref: SfnCreateSnapshotWrapper
            - Ref: SfnFindScanCandidates
            - Ref: SfnFindScanCandidatesByScanType
            - Ref: SfnNotifyQflow
            - Ref: SfnScanInstances
            - Ref: SfnCreateInstance
            - Ref: SfnRunScanner
            - Ref: SfnCleanup
            - Ref: SfnProxyInstance
            - Ref: SfnScannerAmiCreation
            - Ref: SfnCliConfigGenerator
        detail-type:
          - Step Functions Execution Status Change
        source:
          - aws.states
      Name: qualys-step-function-event-rule-second
      State: ENABLED
      Targets:
        - Arn:
            Fn::GetAtt:
              - ApStepDestinationQualysFlowApiDestination
              - Arn
          Id: Target0
          RoleArn:
            Fn::GetAtt:
              - EBRole
              - Arn
  AGEventListenerApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      ApiKeySourceType: HEADER
      EndpointConfiguration:
        Types:
          - REGIONAL
      Name: qualys-api-event-listener
  AGEventListenerApiDeploymentf222637d7aaa0daafffcdac5463676f1:
    Type: AWS::ApiGateway::Deployment
    Properties:
      Description: Automatically created by the RestApi construct
      RestApiId:
        Ref: AGEventListenerApi
    DependsOn:
      - AGEventListenerApiResourcePOST
      - AGEventListenerApiResource
    Metadata:
      aws:cdk:do-not-refactor: true
  AGEventListenerApiDeploymentStagev1:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId:
        Ref: AGEventListenerApiDeploymentf222637d7aaa0daafffcdac5463676f1
      MethodSettings:
        - DataTraceEnabled: false
          HttpMethod: "*"
          ResourcePath: /*
          ThrottlingBurstLimit: 100
          ThrottlingRateLimit: 25
      RestApiId:
        Ref: AGEventListenerApi
      StageName: v1
  AGEventListenerApiCustomAGDomainName:
    Type: AWS::ApiGateway::DomainName
    Properties:
      DomainName:
        Ref: Route53DomainName
      EndpointConfiguration:
        Types:
          - REGIONAL
      RegionalCertificateArn:
        Ref: EventListenerApiGatewayCustomDomainApiGatewayCertificate
    Condition: shouldDeployCustomDomain
  AGEventListenerApiCustomAGDomainNameMapQualysAGEventListenerApi18D1F930:
    Type: AWS::ApiGateway::BasePathMapping
    Properties:
      DomainName:
        Ref: AGEventListenerApiCustomAGDomainName
      RestApiId:
        Ref: AGEventListenerApi
      Stage:
        Ref: AGEventListenerApiDeploymentStagev1
    Condition: shouldDeployCustomDomain
  AGEventListenerApiResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId:
        Fn::GetAtt:
          - AGEventListenerApi
          - RootResourceId
      PathPart: events
      RestApiId:
        Ref: AGEventListenerApi
  AGEventListenerApiResourcePOST:
    Type: AWS::ApiGateway::Method
    Properties:
      ApiKeyRequired: true
      AuthorizationType: NONE
      HttpMethod: POST
      Integration:
        Credentials:
          Fn::GetAtt:
            - RoleResourceEventsListener
            - Arn
        IntegrationHttpMethod: POST
        IntegrationResponses:
          - ResponseTemplates:
              application/json: "{}"
            StatusCode: "200"
        RequestParameters:
          integration.request.header.Content-Type: "'application/x-www-form-urlencoded'"
        RequestTemplates:
          application/json: Action=SendMessage&MessageBody=$input.body
        Type: AWS
        Uri:
          Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - ":apigateway:"
              - Ref: AWS::Region
              - :sqs:path/
              - Ref: AWS::AccountId
              - /qualys-resource-events-queue
      MethodResponses:
        - ResponseModels:
            application/json: Empty
          ResponseParameters:
            method.response.header.x-amz-apigw-id: false
            method.response.header.x-amzn-errortype: false
            method.response.header.x-amzn-requestid: false
            method.response.header.x-amzn-trace-id: false
          StatusCode: "200"
      OperationName: ListenEvents
      ResourceId:
        Ref: AGEventListenerApiResource
      RestApiId:
        Ref: AGEventListenerApi
  AGEventListenerApiUsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Properties:
      ApiStages:
        - ApiId:
            Ref: AGEventListenerApi
          Stage:
            Ref: AGEventListenerApiDeploymentStagev1
          Throttle: {}
      Quota:
        Limit: 10000
        Period: DAY
      Throttle:
        BurstLimit: 100
        RateLimit: 25
      UsagePlanName: qualys-usage-plan-event-listener-api
  AGEventListenerApiUsagePlanUsagePlanKeyResourceQualysAGEventListenerApiKey0F8E8C20:
    Type: AWS::ApiGateway::UsagePlanKey
    Properties:
      KeyId:
        Ref: AGEventListenerApiKey
      KeyType: API_KEY
      UsagePlanId:
        Ref: AGEventListenerApiUsagePlan
  AGEventListenerApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Enabled: true
      GenerateDistinctId: true
      Name: qualys-api-key-event-listener-api
      Value:
        Fn::Select:
          - 2
          - Fn::Split:
              - "."
              - Ref: QToken
  EventListenerApiGatewayCustomDomainApiGatewayCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName:
        Ref: Route53DomainName
      DomainValidationOptions:
        - DomainName:
            Ref: Route53DomainName
          HostedZoneId:
            Ref: Route53DomainId
      Tags:
        - Key: Name
          Value: Qualys/EventListenerApiGatewayCustomDomain/ApiGatewayCertificate
      ValidationMethod: DNS
    Condition: shouldDeployCustomDomain
  EventListenerApiGatewayCustomDomainRoute53RecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      AliasTarget:
        DNSName:
          Fn::GetAtt:
            - AGEventListenerApiCustomAGDomainName
            - RegionalDomainName
        HostedZoneId:
          Fn::GetAtt:
            - AGEventListenerApiCustomAGDomainName
            - RegionalHostedZoneId
      Comment: API Gateway Custom Domain for cross account event listener
      HostedZoneId:
        Ref: Route53DomainId
      Name:
        Fn::Join:
          - ""
          - - Ref: Route53DomainName
            - "."
      Type: A
    Condition: shouldDeployCustomDomain
  CleanupCustomResource:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken:
        Fn::Join:
          - ""
          - - "arn:"
            - Ref: AWS::Partition
            - ":lambda:"
            - Ref: AWS::Region
            - ":"
            - Ref: AWS::AccountId
            - :function:qualys-cft-cleanup
    DependsOn:
      - AGProxyApi
      - AGProxyApiResource
      - AGProxyProxyMethod
      - ApStepDestinationRuleFirst
      - ApStepDestinationRuleSecond
      - LambdaAmiTaskScheduler
      - LambdaAppConfigStore
      - LambdaCFTCleanupFunction
      - LambdacreateInventoryScanStatus
      - LambdaDataFormatter
      - LambdaDownloadToS3
      - LambdaDynamoDbWrapper
      - LambdaEventBasedTaskScheduler
      - LambdafetchInventoryChunks
      - LambdagenerateScanInstancesParams
      - LambdagenerateScanTypesChunks
      - LambdaOnDemandScanLambda
      - LambdaPostProcessScan
      - LambdaProcessScanS3Files
      - LambdaS3CreateBucket
      - LambdaScannerAmiCleanupFunction
      - LambdaScheduledSfnCheck
      - LambdaSDKWrapper
      - LambdaTaskScheduler
      - LambdaTaskWorker
      - LambdaUpdateLambdaCode
      - RegionStackSet
      - ServiceKmsKey
      - SFAccess
      - SfnCleanup
      - SfnCliConfigGenerator
      - SfnCommonConfig
      - SfnCopySnapshot
      - SfnCreateInstance
      - SfnCreateSnapshot
      - SfnCreateSnapshotWrapper
      - SfnDeregisterServiceAccount
      - SfnDynamoDbWrapper
      - SfnEC2Poller
      - SfnFindScanCandidates
      - SfnFindScanCandidatesByScanType
      - SfnImageCopySnapshot
      - SfnNotifyQflow
      - SfnProxyInstance
      - SfnRegisterServiceAccount
      - SfnResourceEventsSyncer
      - SfnRetryFailedSnapshots
      - SfnRunScanner
      - SfnScanInstances
      - SfnScannerAmiCreation
      - SfnSDKWrapper
      - SfnUpdateCommonConfig
Outputs:
  AGProxyApiEndpoint:
    Value:
      Fn::Join:
        - ""
        - - https://
          - Ref: AGProxyApi
          - .execute-api.
          - Ref: AWS::Region
          - "."
          - Ref: AWS::URLSuffix
          - /
          - Ref: AGProxyApiDeploymentStagev0
          - /
  AGEventListenerApiEndpoint:
    Value:
      Fn::Join:
        - ""
        - - https://
          - Ref: AGEventListenerApi
          - .execute-api.
          - Ref: AWS::Region
          - "."
          - Ref: AWS::URLSuffix
          - /
          - Ref: AGEventListenerApiDeploymentStagev1
          - /
  ServiceAccountApiEndpoint:
    Value:
      Fn::If:
        - EnabledCustomDomain
        - Fn::Join:
            - ""
            - - https://
              - Ref: Route53DomainName
              - /events
        - Fn::Join:
            - ""
            - - https://
              - Ref: AGEventListenerApi
              - .execute-api.
              - Ref: AWS::Region
              - "."
              - Ref: AWS::URLSuffix
              - /
              - Ref: AGEventListenerApiDeploymentStagev1
              - /events
Conditions:
  EnabledCustomDomain:
    Fn::Equals:
      - Ref: EnableCustomDomain
      - Enabled
  shouldDeployCustomDomain:
    Fn::Equals:
      - Ref: EnableCustomDomain
      - Enabled

